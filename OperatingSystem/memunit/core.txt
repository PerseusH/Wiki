- **进程是资源分配单位，线程是CPU调度单位**，对大多数操作系统来说，**时间片是线程而非进程相关的**

## 并行

- 两个或两个以上事件或活动在同一时刻发生. 在多道程序环境下, 并行性使'多个程序同一时刻'可在不同CPU上同时执行

## 并发

- 实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用, 并发性是对'有限物理资源'强制行使'多用户共享'以提高效率

## 处理机

- *处理机*=**CPU+主存储器(内存)+输入输出设备接口**
- 处理机包括中央处理器，主存储器，输入-输出接口，加接外围设备就构成完整的计算机系统。处理机是处理计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。程序是描述处理机完成某项任务的指令序列。指令则是处理机能直接解释、执行的信息单位

## 时间片

- 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番执行相应的时间，当所有进程都处于**时间片耗尽**的状态时，内核会**重新为每个进程计算并分配时间片**，如此往复
- 通常状况下，一个系统中所有的进程被分配到的时间片长短并不是相等的，尽管初始时间片基本相等（在Linux系统中，初始时间片也不相等，而是各自父进程的一半），**系统通过测量进程处于“睡眠”和“正在运行”状态的时间长短来计算每个进程的交互性，交互性和每个进程预设的静态优先级（Nice值）的叠加即是动态优先级**，动态优先级按比例缩放就是要分配给那个进程时间片的长短。为了获得较快的响应速度，交互性强的进程（IO消耗型）被分配到的时间片要长于交互性弱的（处理器消耗型）进程
- 时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。调度策略必须规定一个默认的时间片，但这并不是件简单的事。时间片过长会导致系统对交互的响应表现欠佳；让人觉得系统无法并发执行应用程序。时间片太短会明显增大进程切换带来的处理器耗时，因为肯定会有相当一部分系统时间用在进程切换上，而这些进程能够用来运行的时间片却很短。此外，I/O消耗型和处理器消耗型的进程之间的矛盾在这里也再次显露出来：I/O消耗型不需要长的时间片，而处理器消耗型的进程则希望越长越好（比如说这样可以让它们的高速缓存命中率更高）
- Linux调度程序提高交互式程序的优先级，让它们运行得更频繁。于是，调度程序提供较长的默认时间片给交互式程序。此外，Linux调度程序还能根据进程的优先级动态调整分配给它的时间片。从而保证了优先级高的进程，假定也是重要性高的进程，执行的频率高，执行时间长。通过实现这样一种动态调整优先级和时间片长度的机制，Linux调度性能不但非常稳定而且也很强健
- 注意，进程并不是一定非要一次就用完它所有的时间片。举例来说，一个拥有100毫秒时间片的进程并不一定在一次运行中就要用完所有这些时间。相反，进程可以通过重复调度，分五次每次20毫秒用完这些时间片。这样，即使是交互式程序也能从中获益—当它们没必要一次用这么多时间的时候，它们可以分几次使用，这样能保证它们尽可能长时间的处于可运行状态
- 如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。而不会造成CPU资源浪费
- 如果优先级低，线程再多也不能加快执行速度，即使进程是单线程也是通过操作系统来调度的，也会分配时间片，因为后台还有许多线程在调度执行
- 线程的调度执行是有优先级的，优先级高的得到更多时间片，Linux系统中优先级高的线程时间片大于优先级低的时间片，所以**进程有多个线程并不一定会占用更多CPU时间**

