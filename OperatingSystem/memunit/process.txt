- 一个CPU在同一时间只能有一个进程在运行
## PCB(Processing Control Block)

- 进程控制块是操作系统**内核空间**的一个**数据结构(struct)**，用来管理和控制和进程的信息，它是一个程序在多道程序下能够独立运行的基本单位，成为可以并发执行的进程。OS是通过进程数据块来实现对进程的管理和控制的

- PCB是进程存在的唯一标志

- **1.进程标识符信息**
  每个进程都必须有一个唯一的标识符，可以是字符串，也可以是一个数字。UNIX系统中就是一个整型数。在进程创建时由系统赋予。进程标识符用于唯一的标识一个进程。一个进程通常有以下两种标识符。
  (1)外部标识符：由创建者提供，通常是由字母、数字组成，往往是用户（进程）访问该进程使用。外部标识符便于记忆，如：计算进程、打印进程、发送进程、接收进程等。
  (2)内部标识符：为了方便系统使用而设置的。在所有的OS中，都为每一个进程赋予一个唯一的整数，作为内部标识符。它通常就是一个进程的符号，为了描述进程的家族关系，还应该设置父进程标识符以及子进程标识符。还可以设置用户标识符，来指示该进程由哪个用户拥有。
  **2.处理机状态信息**
  说明进程当前状态，为了管理的方便，系统设计时会将相同的状态的进程组成一个队列，如就绪进程队列，等待进程则要根据等待的事件组成多个等待队列，如等待打印机队列、等待等。处理机状态信息主要是由处理机各种寄存器中的内容所组成。
  **通用寄存器：**又称为用户可视寄存器，可被用户程序访问，用于暂存信息。
  **指令寄存器：**存放要访问的下一个指令的地址。
  **程序状态字PSW：**其中包含状态信息。（条件码、执行方式、中断屏蔽标志）
  **用户栈指针：**每个用户进程由一个或多个与之相关的系统栈，用户存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。
  **3.进程调度信息**
  在PCB中还存放了一些与进程调度和进程对换有关的信息。
  （1）进程的状态。指明进程当前的状态，作为进程调度和对换时的依据。
  （2）进程的优先级。用于描述进程使用处理机的优先级别的一个整数，优先级高的进程优先获得处理机。
  （3）进程调度所需要的其他信息。（进程已等待CPU的时间总和、进程已执行的时间总和）
  （4）**事件**。这是进程**由执行状态转变为阻塞状态所等待发生的事件**。（阻塞原因）

  #### 组织方式(内核空间)
  
  1. `线性表`不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。
  2. `索引表`该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。
  3. `双向链表`系统按照进程的状态将进程的PCB组成队列，从而形成**就绪队列、阻塞队列、运行队列**等。

## 进程内存分配(Linux 32bit)

- 每个进程运行的时候，都会分配到4G的虚拟内存地址空间，0-3G为用户空间(对系统中其他进程不可见)，3-4G为内核空间(所有进程共享, 为了执行系统调用)，PCB的struct就是在这个内核空间，进程管理就是在内核空间中进行的
  - 只有**虚拟地址空间**才分用户态和内核态，**物理内存没有这种划分**
- 在32位的平台上，线性地址的大小为固定的4GB。并且，由于采用了保护机制，Linux内核将这4GB分为两部分，虚地址较高的1GB（0xC0000000到0xFFFFFFFF）为共享的内核空间；而较低的3GB（0x00000000到0xBFFFFFFF）为每个进程的用户空间
- 由于每个进程都不能直接访问内核空间，而是通过系统调用间接进入内核，因此**所有进程共享内核空间**。而每个进程都拥有各自的用户空间，各个进程之间不能互相访问彼此的用户空间。因此，对于每一个具体的进程而言，都拥有4GB的虚拟地址空间
- 内核在创建进程的时候，会为进程创建两个栈，内核栈和用户栈。 用户栈存在于用户空间，内核栈存在于内核空间。当进程在用户空间运行时，使用用户栈；当进程在内核空间运行时，使用内核栈。
- `进程上下文`一个进程所具有的全部信息，包括PCB，程序段，数据段，CPU现场信息(堆，栈，内部寄存器)
- 进程运行状态分为内核运行态和用户运行态。内核空间态资源包括内核的堆栈、寄存器等；用户空间态资源包括虚拟内存、栈、变量、正文、数据等
- Linux进程地址空间可以分成两大类，**文件映射和匿名映射**。文件映射是指该地址空间的内容来自于一个文件；而匿名映射地址空间背后什么靠山都没有。进程的**代码段**来自于镜像，采用**文件映射**；**栈，堆，bss段，数据段是匿名映射**

##### 内核态(3-4G)

- **PCB**

##### 用户态(0-3G)

1. `数据区` 包含有程序初始化的全局变量和静态变量，可进一步划分为只读区和读写区，是程序虚拟地址空间的一部分。位于**内存低位**
2. `代码区` 二进制可执行指令机器代码，处理器会到这个区域取指并执行，代码段是只读的，以防止程序以外修改指令。位于**内存低位**
3. `bss段`（Block Started by Symbol）通常是指用来存放全局或静态的未初始化变量的内存区域。属于静态内存分配。位于**内存低位**
4. `堆` 进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。手动分配和回收内存是堆的特点。位于**内存低位**，向上增长。数据结构类似**链表**
5. `内存映射区(memory mapping region)`用户态**虚拟内存的绝大部分**空闲区域，位于**堆与栈之间**
6. `栈` 用于动态地存储函数之间的关系，以保证被调用函数在返回时恢复到父函数中继续执行。存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存,结束时自动释放内存。位于**内存高位**，向下增长

- 代码段,数据段,bss段，直接从磁盘拷贝到当前的内存空间
- 程序在执行时,会动态的申请空间,执行子函数(栈)

## fork()

- fork函数通过系统调用**创建**一个与原来进程几乎完全相同的进程，**复制或共享地址空间与资源**

- 执行一次却**返回两个值，在两个进程中的返回值是不同的**。在子进程中，fork函数返回0，在父进程中，fork返回新创建**子进程的进程ID**。我们可以通过fork()返回的值来判断当前进程是子进程还是父进程
- 创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行**没有固定的先后顺序**，哪个进程先执行要看系统的进程调度策略
- 因为**写时复制**，fork()的实际开销就是复制父进程的**页表**以及给子进程创建一个**进程描述符**。在一般情况下，进程创建后都为马上运行一个可执行的文件，这种优化，可以避免拷贝大量根本就不会被使用的数据(地址空间里常常包含数十兆的数据)
- 子进程在被创建后多会执行exec系统调用
- fork之后内核会通过**将子进程放在队列的前面**，以让子进程先执行，以免父进程执行导致写时复制，而后子进程执行exec系统调用，因无意义的复制而造成效率的下降

## exec( )函数族

- 用来启动别的进程以取代当前运行的进程。**exec函数会取代执行它的进程**，一旦exec函数执行成功, 它就不会返回了, 当前进程结束。如果exec函数执行失败, 它会返回失败的信息,  而且进程继续执行后面的代码
- 一个进程一旦调用exec类函数，它本身就"死亡"了，并不会创建新的进程，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序**分配新的数据段与堆栈段**，**唯一留下的就是进程号**，对系统而言还是同一个进程，不过已经是另一个程序了。（不过exec类函数中有的还允许继承环境变量之类的信息）
-  通常exec会放在fork() 函数的**子进程**部分, 来**替代子进程原程序**, 执行成功后子进程原程序就会消失,  但是执行失败的话, 必须用exit()函数来让子进程退出。当子进程调用exec函数来**运行另一个程序**时，这个进程的地址空间代码和数据都被新程序的代码和数据刷新替换

## 进程上下文切换

- 进程调度函数schedule()，该函数是操作系统内核函数，并非系统调用，只能在内核态中由内核代码主动调用。因此用户态进程无法主动进行进程调度，只能在中断发生时被动调度，而内核态线程即可以被动调度，也可以主动发起进程调度。在**各种系统调用、中断的返回代码最后，在返回用户态代码(ret_from_sys_call)之前**，内核会决定是否调用schedule，被动进程调度的时机位于**发生中断并且系统执行完毕对应的中断服务程序之后**。如果没有进程调度，就会iret，回到用户态接着执行

- 进程是由内核来管理和调度的，**进程的切换只能发生在内核态**。进程上下文切换是**计算密集型**的任务。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作

- 上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：（1）挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处，（2）在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复，（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程

  #### 上下文切换过程

  - 记录当前任务的上下文(CPU寄存器和程序计数器)
  - 加载新任务的上下文到这些寄存器和程序计数器
  - 跳转到程序计数器所指的新位置, 运行新任务
  
  #### 触发进程上下文切换的场景
  (1) 为了保证所有进程得到公平调度，CPU时间被划分一段段时间片，这些时间片轮流分给进程，当时间片耗尽，进程会被挂起，等待下一次分配cpu时间片
  (2) 进程运行的系统资源不足，比如内存不足，进程必须得倒资源满足才可以运行，这个时候会被挂起，系统会调度其他可运行的进程。执行中进程提出I/O请求后被阻塞
  (3) 进程通过睡眠函数 **sleep** 这样的方法将自己主动挂起;
  (4) 当有**更高优先级的进程需要运行**时, 当前进程会被挂起;
  (5) 发生**硬件中断**时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序
  
  6. 在执行完系统调用等系统程序后返回用户进程时
  
- 自愿上下文切换(系统调用)变多，说明进程在等待资源，可能**I/O**等其他问题 

- 非自愿上下文切换变多，说明进程被强制调度，争抢cpu，**cpu是瓶颈**

- 中断次数增多，说明cpu被中断处理程序占用，要通过/proc/interrupts文件来分析具体的中断类

## 进程优先级

- **IO密集型**进程(CPU消耗低)大部分时间都在提交或者等待I/O请求，因此这样的进程要经常处于运行状态，但通常都是短短的一会儿，所以处理器倾向于优先调度IO密集型的进程。该类进程**优先级高，时间片长**；**CPU密集型**则相反，**优先级低、时间片短**。这样只要内核一完成I/O操作，该进程立刻就会被唤醒，处理后续操作，那么**在用户看来，该进程响应非常快**，体现出了很好的用户友好性

- **交互式程序**(如：**键盘输入**)都是I/O消耗型的，所以调度程序向这种类型的进程倾斜会缩短系统响应时间。Linux为了保证交互式应用，所以对进程的响应作了优化（**缩短响应时间**），更倾向于优先调度I/O消耗型进程，因此，这样的进程经常处于可运行状态，使得**界面反应更加迅速**

- **CPU密集型**进程把时间大多用在执行代码上。除非被抢占，否则它们通常都一直不停地运行，因为它们没有太多的I/O需求。因为它们不属于I/O驱动类型，所以从系统响应速度考虑，调度器不应该经常让它们运行。对于这类处理器消耗型的进程，调度策略是尽量**降低它们的运行频率**，对它们而言，**延长其运行时间**会更合适些。处理器消耗型进程的极端例子就是**无限循环**地执行

- Linux根据基于优先级调度思想实现了一种动态优先级调度方法。一开始，该方法先设置基本的优先级，然而它允许调度程序根据需要来加、减优先级。举个例子，如果一个进程在I/O等待上耗费的时间多于其运行时间，那么该进程明显属于I/O消耗型进程。它的优先级会被动态提高。作为一个反例，如果一个进程的全部时间片一下就被耗尽，那么该进程属于处理器消耗型进程，它的优先级会被动态地降低

- 1)如果处理器消耗型进程的优先级高，时间片长，那么它就是实打实地消耗完它的时间片后，系统才会为其他低优先级的进程服务

  2)如果I/O消耗型进程的优先级高，时间片长，则因为频繁的IO操作并等待完成，需要处理器处理的时间其实很少，这样系统会自动将其等待的时间片分配给其他需要服务的进程

  显然2更合理

## 进程状态

- **队列**：就绪队列，阻塞队列，挂起队列，进程在队列之间切换，队列的单元是各种状态的PCB

- `就绪(Ready)`进程已分配到除CPU以外的所有必要的资源，只要获得**处理机时间片**便可立即执行
  - 等待被执行的状态即就绪态
  - 出现场景：**时间片切换**
- `执行(Running)`进程已获得处理机，其程序正在处理机上执行
- `阻塞(Blocked)`正在执行的进程，由于等待某个事件发生而无法执行时，进程自己调用阻塞原语阻塞自己，放弃处理机而处于阻塞状态，是**进程自主行为**
  - 出现场景：等待I/O完成、申请缓冲区不能满足、等待信号等
  - 也被称为**等待状态(Wait)，休眠状态(Sleep)**
  - 当一个等待事件结束会产生一个中断，激活被阻塞的进程
  - 进程的阻塞和唤醒显然是由进程切换来完成
  - 阻塞的进程**不可被中断**，阻塞的进程依然**在内存里**
  - 因为拿不到IO资源，所以阻塞时会**放弃 CPU**的占用
  - 阻塞状态最明显的表现是，进程不能被调度，并且等待自己所需要的资源
  - 当内存中所有进程阻塞时，OS可将一进程置为**挂起态**并交换到外存，再调入另一个进程执行
- `挂起(Suspend)`**操作系统**利用挂起原语把一个**进程所有资源**暂时从**内存转到外存(硬盘，磁盘)**，针对的是进程而非线程
  - 执行过程：检查要被挂起进程的状态，若处于活动就绪态就修改为挂起就绪，若处于阻塞态，则修改为挂起阻塞。被挂起进程**PCB的非常驻部分**要交换到磁盘对换区
  - 挂起一般用于**程序调试**中的条件中断，当出现某个条件的情况下挂起，然后进行单步调试
  - 挂起操作引起的状态变化是**进程级状态变化**而非线程状态变化
  - **就绪态的优先级高于阻塞态**，OS优先选择处于阻塞状态的进程，将其变为阻塞挂起，释放内存
  - **阻塞挂起->就绪挂起**：导致阻塞发生的某事件已经完成了，进程可以继续运行了，但只是改变了状态，数据资源等依然在硬盘上
  - `激活`当条件允许的时候，如果**没有就绪进程**，被挂起的进程资源被操作系统调用激活原语，**由磁盘调回内存**，重新进入等待被执行的状态即就绪态，系统在超过一定的时间没有任何动作
    - 把进程PCB非常驻部分调进内存，然后修改它的状态，挂起阻塞态改为阻塞态，挂起就绪态改为就绪态，并分别排入相应队列中
    - 当**没有活动就绪进程时**或静止就绪队列里面有进程**优先级高于活动就绪里面所有进程**，还有就是当一个进程**释放足够内存**时，系统会把一个高优先级挂起激活。而阻塞却没有对应的主动行为来解除，需要其他进程或系统唤醒
  - 挂起原因
    - （1）终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。
      （2）父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。
      （3）负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。
      （4）操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。
      （5）对换的需要。为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上

## 进程间通信IPC

- **最快的方式是mmap共享内存**