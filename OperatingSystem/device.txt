## 设备控制器

- CPU并不是系统中唯一的智能设备，每个物理设备都拥有自己的控制器。键盘、鼠标和串行口由一个高级I/O芯片统一管理，IDE控制器控制IDE硬盘而SCSI控制器控制SCSI硬盘等等。每个硬件控制器都有各自的控制状态寄存器（CSR）并且各不相同。例如Adaptec 2940 SCSI控制器的CSR与NCR 810 SCSI控制器完全不一样。这些寄存器用来启动、停止、初始化设备以及对设备进行诊断
- 当某进程要启动某个I/O设备工作时，便由CPU向相应的设备控制器发出一条I/O命令，然后立即返回继续执行原来的任务，设备控制器则按照该命令的要求去控制指定I/O设备
- 例如，在输入时，当设备控制器收到CPU发来的读命令后，便去控制相应的输入设备读数据。将要输入的数据送到接口电路的数据寄存器（即**准备好要输入的数据**）后，控制器便通过控制线**向CPU发送一个中断信号**，由CPU检查输入过程中是否出错，若无错，便向控制器发送取走数据的信号，然后再通过控制器及数据线，将数据写入内存单元中

## 设备驱动(DeviceDrive)

- Linux 中管理硬件设备控制器的代码并没有放置在每个应用程序中而是由内核统一管理，这些**管理设备控制器**的软件就是设备驱动程序。Linux 内核的设备管理是由一组**运行在内核中**，驻留在内存以及对底层硬件进行处理的共享库的驱动程序来完成的
- 通过**文件描述符FD**访问设备或文件
- 驱动程序属于内核代码，和内核中其它代码一样运行在内核态。设备驱动程序必须为 Linux 内核或其它子系统提供一个标准的API，这个API就是file_opertions，并且可以使用标准的**内核服务**如内存分配、中断发送和等待队列等等
- 设备控制器对设备本身的控制是电器工程师所关心的事情，操作系统对输入/输出设备的管理只是通过**文件系统和驱动程序**来完成。也就是说在操作系统中，**输入/输出系统只关心驱动程序**
- 在Linux中，设备驱动程序是一组相关函数的集合。它包含设备服务子程序和中断处理程序
  - 设备服务子程序包含了所有与设备相关的代码，每个设备服务子程序只处理一种设备或者紧密相关的设备。其功能就是从与设备无关的软件中接受抽象的命令并执行
  - 当执行一条请求时，根据控制器对驱动程序提供的接口（指的是控制器中的各种寄存器），并利用**中断机制**去调用中断服务子程序配合设备来完成这个请求
- 这样通过层层隔离，对用户进程基本上屏蔽了设备的各种特性，使用户的操作简便易行，不必去考虑具体设备的运作，就象对待文件操作一样去操作设备

## 文件系统

- 设备管理的一个基本特征是设备处理的抽象性，即所有**硬件设备**都被视作**文件**，可以通过用操纵普通文件相同的系统调用来**打开、关闭、读取和写入设备**。系统中每个设备都用一种设备特殊文件来表示，例如系统中第一个IDE硬盘被表示成/dev/hda。键盘、显示器、串口、磁盘等设备在**/dev 目录**下都有一个特殊的**设备文件**与之对应,这些设备文件也可以像普通磁盘文件一样打开、读、写和关闭,使用的函数接口是相同的

- 直接对存储器进行读写操作，反复的操作会产生**内存碎片**降低存储器的工作效率，所以Linux引入文件系统，就是将二进制的数据进行加工，使加工后的数据加载到存储设备中

- 当用户进程发出IO请求时，系统把请求处理的权限放在**文件系统**，文件系统通过驱动程序提供的接口将任务下放到驱动程序，驱动程序根据需要对设备控制器进行操作，设备控制器再去控制设备本身
  
- 由于要存储的数据是被重新加工后再被存储的，因此我们可以将数据的存储位置、大小等信息也存到存储器中，这样，再进行数据查找、插入或删除时，就会便得到相当容易，就是因为这种抽象性，文件系统才不能代表一个具体的存储载体，而必须依托某一个具体的存储设备才会有意义

- 内核为每个进程在其地址空间中都维护了结构体struct* fd_array[]用于维护该进程地址空间中打开的文件的指针；同时内核维护了**系统级的文件描述符表**用以记录该**系统打开的所有文件**，供所有进程之间共享；每个被打开的文件都由一个对应的inode结构体表示，由系统级的文件描述符表指向。所以，**进程**通过自己地址空间中的**打开文件描述符表**可以找到系统级的文件描述符表，进而**找到文件**

- ### 数据结构(Struct)

  1. `inode`索引节点
  
- 列出了**设备编号**，**文件静态属性**，文件中各个数据块在**磁盘中的位置**，以及对应的**驱动程序**等信息。因此，每个存储在存储器中的文件都会有一个索引节点与之对应。也就是说，索引节点就是存储在存储器中的数据抽象
  
- 文件系统的架构之中首先肯定是要有一个结构，用来描述文件系统的基本对象也就是文件，从而引入索引节点的概念，文件实体和文件的inode是一一对应的，在Linux中创建一个文件(包括设备)时，就会在相应的文件系统创建一个inode
     - 创建好一个inode会存在**内存**中，第一次open就会将inode在**内存**建立一个备份，同一个文件被多次打开并不会产生多个inode，当所有被打开的文件都被close之后，inode在内存中的实例才会被释放
   - inode作为VFS四大对象之一，在驱动开发中很少需要自己进行填充，更多的是在open()方法中进行查看并根据需要填充我们的file结构
     
  2. `file`
  
   - 系统中**每个打开的文件**在内核态都有一个对应的file结构体
  
   - **Linux内核会为每一个进程维护一个文件描述符表**，这个表其实就是struct file[]的索引。open()的过程其实就是根据传入的路径填充好一个file结构并将其赋值到数组中并返回其索引
     - f_path里存储的是open传入的路径，VFS就是根据这个路径逐层找到相应的inode
   - f_inode里存储的是找到的inode
     - f_ops里存储的就是驱动提供的file_operations对象，这个对象在open的时候被填充
     - f_count的作用是记录对文件对象的**引用计数**，也即当前有多少个使用CLONE_FILES标志克隆的进程在使用该文件。典型的应用是在POSIX线程中。就像在内核中普通的引用计数模块一样，最后一个进程调用put_files_struct()来释放文件描述符
     - f_mode是**对文件的读写模式**，对应系统调用open的mod_t mode参数。如果驱动程序需要这个值，可以直接读取这个字段
     - private_data表示file结构的私有数据
  
  3. `file_operations`
  
   - 设备驱动程序利用结构  **file_operations**  与文件系统联系起来，file_operations里面定义了**文件操作函数**
     - 驱动运行过程中会被注册到驱动里，之后会赋值给file结构体的f_ops字段

## 驱动分类

- 驱动程序分为两大类：**字符设备和块设备**
  1. 字符设备：每次传输数据时**以字符为基本单位**的设备，如**键盘和声卡**等。他们通常不支持随机存取数据，因此对字符设备的处理非常直观简单，字符设备在实现时也大多不需要缓存，**系统直接从设备读取/写入每一个字符**
  2. 块设备：与字符设备相对的，**批量数据传输的设备**，如**硬盘，CD-ROM**等。块设备支持随存取和寻址并使用缓存，这几点与字符设备相对的，操作系统会为块设备的输入或输出过程分配缓存，以存储临时读出或写入的数据。当缓存被填满时，会采取适当的操作把数据传走，而后系统清空缓存。这种针对设备的缓存机制其实是广泛存在的，目的就是使**访问速度较慢的块设备**，能够适当的提高读写效率
- Linux设备中**用的最多的是字符设备**
