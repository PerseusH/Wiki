- 内核缓冲区是所有I/O的基础，**I/O就是把数据移进或移出内核缓冲区**；进程执行I/O操作，就是向操作系统发出请求，让它要么把缓冲区的数据排干(写)，要么填充缓冲区(读)
- **进程缓冲区**的目的是为了**减少系统调用次数**,从而降低操作系统在用户态与核心态切换所耗费的时间
  - 用户态/内核态切换是比较费时的，所以一次读入大量的数据放在进程缓冲区，需要的时候**从进程缓冲区读取数据**，以避免频繁的系统调用陷入内核
  - 进程缓冲区是由IO库实现的
- **内核缓冲区**，是为了**减少磁盘IO次数**，优化磁盘**写操作**
  - 磁盘是数据块 的集合，内核会对**磁盘数据块**做缓冲。内核将磁盘上的数据块复制到内核缓冲区中，当一个用户进程要从磁盘上读数据时，内核一般**不直接读磁盘**，而 是将内核缓冲区中的数据复制到进程的缓冲区中。当进程所要求的数据块不在内核缓冲区时，内核会把相应的数据块加入到请求队列，然后把该进程挂起，接着为其 他进程服务。一段时间之后(其实很短的时间)，内核把相应的数据块以**DMA方式**从磁盘读到内核缓冲区，然后再把数据复制(read)到进程的缓冲区中，最后唤醒被挂起的进程
  - 每个**TCP** socket 被创建后，都会被分配两个**内核**缓冲区，**输入缓冲区和输出缓冲区**
    - write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器
    - read()/recv() 函数从输入缓冲区中读取数据，而不是直接从网络中读取
  - 每个**UDP** Socket都有一个接收缓冲区，**没有发送缓冲区, 有数据就直接发送**，不管对方是否能够正确接收，也不管对端接收缓冲区是否已经满了
- **read**是把数据从内核缓冲区复制到进程缓冲区。**write**是把进程缓冲区复制到内核缓冲区
  - write返回后并不一定导致内核的写动作，比如os可能会把内核缓冲区的数据积累到一定量后，再一次写入。这也就是为什么断电有时会导致数据丢失

## 缓冲区共享

- 比较全面的零拷贝技术，完全去掉了基于数据拷贝的传统IO接口，**内核为每个进程**都维护着一个**缓冲区池**，这个缓冲区池能**被同时映射到进程地址空间和内核地址空间**，内核和所有用户进程共享这个缓冲区池，这样就避免了拷贝。尚处于**实验阶段**

## 写时复制(CopyOnWrite)

- 读时共享，写时复制。**读操作不需要拷贝**，降低了系统开销

- 内核缓冲区可能被多个进程所共享，如果某个进程想要这个共享区进行 write 操作，由于 **write 不提供任何的锁操作**，那么就会对共享区中的数据造成破坏，写时复制就是 Linux 引入来**保护数据**的

- 写时复制，就是当多个进程共享同一块数据时，如果其中一个进程需要对这份数据进行修改，那么就需要抛出一个异常，将数据拷贝到自己的进程地址空间中，这样做不影响其他进程对原始数据的操作，每个进程**要修改的时候才会进行拷贝**

  #### 应用场景

  1. `虚拟内存管理`一般把这种被共享访问的页面标记为只读。当一个task试图向内存中写入数据时，内存管理单元（MMU）抛出一个异常，内核处理该异常时为该task分配一份物理内存并复制数据到此内存，重新向MMU发出执行该task的写操作
  2. linux文件管理系统
  3. linux进程fork
     - 传统的fork()系统调用直接把父进程的资源复制给新创建的子进程。这种实现过于简单并且效率低下，因为它拷贝的数据或许可以共享
     - 写时复制并不复制整个进程的地址空间，而是让**父子进程共享同一个地址空间**。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候
  4. 数据库snapshot策略
  5. STL字符串修改
     - [C++11]标准中为了**提高并行性**取消了这一策略。 GCC从版本5开始，std::string不再采用COW策略

## sendfile

- 磁盘=>页缓存=>内核socket缓冲区=>网卡

- sendfile系统调用在内核版本2.1中被引入，目的是简化通过网络在两个通道之间进行的数据传输过程。sendfile系统调用的引入，不仅减少了数据复制，还减少了上下文切换的次数

- 数据传送只发生在内核空间，所以减少了一次上下文切换；但是还是存在一次copy，能不能把这一次copy也省略掉，Linux2.4内核中做了改进，将Kernel buffer中对应的数据描述信息（内存地址，偏移量）记录到相应的socket缓冲区当中，这样连内核空间中的一次cpu copy也省掉了
- kafka中存在大量的网络数据持久化到磁盘和磁盘文件通过网络发送的过程，**kafka使用了sendfile零拷贝方式**

