- 内存通常指向计算机中的**DRAM**，**CPU只能操作内存**中的数据，无法直接操作硬盘上的数据

`重定位` 将逻辑地址转换为物理地址。物理地址 = 起始物理地址 + 逻辑地址

`中断传送方式`当外设需要与CPU进行信息交换时，由外设向CPU发出请求信号，使CPU暂停正在执行的程序，转而去执行数据IO操作，待数据传送结束后，CPU再继续执行被暂停的程序。在没有发出请求时，CPU和外设并行工作。 中断需要进行断点和现场的保护和恢复，浪费了很多CPU的时间，适合**少量数据的传送**

`DMA(直接内存访问)`**外部设备(磁盘文件，网卡)**不通过CPU而**直接与系统内存交换数据**的接口技术，为了解决批量数据的IO问题。这样数据的传送速度就取决于存储器和外设的工作速度，不需要依赖CPU 的大量中断负载

- 内存只有在要**被DMA访问**的时候才需要**物理连续**

- 传输动作本身是由**DMA控制器**来实行和完成

- DMA是完全由硬件进行组信息传送的控制方式，具有中断方式的优点，即在数据准备阶段，**CPU与外设并行工作**

- I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU发送总线请求(统称为DMA请求)，用以传输数据。DMA占用总线后的数据输入和输出操作都是通过循环来实现。需要特别之处的是，这一循环也是由DMA控制器(而不是通过CPU执行程序)实现的，即数据**传送阶段是完全由DMA(硬件)来控制的**

- 很多**硬件设备**需要一块大的**连续物理内存**用作DMA传送。这块内存需要**一直驻留在内存**，不能被交换到文件中去

  

- 缓存(Cache)：使用**哈希算法**将缓慢的访问结果保存下来，目的是**提高访问命中率**，用于**访问加速**，**随机访问**

  - 为了弥补高速设备和低速设备的鸿沟而引入的中间层

- 缓冲(Buffer)：使用**队列结构**将突发快速的访问平稳下来，目的是**预读和延迟写入**，用于**流量削峰**，**顺序访问**

  - 主要目的进行流量整形，把突发的大数量小规模的 I/O 整理成平稳的小数量大规模的 I/O，以**减少IO次数**。比如从网上下电影，你不能下一点点数据就写一下硬盘，而是积攒一定量的数据以后一整块一起写
  - 生产者消费者模式——消息队列

## 虚拟内存
- 基本思想是程序，数据，堆栈的总的大小可以超过物理存储器的大小，操作系统把当前使用的部分保留在内存中，而把其他未被使用的部分保存在磁盘上
- 通过地址映射将离散的物理地址组织为面向程序的连续逻辑地址
- 内存满时在磁盘上开辟临时空间存储内存交换出的数据
|地址映射 -> 逻辑地址 -> 物理地址(主存内地址, 磁盘外地址)
- `虚拟地址空间`由CPU的位数决定的地址范围
- 大多数时候系统所具备的物理地址空间只是虚拟地址空间的一个子集。举一个例子，对于一台内存为256M的32bit x86主机来说，它的虚拟地址空间范围是0~0xFFFFFFFF（4G），而物理地址空间范围是0x00000000~0x0FFFFFFF（256M）
- CPU在启动的时候是运行在实模式的，内核在**初始化页表之前**并不使用虚拟地址，而是直接**使用物理地址**的
- CPU启动**保护模式**后，**程序运行在虚拟地址空间中**
- 在32位的平台上，线性地址的大小为固定的4GB。并且，由于采用了保护机制，Linux内核将这4GB分为两部分，虚地址较高的1GB（0xC0000000到0xFFFFFFFF）为共享的内核空间；而较低的3GB（0x00000000到0xBFFFFFFF）为每个进程的用户空间

- `连续内存分配`固定分区和可变分区

## 非连续内存分配
- `请求分页存储管理`大多数使用虚拟存储器的系统都使用分页（paging）机制。虚拟地址空间(逻辑地址空间)划分页（page），相应的物理地址空间被进行划分为页帧(frame)。页和页帧的大小必须相同
  - 逻辑地址 = 高位逻辑页号*2**偏移位数+低位页内偏移(2**偏移位数=每页容量大小)*
  - 物理地址 = 物理页帧号2**偏移位数 + 页内偏移
  - `页表`每个进程都有一张, 内容为每个页对应的'物理页帧号'
  - 多个进程可共享同一页帧
  - `快表`如果页表在内存中, 那么每次访问内存物理块时, CPU需要先查询页表, 再根据得到的物理地址访问内存, 实际访问了两次内存. 为了提高访问速度, 可以把页表暂存到Cache
  - 地址变换机构 -> 页表寄存器. 利用页表把程序逻辑地址转换为内存物理地址
  - 只有作业的最后一页可能产生零头(碎片)
- `请求分段存储管理`根据程序逻辑结构将内存分段
- `段页式存储管理`先按照程序逻辑结构分段, 每个段再按照单位页大小分页. 计算开销大, 方便调度, 数据安全和共享
- `零头(碎片)`内零头指分配给进程的未被利用的存储空间，外零头指系统中无法利用的小存储块
  - `内零头`固定分区和请求页式存储; `外零头`可变分区和请求段式存储
  - 解决方法是移动所有已占用区域, 使所有碎片拼接成连续区域
- `页面分配策略`进程生命周期内根据进程情况固定分配页帧数; 可变分配进程页帧数
- `页面置换策略`页面置换算法作用于整个系统的为全局置换; 只作用于本进程的为局部置换

## 页表

- `内核页表`全局只有一份，所有进程共享，由内核自己维护并更新

- `进程页表`每个进程都有一份，时刻在更换。每个进程页表中**内核态地址相关的页表项**都是内核页表的一个拷贝

  - 进程页表 = 内核页表 + 用户地址项
  - 在进程调度而进行上下文切换时，会进行页表的切换：即将新进程的pgd(页目录)加载到CR3寄存器中
  - 在vmalloc区发生page fault时，将内核页表更新到进程页表中

- `TLB(Translation Lookaside Buffer)转换检测缓冲区,快表`用于**改进虚拟地址到物理地址转换速度**的内存管理单元,

  - TLB是一个虚拟寻址的**页表高速缓存**，其中每一行都保存着一个由单个PTE(Page Table Entry,页表项)组成的块。如果**没有TLB**，则每次**取数据**都需要**两次访问内存**，即查页表获取物理地址和取数据
  - TLB内核可以**快速找到虚拟地址指向物理地址**，而**不需要请求慢速RAM内存**获取虚拟地址到物理地址的映射关系
- Linux使用内存时还是倾向于分配**连续内存**，因为分配连续内存时，**不需要更改页表**，因此能**降低TLB的刷新率**（频繁刷新会在很大程度上降低访问速度）
  
#### 多级页表

- 进程虚拟内存地址中的**堆与栈之间**的绝大部分都是不会被用到的**空闲区**，这一部分地址**不需要页表映射**
  
  - 二级页表通过只为**进程实际使用**的那些虚拟内存区请求页表来减少页表占用的空间，进程未使用的页暂时可以不用为其建立页表。如果使用一级页表的话，必须为所有虚拟内存分配页表，不能细分
  - 二级页表的引进是**避免把全部页表都保存到内存**中去（就像一级页表那样），特别是那些**程序没有用到的页表**
  - 二级页表是在进程的确**需要更多内存**的时候，才会分配更多的页表给当前进程
  - 对于32位虚拟地址来说，**一级页表**的确是需要**4MB**的内存来存储，事实上，很少有需要4G内存的程序，很多地址其实进程是用不上的
    - 对于12MB的进程，实际上只需要4个页表：顶级页表，0M-4M的页表(正文段·)，4-8M的页表（数据段，堆段），顶端4M（栈段）的**二级页表**，每个页表大约4kb,所以只需要**16KB**的内存，相比4Mb大大节约了内存

## 缺页中断
- 一个页是一个固定容量的内存区块，是物理内存和外部存储(如硬盘等) 传输的单位。当程序访问一个映射到地址空间但实际上并未加载到物理内存的页时，硬件向软件发出的一次中断（或异常）就是一个缺页中断或叫页错误（page fault）。通过DMA调入需要的页
- |缺页率 -> 可变分配局部置换策略可获得较高的内存空间利用率又能保证每个进程较低的缺页率
- |抖动(thrashing) -> 在分页存储管理系统中，内存中只存放了那些经常使用的页面，而其它页面则存放在外存中，当进程运行需要的内容不在内存时，便启动磁盘读操作将所需内容调入内存，若内存中没有空闲物理块，还需要将内存中的某页面置换出去。也就是说，系统需要不断地在内外存之间交换信息。若在系统运行过程中，刚被淘汰出内存的页面，过后不久又要访问它，需要再次将其调入。而该页面调入内存后不久又再次被淘汰出内存，然后又要访问它。如此'反复访问磁盘'，使得系统把大部分时间用在了页面的调入/换出上，而几乎不能完成任何有效的工作，这种现象称为抖动
- |产生原因 -> 同时运行的进程数过多，进程频繁访问的页面数高于可用的物理块数，造成进程运行时'频繁缺页'。CPU利用率太低时，调度程序就会增加多道程序度，将新进程引入系统中，反而进一步导致处理机利用率的下降
|解决方法
- 1.工作集 -> 一段时间内, 进程实际要访问的页面集合. 引入虚拟内存后, 程序只需少量内存就可运行, 但是为了使程序较少产生缺页中断, 需保证进程的工作集页都分配到物理块(系统为每个工作集分配不小于其本身的物理块). 应限制进程数, 使所有工作集的总尺寸不超过内存
- |工作集窗口 -> 一个时间概念，不是说动态集合分配的页框数。而是过去k次（不含当前）访问的页面记号。比如工作集窗口大小是3，那么一个访问串为：0，2，3，2，1，4 则当访问页面4时，往前看3个，1，2，3在被窗口覆盖，因此驻留集中页面是3，2，1
- -> 工作集精确度与窗口尺寸 ∆ 的选择有关。如果 ∆ 太小，那么它不能表示进程的局部特征；如果 ∆ 为无穷大，那么工作集合是进程执行需要的所有页面的集合
- -> 每个进程都有一个工作集. 如果所有工作集之和增加到超过了可用物理块的总数，操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动
- -> 工作集页面置换法的基本思想：找出一个不在工作集中的页面，把它淘汰
- -> 根据局部性原理，进程会在一段时间内相对稳定在某些页面构成的工作集上
- |驻留集 -> 每个进程当前驻留在物理内存中的页面子集
- -> 缺页率与系统为进程分配物理块的多少（驻留集的大小）有关。缺页率随着分配物理块的增加而减少

  #### 利用工作集进行驻留集调整的策略

  - 操作系统监视每个进程的工作集变化情况
  - -> 只有当一个进程的工作集在内存中时才执行该进程
  - -> 定期淘汰驻留集中不在工作集中的页面
  - -> 总是让驻留集包含工作集(不能包含时则增大驻留集)
  - 2.采用局部置换策略 -> 仅允许进程在自身范围内进行置换。即使发生抖动，也可以把影响限制在较小范围内
  - 3.挂起优先级低的进程, 将释放的内存分配给其他进程

## 零值指针和NULL指针的区别

- 零值指针，是值是0的指针，可以是任何一种指针类型，可以是通用变体类型void*也可以是char*，int*等等。
- 空指针NULL只是一种编程概念，就如一个容器可能有空和非空两种基本状态，而在非空时可能里面存储了一个数值是0，因此空指针是人为认为的指针不提供任何地址讯息
