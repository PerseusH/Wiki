## 页缓存(Page Cache)

- **所有常规的文件I/O都是通过页面缓存进行的**。用户进程<=>系统调用(Read,Write)<=>内核PageCache<=>磁盘
- 其中存储的数据在I/O完成后并不回收，而是一直保存在内存中，除非内存紧张，才开始回收占用的内存
- **pagecache是物理地址**，用户空间/内核空间是虚拟地址
- `脏页`因为硬盘的读写速度远赶不上内存的速度，Linux系统就**把读写比较频繁的磁盘数据事先放到内存中**，以**提高进程读写速度**，这就叫**页高速缓存**，linux是以页作为高速缓存的单位，当**进程修改了高速缓存里的数据**时，该页就被内核线程flusher标记为**脏页**，一个内核进程周期性将**脏页的数据写到磁盘**中去（**回写**），以保持高速缓存中的数据和磁盘中的数据一致。最后清理“脏”页标识
- 脏页数据结构为链表
- 页缓存回收策略为LRU
- 如果没有进程之间的共享机制，那么对于系统中所启动的所有进程在打开文件的时候都要将需要的数据从磁盘加载进物理内存空间，这样不仅造成了加载速度变慢（每次都从磁盘中读取数据），而且造成了物理内存的浪费
- **在虚拟内存机制出现以前，操作系统使用块缓存机制，但是在虚拟内存出现以后操作系统管理IO的粒度更大，因此采用了页缓存机制。**此后，和后备存储的数据交互普遍以页为单位
- 页缓存就是将一个文件在内存中的所有物理页所组成的一种树形结构，我们称之为基数树，用于管理属于同一个文件在内存中的缓存内容。页缓存是**在内核态内存**以页为单位进行管理，面向文件的缓存机制，**不能被用户进程直接寻址**
- 即使一个文件中仅仅读取几个字节的数据，那么包含这些字节的**整个页**的数据都会从硬盘**读入页缓存**中
- 所有普通的文件IO（无论一开始是命中页缓存还是没有命中页缓存）最终都是**直接来源于页缓存**。当将数据从磁盘复制到页缓存之后，还要将页缓存的数据通过CPU复制到read调用提供的缓冲区中，这就是**普通文件IO**需要的**两次数据复制**过程(因为**不能直接在用户地址空间和磁盘之间进行数据传输**)。其中第一次是通过**DMA**方式将数据**从磁盘复制到页缓存**中，本次过程只需要CPU在一开始的时候让出总线、结束之后处理DMA中断即可，中间不需要CPU的直接干预，CPU可以去做别的事情；第二次是内核将数据**从页缓存复制到用户缓冲区**地址空间对应的物理内存中，这个过程中需要CPU的全程干预，浪费CPU的时间和额外的物理内存空间
- page cache通过一系列的数据结构，比如inode, address_space, struct page，将一个文件映射到内存页
- **内核会为每个文件单独维护一个page cache**，位于内存和文件之间缓冲区，用户进程对于文件的大多数IO操作会直接作用到page cache上，内核会选择在适当的时候将page cache中的内容写到磁盘上（当然我们可以手工fsync控制回写），这样可以大大减少磁盘的访问次数，从而提高性能。Page cache是linux内核文件访问过程中很重要的数据结构，page cache中会保存用户进程访问过得该文件的内容，这些内容以页为单位保存在内存中，当用户需要访问文件中的某个偏移量上的数据时，内核会以偏移量为索引，找到相应的内存页，如果该页没有读入内存，则需要访问磁盘读取数据。为了提高页得查询速度同时节省page cache数据结构占用的内存，linux内核使用树来保存page cache中的页
- 一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写访问，这里的主要原因就是在于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache
  - **对于数据文件的读取**，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取（ps：顺序读入紧随其后的少数几个页面）。这样，只要下次访问的文件已经被加载至PageCache时，读取操作的速度基本等于访问内存
  - **对于数据文件的写入**，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的脏页回写至物理磁盘上
- 使用page cache 的I/O操作称为 buffer I/O，默认情况下，内核都是使用 buffer I/O；但有的应用不希望使用内存缓存，而是由应用提供内存，这种由应用提供内存的I/O 称为 **direct I/O**，它的特点是**不使用系统提供的page cache**
  - Linux系统的buffer I/O(标准IO)由于填充page cache，必须等于I/O完成才能返回，所以buffer I/O本身在内核中就会阻塞。所以Linux的**异步I/O必须是 direct I/O(直接IO)**，才能不阻塞进程立即返回
  - 直接IO属于**自缓存**技术，即使用进程自身的用户虚拟内存而非内核虚拟内存，数据传输不经过操作系统内核缓冲区
  - 直接IO的数据均直接在用户地址空间的缓冲区和磁盘之间直接进行传输，完全**不需要页缓存**的支持
  - 应用场景：**数据库系统**，其高速缓存和IO优化机制均自成一体，无需内核消耗CPU时间和内存去完成相同的任务
