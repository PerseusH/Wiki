## 堆(Heap)

- 进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆的特点
- 堆是由程序员自己分配的，由所有共享库和进程中动态加载的模块共享，分配速度较慢，容易产生碎片，不过用起来方便
- **malloc/free，new/delete**之类的操作都是在**堆空间**
  - malloc()返回的指针是指向堆里面的一块内存
  - free()释放的是指针指向的内存，指针并没有被释放，指针仍然指向原来的存储空间。指针是一个变量，只有程序结束时才被销毁
  - new表达式返回指向该新创建对象的指针，我们可以通过指针来访问此对象
  - delete释放指针指向的地址空间。一旦删除了指针所指的对象，立即将指针置为0，这样就非常清楚的指明指针不再指向任何对象（零值指针：int *ip=0;）
- 操作系统中有一个记录**空闲内存地址**的**链表**。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。在使用malloc()分配内存空间后，一定要记得释放内存空间，否则就会出现内存泄漏
- 堆是向高地址扩展的数据结构，是**不连续的内存区域**，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有效虚拟内存空间，由此空间，堆获得的空间比较灵活，也比较大
- 一般是在堆的头部用一个字节存放堆的大小，堆的具体内容由程序员安排
- 堆容易产生**内存泄漏**

## 栈(Stack)

- 用于动态地存储函数之间的关系，以保证被调用函数在返回时恢复到父函数中继续执行
- 存放局部变量（形参也是局部变量），以及每次调用函数时保存的信息。每当调用一个函数时，返回到的地址和关于调用者环境的某些信息的地址，比如一些机器寄存器，就会被保存在栈中。然后，新调用的函数在栈上分配空间，用于自动保存临时变量
- 栈由**编译器自动分配释放**，速度快，程序员无法控制
- 栈是向低地址扩展的数据结构，是一块**连续的内存区域**，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小
- 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令的地址，然后是函数的各个参数，在大多数的C编译器中，参数是从右往左入栈的，当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令
- 当一个子函数被调用时，子函数的数据及代码都会被装入栈中，因为栈空间通常会有大小限制，如果子函数太多时，就会有**栈溢出**的风险。所以当程序员考虑使用递归函数解决问题时，应当考虑到栈溢出的风险。建议学会使用将递归函数写成非递归函数的方法

## **malloc与new的区别**

- new 返回**指定类型的指针**，并且可以**自动计算**所需空间大小。而 malloc 则必须要由程序员计算所需空间大小，并且在返回后强行转换为实际类型的指针
- malloc 只管分配内存，**不能进行初始化**，得到的新内存值是随机的。除了分配及最后释放的方法不一样以外，通过malloc或new得到指针，在其它操作上保持一致
- 既然**new/delete的功能完全覆盖了malloc/free**，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而**C程序只能用malloc/free管理动态内存**
- malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于**申请动态内存和释放内存**
- 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。我们不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的
- 如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致**程序出错**。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new/delete必须**配对使用**，malloc/free也一样