- Linux中**一切皆文件**

## 用户态和内核态

- 为了限制不同的进程之间的访问能力，防止它们获取别的进程的内存数据，或者获取外围设备的数据并发送到网络，将CPU划分出两个等级---用户态和内核态。设置内核态和用户态的主要目的是为了**安全**，是程序的两种运行级别，想要对操作系统底层进行操作，就必须切换到内核态，不必担心应用程序对硬件进行非法操作

- `指令的执行状态`： 用户态

- 内核态就是最高特权级的二进制全局共享库

- 进程都运行在用户态，在用户态使用CPU和内存完成一些事情，但是当进程需要对硬件进行操作（如读取磁盘文件、发送网络数据）时，就需要切换到内核态，在内核态，进程将拥有更多的权限来控制整个计算机，在内核态完成任务之后，进程又切换回用户态

- 用户态切换到内核态的3种方式

  1. `系统调用` 

     - 所有程序的运行都是在用户态的，但有时候需要做一些内核态的事情（从硬盘读取数据、或者从键盘输入数据），这些事情的实现必须依赖操作系统，此时，程序就需要向操作系统请求系统调用机制，在CPU的实现称为**陷阱指令(Trap)**
  
- 系统调用(软中断)在内核态完成的，需要进行2次CPU上下文切换(用户空间–>内核空间–>用户空间)，不涉及用户态资源，也**不会切换进程**
     - 系统调用的中断与硬件无关，属于**自愿性中断事件**，应用程序**主动**向操作发出的服务请求

  2. `异常`当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常

  3. `外围设备的中断` 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行对应的中断处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作
  
- 其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的
  
- #### 实现系统调用的基础

  - **中断异常机制**
  - 设计一条特殊指令，使得应用程序主动陷入内核（在linux中为 int 0x80，用于执行一个软中断）
  - 设置系统调用号以及参数，因为所有的系统调用都从同一个入口进入内核，所以需要额外的编号对这些调用加以区分。参数一般放在栈上，但是用户态的栈是没法传递到内核态的，所以参数传递这块，以linux为例，是通过将参数放在通用寄存器上传递的。
  - 初始化**系统调用表**，用于存放各个**调用服务的入口地址**

- 用户态切换到内核态的过程

  （1）用户态

  ​		 ① 触发0x80中断

  ​         ②保存当前的运行位置，状态，数据

  ​         ③将系统调用号保存到eax寄存器中

  ​         触发0x80中断 由系统调用函数触发的中断 。实际上在内核中，  触发0x80中断之后才会有上面的两步 。

  （2）每一个中断号在内核中都有一个中断处理程序，中断处理程序是被内核调用来响应中断的

  ​      通过该中断处理程序陷入内核

  （3）内核态

  ​		 ①有系统调用表，用寄存器中的系统调用号对应一个系统调用函数

  ​         ②通过函数得到执行该系统调用函数会得到一个返回值fd

  ​         ③将fd的值用eax寄存器带出  

  - 只有0x80中断才是**系统调用中断**
  
- #### 系统调用过程详解

  1. 中断异常机制：硬件保护现场，查询中断向量表，cpu控制权转移至系统调用总入口程序。
  2. 系统调用总入口程序：保存现场，把参数保存到内核的堆栈中，查询系统调用表，将cpu控制权转交给相应内核函数
  3. 执行系统调用例程
  4. 恢复现场，返回用户进程

-> 计算机指令执行过程的控制信号

-> '假定下列指令已装入指令寄存器. 则执行时不可能导致CPU从用户态变为内核态(系统态)的是?'
	1.DIV R0, R1;(R0)/(R1)→R0
	2.INT n; 产生软中断
	3.NOT R0; 寄存器R0的内容取非
	4.MOV R0, addr; 把地址处的内存数据放入寄存器R0中

-> '会导致进程从执行态变为就绪态的事件是?'
	1.执行P(wait)操作
	2.申请内存失败
	3.启动I/O设备
	4.被高优先级进程抢占

-> 文件系统的顺序分配方式, 文件系统的链接分配方式, 以及文件的存储

-> 总线定时 >>> 异步通信,全互锁协议是否最慢,非互锁协议的可靠性是否最差 >>> 同步通信,时钟信号是否可由多设备提供 >>> 半同步通信,握手信号的采样是否由同步时钟控制

-> 磁盘转速 >>> 平均寻道时间 >>> 扇区数 >>> 访问一个扇区的平均存取时间

-> '若系统S1 采用死锁避免方法, S2采用死锁检测方法,那么'
	1.S1会限制用户申请资源的顺序
	2.S1需要进行所需资源总量信息, 而S2不需要
	3.S1不会给可能导致死锁的进程分配资源, S2会

-> '系统为某进程分配了4个页框, 该进程已访问的页号序列为2,0,2,9,3,4,2,8,2,3,8,4,5, 若进程要访问的下一页的页号为7, 依据LRU算法, 应淘汰页的页号是?'
	1.2
	2.3
	3.4
	4.8

-> '在系统内存中设置磁盘缓冲区的主要目的是?'
	1.减少磁盘IO次数
	2.减少平均寻道时间
	3.提高磁盘数据可靠性
	4.实现设备无关性

-> '在文件的索引节点中存放直接索引指针10个, 一级二级索引指针各1个, 磁盘块大小为1KB. 每个索引指针占4个字节. 若某个文件的索引节点已在内存中, 到把该文件的偏移量(按字节编址)为1234和307400处所在的磁盘块读入内存. 需访问的磁盘块个数分别是?'
	1.1, 2
	2.1, 3
	3.2, 3
	4.2, 4

-> '在请求分页系统中, 页面分配策略与页面置换策略不能组合使用的是?'
	1.可变分配, 全局置换
	2.可变分配, 局部置换
	3.固定分配, 全局置换
	4.固定分配, 局部置换
