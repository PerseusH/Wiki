## 中断(Interruption)

- 由其他硬件设备依照CPU时钟周期信号随机产生

- CPU在执行程序的过程中，出现了某些突发事件急待处理(设备给CPU发一个中断请求信号)，CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后CPU又返回程序被中断的位置并继续执行

- `中断要解决的问题`：早期的CPU处理外设的事件(比如接收键盘输入)，往往采用**轮询**的方式。即CPU轮番对外设顺序访问，比如它先看看键盘有没被按下，有的话就处理，没的话继续往下看鼠标有没有移动，再看看打印机……这种方式使CPU的执行效率很低，且CPU与外设不能同时工作（因为要等待CPU来“巡查”）

- 根据中断来源分为：内部(软)中断和外部(硬)中断。内部中断来源于CPU内部（软中断指令、溢出、语法错误等），外部中断来自CPU外部，由**设备**提出请求

  - 外部中断包括I0设备发出的**IO中断**、外部信号中断(例如用户键人ESC键)。各种定时器引起的时钟中断以及调试程序中设置的断点等引起的调试中断等
  - 内部中断包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断以及**从用户态到核心态的切换**等。软中断是在通信进程之间通过**模拟硬中断**而实现的一种通信方式

- 设备的中断会**打断内核中正常调度和运行**，系统对更高吞吐率的追求势必要求中断服务程序尽可能的短小（时间短），但是在大多数实际使用中，要完成的工作都是复杂的，它可能需要进行大量的耗时工作

- 硬件通过触发信号或系统调用产生软中断，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理

- cpu的控制单元会检查在执行前一条指令的过程中是否有中断或异常发生。当捕捉到这样一个信号后，CPU根据该中断码找到中断向量表内的对应向量，根据该向量转到中断处理程序，开始立即执行do_irq（）函数，执行相应的中断处理程序，中断处理程序是在**内核态**下运行，中断响应是即时的

- 由于中断服务程序的执行并不存在于进程上下文，因此，要求**中断处理程序的时间尽可能的短，不能阻塞**。 为了在中断执行事件尽可能短和中断处理需完成大量耗时工作之间找到一个平衡点，Linux将中断处理分为两个部分：顶半部（top half）和底半部（bottom half）

  - 对于一些要求处理过程比较复杂的任务就不合适在中断任务中一次处理。比如，网卡接收数据的过程中,首先网卡发送中断信号告诉CPU来取数据，然后系统从网卡中读取数据存入系统缓冲区中，再下来解析数据然后送入应用层。这些如果都让中断处理程序来处理显然过程太长，造成新来的中断丢失。因此Linux开发人员将这种任务分割为两个部分，一个叫上底，即中断处理程序，短平快地处理与硬 件相关的操作（如从网卡读数据到系统缓存）；而把对时间要求相对宽松的任务（如解析数据的工作）放在另一个部分执行，这个部分就是我们这里要讲的下半底
  - 下半底是一种推后执行任务，它将某些不那么紧迫的任务推迟到系统更方便的时刻运行。因为并不是非常紧急，通常还是比较耗时的，因此**由系统自行安排运行时机，不在中断服务上下文中执行**

- 顶半部完成尽可能少的比较紧急的功能，它往往只是简单地读取寄存器中的中断状态并清除中断标志后进行“登记中断”的工作。“登记”意味着将底半部的处理程序挂载到**该设备的底半部队列**中去，在cpu运行状态不是那么繁忙的情况下再去执行程序。底半部作为工作重心，完成中断事件的绝大多数任务。**底半部**在运行时调用open_softirq()**注册软中断处理程序**

  a. 底半部可以被新的中断事件打断，这是和顶半部最大的不同，顶半部通常被设计成不可被打断

  b. 底半部相对来说不是非常紧急的，而且相对比较耗时，不在硬件中断服务程序中执行。

  c. 如果中断要处理的工作本身很少，所有的工作可在顶半部全部完成

- **中断注册**最重要的就是request_irq函数，其输入参数如下，分别是:中断号，**中断回调函数**，中断条件（上升沿还是下降沿），中断的名字、依托的设备文件

- 中断模式的作用和优点在于：

  1. 可以使CPU和外设同时工作，使系统可以及时地响应外部事件。
  2. 可允许多个外设同时工作，大大提高了CPU的利用率，也提高了数据输入、输出的速度。
  3. 可以使CPU及时处理各种软硬件故障（比如计算机在运行过程中，出现了难以预料的情况或一些故障，如电源掉电、存储出错、运算溢出等等。计算机可以利用中断系统自行处理，而不必停机或报告工作人员。

- 当满足了中断的条件后，CPU就会响应中断，转入中断程序处理。具体的工作过程如下：

  1. 关闭中断信号接收器
  2. 保存现场(context)，也就是把cpu当前的状态保存起来
  3. 给出中断入口，转入相应的中断程序处理
  4. 处理完成，返回并恢复现场(context)
  5. 开启中断信号接收器

- 中断排队和中断判优

  1. 中断申请是随机的，有时会出现多个中断源同时提出中断申请。
  2. CPU每次只能响应一个中断源的请求。
  3. CPU不可能对所有中断请求一视同仁，它会根据各中断源工作性质的轻重缓急，预先安排一个优先级顺序。当多个中断源同时申请中断时，即按此优先级顺序进行排队，等候CPU处理

- 了解了CPU中断处理的过程，就不难理解下面一种常见的情景：

  > 正在拷贝文件时，往某个文本框输入信息，这个文本框会出现短暂的假死，键盘输入的数据不能及时显示在文本框中，需要等一会儿才能逐渐显示出来。

  - 这是因为该中断操作(往文本框输入信息)在中断队列的优先级比较低，或者CPU认为正在处理的操作(拷贝文件)进行挂起的代价太大，所以只有等到CPU到了一个挂起代价较低的点，才会挂起当前操作，处理本次中断信息

- 多核CPU的中断处理和单核有很大不同。**多核的各处理器核心之间需要通过中断方式进行通信**，所以CPU芯片内部既有各处理器核心的本地中断控制器，又有负责仲裁各核之间中断分配的全局中断控制器

  - 对于外部设备发出的中断请求，由全局中断控制器接收请求并决定交给CPU的哪一个核心处理

- **中断处理程序**（包括上半部和下半部）没有自己的堆栈，执行的时候都是使用的当前**用户进程的内核栈**，若当前没有用户进程，便使用idle进程的内核栈。软中断处理程序的执行在某一个cpu（多核中的一个）上应是线性的，只有上一个软中断处理完成之后才能执行下一个软中断处理程序

- **系统调用**的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断