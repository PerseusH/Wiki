###  *RST分节*

- 在TCP协议中RST表示复位,用来异常地关闭连接,在TCP的设计中它是不可或缺的。发送RST包关闭连接时,不必等缓冲区的包都发出去,直接就丢弃缓存区的包发送RST包。而接收端收到RST包后,也不必发送ACK包来确认。系统收到RST包就会产生一个错误然后'立即关闭连接

---

### *TTL*(Time to Live，包括数据包TTL和域名TTL)

1. IPv4包头的一个8 bit字段, 最大值是255，推荐值是64. 作用是限制IP数据包在计算机网络中的存在的时间, 避免IP数据包在网络中的无限循环和收发，节省了网络资源，并能使IP包的发送者能收到告警消息

   在很多情况下数据包在一定时间内不能被传递到目的地。解决方法就是在一段时间后丢弃这个包，然后给发送者一个报文，由发送者决定是否要重发

   数据包中的TTL是IP数据包在计算机网络中可以转发的最大(路由器)跳数，指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL字段由IP数据包的发送者设置，在IP数据包从源到目的的整个转发路径上，每经过一个路由器，路由器都会修改这个TTL字段值，把该TTL值减1，然后再将IP包转发出去。当记数到0时，路由器决定丢弃该包，并发送一个ICMP Type 11 and Code 0 message(Time to live exceeded) 报文给最初的发送者，由发送者决定是否要重发

2. 域名TTL表示DNS记录在DNS服务器上缓存时间，就是一条域名解析记录在DNS服务器中的存留时间。当各地的DNS服务器接受到解析请求时，就会向域名指定的NS服务器(权威域名服务器）发出解析请求从而获得解析记录；在获得这个记录之后，记录会在DNS服务器(各地的缓存服务器，也叫递归域名服务器）中保存一段时间，这段时间内如果再接到这个域名的解析请求，DNS服务器将不再向NS服务器发出请求，而是直接返回刚才获得的记录；而这个记录在DNS服务器上保留的时间，就是TTL值

   

   #### *linux系统TTL值修改*

   - TTL值在文件/proc/sys/net/ipv4/ip_default_ttl中定义,可通过执行以下命令修改
     echo 128 &gt; /proc/sys/net/ipv4/ip_default_ttl #这是短暂性的
   - 若要永久生效可修改/etc/sysctl.conf配置文件，添加net.ipv4.ip_default_ttl=128，接着执行sysctl -p即可

---

### *MSL(MaximumSegmentLifetime,  最大分节生命期)*

- 一个数据包在网络上的最长生存时间,超过这个时间数据包将消失.RFC1122建议是2分钟,berkeley的TCP实现传统上是30秒
- MSL是一个系统级参数，可手动调整

---

### *CLOSE_WAIT*

- Server端收到Client发来的FIN后，发送一个ACK报文给Client端(序号为M+1)，Server状态变为CLOSE_WAIT
- 如果Server端一直没有向client端发送FIN消息(调用close() API)，那么CLOSE_WAIT会一直存在下去

---

### *TIME_WAIT*

   - 主动发送出FIN信号后又接收到对方发来的FIN信号, 就会进入TIME_WAIT状态. 通信双方建立TCP连接后,主动关闭连接的一方会进入TIME_WAIT状态
   - TIME_WAIT状态维持时间是'两个MSL'时间长度,即1-4分钟.Winsdows系统是4分钟
- 主动关闭连接的一端会发送最后一个ack,然后进入TIME_WAIT状态,停留2个MSL时间后进入CLOSED状态
- local peer主动调用close后，此时的TCP连接进入TIME_WAIT状态，处于该状态下的TCP连接不能立即以同样的四元组建立新连接，即发起active close的那方占用的local port在'TIME_WAIT期间不能再被重新分配(socket不能被回收使用)'
  `$ netstat -an|-ae #常用来检查网络连接状态`

#### *作用*

1. 可靠地实现TCP全双工连接的终止(保证可重发丢失的最终ACK)，不会导致系统资源耗尽的问题
    TCP协议在关闭连接的四次挥手过程中,最终的ACK是由主动关闭连接的一端(后面统称A端)发出的,如果这个'ACK丢失',对方(后面统称B端)将重发出最终的FIN,因此A端必须维护状态信息(TIME_WAIT)允许它'重发最终的ACK'.如果A端不维持TIME_WAIT状态,而是处于CLOSED 状态,那么A端将发送'RST分节',B端收到后将此分节解释成一个'错误'(在java中会抛出connection reset的SocketException)
    因此要实现TCP全双工连接的正常终止,必须处理终止过程中四个分节任何一个分节的丢失情况,主动关闭连接的A端必须维持TIME_WAIT状态
2. 允许旧的重复分节在网络中消失(保证旧的重复分节完全被释放后才会重新连接)
    TCP分节可能由于路由器异常而"迷途",在迷途期间,TCP发送端可能因确认超时而重发这个分节,迷途的分节在路由器修复后也会被送到最终目的地,这个迟到的迷途分节到达时可能会引起问题.在关闭前一个连接之后,马上又重新建立起一个相同的IP和端口之间的新连接,前一个连接的迷途重复分组在前一个连接终止后到达,而被新连接收到了.TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。为了避免这个情况,TCP协议'不允许TIME_WAIT状态的连接启动一个新连接',因为TIME_WAIT状态持续2MSL,就可以保证当成功建立一个新TCP连接的时候,来自旧连接重复分组已经在网络中消失

