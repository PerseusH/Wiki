|MD5 -> (消息摘要算法，属Hash算法)以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值
    1、数据填充 -> 对消息进行数据填充，使消息的长度对512取模得448，设消息长度为X，即满足X%512=448。根据此公式得出需要填充的数据长度。填充方法：在消息后面填充，第一位为1，其余为0
    2、添加消息长度 -> 在第一步结果之后再填充上原消息长度,可用来进行的存储长度为64位。如果消息长度大于2**64，则只取其低64位的值(消息长度对2**64取模).此步骤完成后,最终消息长度就是512的整数倍
    3、数据处理
        需要用到的数据：
            4个常数： A = 0x67452301, B = 0x0EFCDAB89, C = 0x98BADCFE, D = 0x10325476;
            4个函数：F(X,Y,Z)=(X & Y) | ((~X) & Z); G(X,Y,Z)=(X & Z) | (Y & (~Z));  H(X,Y,Z)=X ^ Y ^ Z; I(X,Y,Z)=Y ^ (X | (~Z));
        -> 把消息分以512位为一分组进行处理，每一个分组进行4轮变换，以上面所说4个常数为起始变量进行计算，重新输出4个变量，以这4个变量再进行下一分组的运算，如果已经是最后一个分组，则这4个变量为最后的结果，即MD5值

    -> 任意长度的数据，算出的MD5值长度都是固定的和唯一的. 一般用作数字签名和加密
    -> 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的
    -> 1996年后被证实可以被破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-1

|中间人攻击 -> 把目标计算机放在两台计算机中间, 劫持信息(抓包)
    |解决 -> https(由SSL(安全套接层)进行网站身份验证和加密传输数据) CA(证书颁发机构)
        -> 对称加密与非对称加密区别？
            |对称加密 -> 采用单钥密码系统的加密方法,同一个密钥可以同时用作信息的加密和解密.'{加密与解密速度快}',但由于需要将'{密钥在网络传输}',所以安全性不高

            |非对称加密 -> 为数据的加密与解密提供了一个'{非常安全}'的方法,它使用了一对密钥,公钥(public key)和私钥(private key).私钥只能由一方安全保管,不能外泄,而公钥则可以发给任何请求它的人.非对称加密使用这对密钥中的一个进行加密,而'{解密则需要另一个密钥}'.比如,你向银行请求公钥,银行将公钥发给你,你使用公钥对消息加密,那么只有私钥的持有人--银行才能对你的消息解密。银行不需要将私钥通过网络发送出去,因此安全性大大提高,但'{加密与解密速度慢}'

        |https原理 -> 客户端与服务器端握手用非对称加密交换'{对称密钥}', 然后对称加密传输
        -> SSL先采用'{非对称密钥}'技术交换认证信息，并交换服务器和浏览器之间用于加密数据的会话密钥，然后利用该密钥对通信过程中的信息进行加密和解密
        -> SSL位于http和tcp之间, SSL证书可防止黑客冒充服务器
        -> HTTPS协议 = SSL + HTTP协议. 端口 -> http:80, https:443
        -> https需要到CA申请证书,一般免费证书很少,需要交费
            -> SSL证书携带CA信息和公钥被发送到客户端,客户端校验CA通过后取用公钥加密传输
        -> http是超文本传输协议,信息是明文传输,https则是具有安全性的ssl加密传输协议

        |HTTPS缺点
            1.SSL证书费用很高，以及其在服务器上的部署、更新维护非常繁琐
            2.HTTPS降低用户访问速度（多次握手）
            3.网站改用HTTPS后,由HTTP跳转到HTTPS时增加了用户访问耗时,多数网站采用302跳转
            4.HTTPS涉及到的安全算法会消耗CPU资源,需要增加大量机器,https访问需要加解密

       |Best Practice
           1.将'{对称密钥}'使用'{非对称加密的公钥}'进行加密,然后发送出去,接收方使用'{私钥解密}'得到对称加密的密钥,然后双方可以使用'{对称加密}'进行安全的沟通(用非对称加密封装对称加密)
           2.通过https访问Nginx一般会比http访问慢30%（https方式访问主要是耗Nginx服务器的cpu）.SSL是需要耗费大量CPU资源的一种安全技术。目前，大多数负载均衡设备均采用'{SSL加速芯片}'进行SSL信息的处理

   -> 如何生成共享秘钥?
       |共享秘钥 -> 服务器端和用户共同拥有一个或一组密码
       -> IPSec协议中引入了一个密钥管理协议,称'{Internet密钥交换协议IKE}',该协议可以动态认证IPSec对等体,协商安全服务,并自动生成共享密钥

   -> 什么是分组加密？加密模式有哪些？ecb和cbc模式有什么区别？为什么需要iv向量？
       |分组密码 -> 将明文消息编码表示后的数字（简称明文数字）序列，'{划分成长度为n的组}'（可看成长度为n的矢量），每组分别在密钥的控制下变换成等长的输出数字（简称密文数字）序列.明文组经过加密得到密文组，密文组经过解密，还原成明文组

       |加密模式 -> ECB,CBC,CFB,OFB
           |ecb -> 将明文切分成若干小段，再进行加密
           |cbc -> 将明文切分成若干小段，然后每一小段与'{初始块(iv向量)}'或者上一段的密文段进行'{异或}'运算后，再进行加密

       |iv向量 -> cbc'{初始加密}'时进行异或运算

|xss -> js脚本注入
    |反射型 -> js死循环|js生成隐藏iframe,提交到服务器,服务器把恶意脚本渲染出来,再用表单将用户输入发送到iframe.src所指服务器
        浏览器 -> 服务器 -> 浏览器

    |DOM型 -> 不经过服务器端,直接在客户端完成
    |存储型 -> 将脚本存入数据库

    -> htmlescape后能否避免xss?
        -> 替换尖括号、引号等特殊符号,只解决了'{html}'的问题,'{不能完全防御XSS}'.因为<script>是javascript输出点,xss的'{目标是破坏js构造}'而不是html构造.html构造中的关键字符是尖括号、双引号、“&”符号等.而js构造就复杂了,比如换行、注释（//和/*）、引号（包括单引号）等都会改变构造.需要'{在htmlescape外加一层js_encode}'

    |解决
        1.输入验证(客户端,服务器端)
        2.view过滤
        3.html转义+js_encode(import cgi;cgi.escape('<script>') -> &lt;script&gt;)
        4.渲染时用Mako一类的模板库可以避免大部分情况下的XSS,图片URL需要显式防范
        5.jinjia2里safe标签,无法绕过,防范xss的最常见手段

|csrf(跨站伪造请求) -> 在请求中(url&cookie)插入恶意参数, 破坏服务器
    domain/deleteAriticle.php?id=3&username=xxx
    |解决 -> 提高攻击的门槛
        1.RESTful API
        -> 对发帖等创建资源的操作,应该只接受POST请求,而GET请求应该只浏览而不改变服务器端资源,这样攻击者就不能通过发布链接来伪造请求(屏蔽PUT,DELETE)
        2.请求令牌(服务器端验证过一定记得销毁)
        -> 服务器生成随机令牌(random string-token in Session)
            1.服务端在收到路由请求时，生成一个随机数，在渲染请求页面时把随机数埋入页面（一般埋入 form 表单内，<input type="hidden" name="token" value="xxx">）
            2.服务端设置setCookie，把该随机数作为cookie或者session种入用户浏览器
            3.当用户发送 GET 或者 POST 请求时带上token参数（对于 Form 表单直接提交即可，因为会自动把当前表单内所有的 input 提交给后台，包括token）
            4.后台在接受到请求后解析请求的cookie获取token的值，然后和用户请求提交的token做个比较，如果相等表示请求是合法的
        3.验证码(服务器端验证过一定记得销毁): 需要手动输入, 用户体验差
        4.django通过中间件django.middleware.csrf.CsrfViewMiddleware实现防止csrf
            |全局 settings->MIDDLEWARE=['django.middleware.csrf.CsrfViewMiddleware']

            |局部 -> from django.views.decorators.csrf import csrf_exempt,csrf_protect
            -> @csrf_protect, 为当前函数强制设置防csrf功能, 即便没有设置全局中间件
            -> @csrf_exempt, 禁用当前函数防csrf功能, 即便设置了全局中间件

|SQL注入 -> 本质是'改变原有查询的逻辑结构'
    "<name>' union select ..." #常用手法
    -> 使用参数查询,不要拼接SQL字符串('%s' % args).用现成的SQL封装库
    -> 使用cur.execute+参数预编译,python会自动过滤args中的特殊字符,防止SQL注入的产生
    cur.execute('select id, name from tb where id=%s and name=%s', (id, name))
    cur.execute("insert into people values (?, ?)", (name, age))
    cur.execute("insert into people values (:name, :age)", {'name': name, 'age': age})

|DDos -> Distributed of Service 分布式拒绝服务 没有很好的解决方案, 就是硬扛
    -> 借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户/服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行.利用目标系统网络服务功能缺陷或者直接消耗其系统资源，使得该目标系统无法提供正常的服务

    |对DoS和DDoS的防范主要从下面几个方面考虑
        1.尽可能对系统加载最新补丁，并采取有效的合规性配置，降低漏洞利用风险
        2.采取合适的安全域划分，配置防火墙、入侵检测和防范系统，减缓攻击
        3.采用分布式组网、负载均衡、提升系统容量等可靠性措施，增强总体服务能力
        4.把网站做成静态页面
            -> 大量事实证明，把网站尽可能做成静态页面，不仅能大大提高抗攻击能力，而且还给黑客入侵带来不少麻烦，至少到目前为止关于HTML的溢出还没出现，新浪、搜狐、网易等门户网站主要都是静态页面，若你非需要动态脚本调用，那就把它弄到另外一台单独主机去，免的遭受攻击时连累主服务器，当然，适当放一些不做数据库调用脚本还是可以的
        5.最好在需要调用数据库的脚本中拒绝使用代理的访问，因为经验表明使用代理访问你网站的80%属于恶意行为
        6.升级主机服务器硬件
        7.充足的网络带宽保证(核心措施)
            -> 网络带宽直接决定了抗受攻击的能力，假若仅有10M带宽，无论采取什么措施都很难对抗当今的SYN Flood攻击，至少要选择100M共享带宽，最好是挂在1000M的主干上
        8.尽量避免NAT的使用
            -> 无论是路由器还是硬件防护墙都要尽量避免采用网络地址转换NAT的使用，采用此技术会较大降低网络通信能力. 因为NAT需要对地址来回转换，转换过程中需要对网络包的校验和进行计算，因此浪费了很多CPU的时间，但有些时候必须使用NAT，那就没有好办法了
        9.DDos防火墙, 买阿里云的防ddos服务, 开启CDN、增加负载均衡
            -> 集群抗攻击 广泛分布的CDN节点加上节点之间的智能冗余机制，可有效预防DDoS攻击，同时保证较好的服务质量

    |解决 -> 查询netstat的连接数,超过一定连接数目的IP用iptables封禁一段时间,脚本加入cron每分钟执行. 只能'{防止小规模DDos}'

    |死亡之ping -> 简单DDos, 利用缓存溢出攻击
        -> 许多操作系统的TCP/IP协议栈规定ICMP包大小为64KB，且在对包的标题头进行读取之后，要根据该标题头里包含的信息来为有效荷载生成缓冲区。”死亡之ping”就是故意产生畸形的测试ping包，声称自己的尺寸超过ICMP上限，也就是加载的尺寸超过64KB上限，使未采取保护措施的网络系统出现内存分配错误，导致TCP/IP协议栈崩溃，最终接收方宕机

        $ ping -l 65500 -t 192.168.1.21
        -> 这样它就会不停的向192.168.1.21计算机发送大小为65500byte的数据包，如果你只有一台计算机也许没有什么效果，但如果有很多计算机那么就可以使对方完全瘫痪，当同时使用10台以上计算机ping一台Win2000Pro系统的计算机时，不到5分钟对方的网络就会完全瘫痪，网络严重堵塞，HTTP和FTP服务完全停止，可见威力非同小可
        -> 因为以太网长度有限，IP包片段被'{分片}'。当一个IP包的长度超过以太网帧的最大尺寸（以太网头部和尾部除外）时，包就会被分片，作为多个帧来发送。接收端提取各个分片，并'{重组}'为一个完整的IP包。在正常情况下，IP头包含整个IP包的长度。当一个IP包被分片以后，头只包含各个分片的长度。分片并不包含整个IP包的长度信息，因此IP包一旦被分片，重组后的整个IP包的总长度只有在所在分片都接受完毕之后才能确定
        -> 在IP协议规范中规定了一个IP包的最大尺寸，而大多数的包处理程序又假设包的长度超过这个最大尺寸这种情况是不会出现的。因此，包的重组代码所分配的内存区域也最大不超过这个最大尺寸。这样，'{超大的包}'一旦出现，包当中的'{额外数据}'就会被写入其他正常区域。这很容易导致系统进入'{非稳定状态}'，是一种典型的'{缓存溢出}'（Buffer Overflow）攻击。在防火墙一级对这种攻击进行检测是相当难的，因为每个分片包看起来都很正常

        -> 最好的方法是对操作系统打补丁，使内核将不再对超过规定长度的包进行重组

    |伪造IP -> 修改http header的X-Forwarded-For为自定义IP, 就可以伪造IP向服务器发送请求

    |SYN洪水攻击 -> 一种DDos,它利用TCP协议缺陷,通过伪造IP发送大量半连接请求,耗费CPU和内存资源
        -> 少量洪水攻击会导致主机服务器无法访问,但却
        　　可以Ping通,在服务器上用Netstat -na命令会观察到存在大量的SYN_RECEIVED状态,
        　　大量洪水攻击会导致Ping失败,TCP/IP栈失效,并会出现系统凝固现象,即不响应键盘
        　　和鼠标。普通防火墙大多无法抵御此种攻击

        -> 客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN报文，服务器回复ACK确认报文，并等待客户的确认，由于'{源地址是不存在}'的，服务器需要不断的重发直至超时，这些伪造的SYN报文被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪

        |解决方法
            1.缩短SYN Timeout时间
                -> 由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数，这个值=SYN攻击的频度 x SYN Timeout，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃该连接的时间，例如设置为20秒以下（过低的SYN Timeout设置可能会影响客户的正常访问），可以成倍的降低服务器的负荷
            2.减少重试发送SYN-ACK消息的次数 /proc/sys/net/ipv4/tcp_synack_retries
            3.提高TCP半开连接队列大小的上限 /proc/sys/net/ipv4/tcp_max_syn_backlog
            4.设置SYN Cookie
                -> 给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被丢弃
                -> 原理与HTTP Cookies技术类似，B通过特定的算法把半开连接信息编码成“Cookie”，用作B给A的消息编号（SequenceNum），随SYN-ACK消息一同返回给连接发起方A，这样在连接完全建立前B不保存任何信息。如果A是正常用户，则会向B发送最后一次握手消息（ACK），B收到后验证“Cookie”的内容并建立连接；如果A是攻击者，则不会向B反馈ACK消息，B也没任何损失，也就说是单纯的SYN攻击不会造成B的连接资源消耗。当然这种方案也有一定缺点，最明显的就是B不保存连接的半开状态，就丧失了重发SYN-ACK消息的能力，这一方面会降低正常用户的连接成功率，另一方面会导致某些情况下正常通信的双方会对连接是否成功打开产生误解，如A发给B的第三次握手消息(ACK)半路遗失，A认为连接成功了，B认为没收到ACK，连接没成功，这种情况就需要上层应用采取策略特别处理了
            5.SYN flood可以用'{DCN防火墙}'来拦截，在DCN防火墙受到攻击的时候会提示有IP试图连接你的端口等报警，这是受到了SYN FLOOD攻击的征兆，不是什么抓肉鸡，而是被SYN攻击了，正常情况下SYNFLOOD是攻击不进去的，所以尽管放心
                -> 上述两种方法只能对付比较原始的SYN Flood攻击，缩短SYN Timeout时间仅在对方攻击频度不高的情况下生效，SYN Cookie更依赖于对方使用真实的IP地址，如果攻击者以数万/秒的速度发送SYN报文，同时利用随机改写IP报文中的源地址，以上的方法将毫无用武之地。例如SOCK_RAW返回的套接字通过适当的设置可以自己完全控制IP头的内容从而实现IP欺骗
            6.SYN Cache -> 构造一个全局的Hash Table，用来缓存系统当前所有的半开连接信息，连接成功则从Cache中清除相关信息；Hash Table中每个桶（bucket）的容量大小也有限制，当桶“满”时做除旧迎新操作
                -> 当B收到一个SYN消息后，会将半开连接信息加入到Hash Table中，其中key的生成很关键，既要用到SYN消息中包含的信息（如：Source IP，Port等）又要做到很难被攻击者猜到，一般会通过一个秘密的函数生成，这样所有的半开连接无论好坏，都看似随机地被平均分配到了不同的“桶”中，使攻击难度大增，因为为达到DoS效果，攻击者需要使每个桶都达到填满状态，并且还要有足够快的“填桶”速度，使得正常的半开连接在还未完成建立前就被踢出桶，这样的攻击行为估计在达到目的前早就暴露了

    |TCP全连接攻击
        -> 这种攻击是为了绕过常规防火墙的检查而设计的，常规防火墙大多具备过滤TearDrop、Land等DOS攻击的能力，但是会放过正常的TCP连接，殊不知很多网络服务程序（IIS、Apache等Web服务器）能接受的TCP连接数是有限的，一旦有大量的TCP连接，即便是正常的，也会导致网站访问非常缓慢甚至无法访问，TCP全连接攻击就是通过许多僵尸主机不断地与受害服务器建立大量的TCP连接，直到服务器的内存等资源被耗尽而被拖跨，从而造成拒绝服务，这种攻击的特点是'{可绕过一般防火墙}'的防护而达到攻击目的，缺点是需要找很多僵尸主机，并且由于僵尸主机的IP是暴露的，因此容易被追踪

    |刷Script脚本攻击：
        -> 这种攻击主要是针对存在 ASP、JSP、PHP、CGI 等脚本程序，并调用 MSSQLServer、MySQLServer、Oracle 等数据库的网站系统而设计的，特征是和服务器建立正常的 TCP 连接， 并不断的向脚本程序提交查询、 列表等大量耗费数据库资源的调用， 一般来说， 提交一个 GET 或 POST 指令对客户端的耗费和带宽的占用是几乎可以忽略的，而服务器为处理此请求却可能要从上万条记录中去查出某个记录， 这种处理过程对资源的耗费是很大的， 常见的数据库服务器很少能支持数百个查询指令同时执行，而这对于客户端来说却是轻而易举的， 因此攻击者只需通过 Proxy 代理向主机服务器大量递交查询指令， 只需数分钟就会把服务器资源消耗掉而导致拒绝服务，常见的现象就是网站慢如蜗牛、ASP 程序失效、PHP 连接数据库失败、数据库主程序占用 CPU 偏高。这种攻击的特点是可以完全绕过普通的防火墙防护， 轻松找一些 Proxy 代理就可实施攻击， 缺点是对付只有静态页面的网站效果会大打折扣，并且有些 Proxy 会暴露攻击者的 IP 地址

    |iptables
        1.防止syn攻击
        -> 限制syn的请求速度,这个方式需要调节一个合理的速度值,不然会影响正常用户的请求
        iptables -N syn-flood
        iptables -A INPUT -p tcp --syn -j syn-flood
        iptables -A syn-flood -m limit --limit 1/s --limit-burst 4 -j RETURN
        iptables -A syn-flood -j DROP
        2.木马反弹
        iptables –A OUTPUT –m state --state NEW –j DROP
        3.防止ping攻击
        iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/m -j ACCEPT

|Encryption
   1.md5(key)
   2.md5(md5(key) + salt) #salt = substr(uniqid(rand()), -6)
