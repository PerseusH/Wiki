## 可靠传输

- TCP之所以是可靠传输，意味着它保证每次传输的报文段的**大小和顺序**
- 通过下列方式实现
  1. 分块发送：应用数据被分割成TCP认为最适合发送的数据块。由TCP传递给IP的信息单位称为报文段或段（segment）
  2. 定时确认重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒
  3. 数据校验：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）
  4. 正确排序：由于IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层
  5. 重复丢弃：IP数据报会发生重复，TCP的接收端必须丢弃重复的数据
  6. 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出

## TCP状态

​    LISTEN：(Listening for a connection.)侦听来自远方的TCP端口的连接请求
​    SYN-SENT：(Active; sent SYN. Waiting for a matching connection request after having sent a connection request.)再发送连接请求后等待匹配的连接请求
​    SYN-RECEIVED：(Sent and received SYN. Waiting for a confirming connection request acknowledgment after having both received and sent connection requests.)再收到和发送一个连接请求后等待对方对连接请求的确认
​    ESTABLISHED：(Connection established.)代表一个打开的连接
​    FIN-WAIT-1：(Closed; sent FIN.)等待远程TCP连接中断请求，或先前的连接中断请求的确认
​    FIN-WAIT-2：(Closed; FIN is acknowledged; awaiting FIN.)从远程TCP等待连接中断请求
​    CLOSE-WAIT：(Received FIN; waiting to receive CLOSE.)等待从本地用户发来的连接中断请求
​    CLOSING：(Closed; exchanged FIN; waiting for FIN.)等待远程TCP对连接中断的确认
​    LAST-ACK：(Received FIN and CLOSE; waiting for FIN ACK.)等待原来的发向远程TCP的连接中断请求的确认
​    TIME-WAIT：(In 2 MSL (twice the maximum segment length) quiet wait after close. )等待足够的时间以确保远程TCP接收到连接中断请求的确认
​    CLOSED：(Connection is closed.)没有任何连接状态

## 三次握手 & 四次挥手

####   *TCP报文字段*

- 序号(seq) -> 随机数或接收到的ack_seq, 用来保证数据段顺序，也就是**报文段的序号**

  - 数据段是**乱序发送**的，如果没有序号，可能造成报文段的**重传、顺序的颠倒甚至丢包**

- 确认序号(ack_seq) -> 接收到的seq + 1，也就是**允许发送端发送的报文段起始序号**

  - 如果发送端收到的**ack_seq不等于seq+1**，说明传输过程存在**丢包**，发送端依然将从ack_seq继续传输

- 标志位 -> SYN(0: 无询问, 1: 询问), ACK(0: 无应答, 1: 确认), FIN(0: 未关闭, 1: 关闭)

  - 发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功

  - **发送方没有接收到响应的ACK报文**原因可能有两点

    1. 数据在传输过程中由于网络原因直接全体丢包，**接收方没有接收到**
    2. 接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络延迟**丢包**

  - 为了解决**发送端接收不到ACK报文**的问题，TCP引入了**超时重传机制**

    

#### TCP如何保证报文段的顺序

1. 主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机**对这个序列号进行确认**

2. 如果发送主机在特定时间内没有收到接收主机的确认，则**发送主机会重传**此数据包

3. 接收主机利用序列号对接收的数据进行确认，以便**检测对方发送的数据是否有丢失或乱序**等

4. 接收主机一旦**确认收到已经顺序化的数据**，它就将这些数据按正确的顺序**重组成数据流**并传递到高层进行处理

#### *三次握手*

- 建立TCP连接, 分配资源、初始化序列号(通知对方我的初始序列号是多少)
- 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
- client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client没有要求建立连接
- client(SYN) -> server(ACK+SYN) -> client(ACK)

#### *四次挥手*

- 终止TCP连接, 释放连接资源. 四次挥手是因为被动关闭方接收到FIN时需要处理完未发送的报文后才能确定关闭连接
- TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但这时主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快地中断这次TCP连接
- 两端同时关闭连接 -> 一个关闭方发出FIN时接收到另一方发过来的FIN, 则双方同时进入FIN_WAIT; 在确认收到了对方全部的数据包后, 双方返回ACK, 然后同时进入TIME_WAIT
- client(SYN) -> server(ACK), server(FIN) -> client(ACK)

|   Client    |                                                |   Server    |
| :---------: | :--------------------------------------------: | :---------: |
|             |                  **Connect**                   |             |
|             |        --SYN=1,seq=m,ACK=0,ack_seq=0->         |             |
|  SYN_SENT   |                                                |             |
|             |       <-ACK=1,ack_seq=m+1,SYN=1,seq=n--        |             |
|             |                                                |  SYN_RCVD   |
|             |      --ACK=1,ack_seq=n+1,SYN=0,seq=m+1->       |             |
| ESTABLISHED |                                                | ESTABLISHED |
|             |                  **DataSend**                  |             |
|             |   --ACK=1,ack_seq=n+1,SYN=0,seq=m+1,data1->    |             |
|             |    <-ACK=1,ack_seq=m+1+L_d1,SYN=0,seq=n+1--    |             |
|             | --ACK=1,ack_seq=n+2,SYN=0,seq=m+1+L_d1,data2-> |             |
|             | <-ACK=1,ack_seq=m+1+L_d1+L_d2,SYN=0,seq=n+2--  |             |
|             |                   **Close**                    |             |
| ESTABLISHED |                                                | ESTABLISHED |
|             | --FIN=1,seq=m+1+L_d1+L_d2,ACK=1,ack_seq=n+2->  |             |
|  FIN_WAIT   |                                                |             |
|             |        <-ACK=1,ack_seq=m+2+L_d1+L_d2--         |             |
|             |                                                | CLOSE_WAIT  |
|             | <-FIN=1,seq=n+2,ACK=1,ack_seq=m+2+L_d1+L_d2--  |             |
|             |                                                |  LAST_ACK   |
|             |             --ACK=1,ack_seq=n+3->              |             |
|  TIME_WAIT  |                                                |             |
|   CLOSED    |                                                |   CLOSED    |

## 滑动窗口协议（Sliding Window Protocol）

- 属于TCP协议的一种应用，用于网络数据传输时的**流量控制**，以**避免拥塞**的发生。该协议**允许发送方在停止并等待确认前发送多个数据分组**。由于发送方**不必每发一个分组就停下来等待确认**，因此该协议可以**加速数据的传输，提高网络吞吐量**

- 可以理解成**接收缓冲区的大小**，发送方根据**接收端发来的数据报中的win字段大小**来计算自己最多能发送多长的数据
- **发送方每次发送的报文段范围为：seq to seq+win-1（win为可变窗口大小）**
- 如果发送方收到接受方的窗口大小为0的TCP数据报（win=0），那么发送方将停止发送数据，**等到接受方发送窗口大小不为0的数据报的到来**
  - 接收缓冲区把数据缓存入内核，等待recv()读取，recv()所做的工作，就是把内核缓冲区中的数据拷贝到应用层用户的buffer里面，并返回。若应用进程一直没有调用recv()进行读取的话，此数据会一直缓存在相应socket的接收缓冲区内。对于TCP，如果应用进程一直没有读取，**接收缓冲区满**了之后，发生的动作是：**收端通知发端，接收窗口关闭（win=0）**。保证TCP套接口**接收缓冲区不会溢出**，从而**保证了TCP是可靠传输**，因为对方不允许发出超过所通告窗口大小的数据
- TCP就是用这个窗口，慢慢的从数据的左边移动到右边，把处于窗口范围内的数据发送出去（但不用发送所有，只是处于窗口内的数据可以发送）。这就是窗口的意义。窗口的大小是可以通过socket来制定的，4096并不是最理想的窗口大小，而16384则可以使吞吐量大大的增加
- 如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方TCP将丢弃它
- win字段只属于接收方报文，随ACK报文发送
- 与固定大小的滑窗协议相比，TCP采用**可变大小的滑窗协议**是为了取得更好的性能
- 窗口合拢：当窗口从左边向右边靠近的时候，这种现象发生在数据被发送和确认的时候。   
- 窗口张开：当窗口的右边沿向右边移动的时候，这种现象发生在接受端处理了数据以后。   
- 窗口收缩：当窗口的右边沿向左边移动的时候，这种现象不常发生