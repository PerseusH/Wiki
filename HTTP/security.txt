\Network Attack
    |中间人攻击 -> 把目标计算机放在两台计算机中间, 劫持信息
       |解决 -> https(由SSL(安全套接层)进行网站身份验证和加密传输数据)
           |https原理 -> 客户端与服务器端握手交换'{对称密钥}', 接下来传输加密信息
           -> SSL通信首先采用'{非对称密钥}'技术交换认证信息，并交换服务器和浏览器之间用于加密数据的会话密钥，然后利用该密钥对通信过程中的信息进行加密和解密
           -> https协议需要到ca申请证书,一般免费证书很少,需要交费
           -> http是超文本传输协议,信息是明文传输,https则是具有安全性的ssl加密传输协议
           -> http和https使用的端口不一样,前者是80,后者是443
           -> http的连接很简单,是无状态的;HTTPS协议是由SSL+HTTP协议构建的可进行加密传输,身份认证的网络协议,比http协议安全
           -> 通过https访问Nginx一般会比http访问慢30%（https方式访问主要是耗Nginx服务器的cpu）.SSL是需要耗费大量CPU资源的一种安全技术。目前，大多数负载均衡设备均采用'{SSL加速芯片}'进行SSL信息的处理

       -> 对称加密与非对称加密区别？
           |对称加密 -> 采用单钥密码系统的加密方法,同一个密钥可以同时用作信息的加密和解密.'{加密与解密速度快}',但由于需要将'{密钥在网络传输}',所以安全性不高
           |非对称加密 -> 为数据的加密与解密提供了一个'{非常安全}'的方法,它使用了一对密钥,公钥(public key)和私钥(private key).私钥只能由一方安全保管,不能外泄,而公钥则可以发给任何请求它的人.非对称加密使用这对密钥中的一个进行加密,而'{解密则需要另一个密钥}'.比如,你向银行请求公钥,银行将公钥发给你,你使用公钥对消息加密,那么只有私钥的持有人--银行才能对你的消息解密。银行不需要将私钥通过网络发送出去,因此安全性大大提高,但'{加密与解密速度慢}'
           |Best Practice -> 将'{对称密钥}'使用'{非对称加密的公钥}'进行加密,然后发送出去,接收方使用'{私钥解密}'得到对称加密的密钥,然后双方可以使用'{对称加密}'进行安全的沟通(用非对称加密封装对称加密)

       -> 如何生成共享秘钥?
           |共享秘钥 -> 服务器端和用户共同拥有一个或一组密码
           -> IPSec协议中引入了一个密钥管理协议,称'{Internet密钥交换协议IKE}',该协议可以动态认证IPSec对等体,协商安全服务,并自动生成共享密钥

       -> 什么是分组加密？加密模式有哪些？ecb和cbc模式有什么区别？为什么需要iv向量？
           |分组密码 -> 将明文消息编码表示后的数字（简称明文数字）序列，'{划分成长度为n的组}'（可看成长度为n的矢量），每组分别在密钥的控制下变换成等长的输出数字（简称密文数字）序列.明文组经过加密得到密文组，密文组经过解密，还原成明文组

           |加密模式 -> ECB,CBC,CFB,OFB
               |ecb -> 将明文切分成若干小段，再进行加密
               |cbc -> 将明文切分成若干小段，然后每一小段与'{初始块(iv向量)}'或者上一段的密文段进行'{异或}'运算后，再进行加密

           |iv向量 -> cbc'{初始加密}'时进行异或运算

    |xss -> js脚本注入
        |反射型 -> js死循环|js生成隐藏iframe,提交到服务器,服务器把恶意脚本渲染出来,再用表单将用户输入发送到iframe.src所指服务器
        |DOM型 -> 不经过服务器端,直接在客户端完成
        |存储型 -> 将脚本存入数据库

        -> htmlescape后能否避免xss?
            -> 替换尖括号、引号等特殊符号,只解决了'{html}'的问题,'{不能完全防御XSS}'.因为<script>是javascript输出点,xss的'{目标是破坏js构造}'而不是html构造.html构造中的关键字符是尖括号、双引号、“&”符号等.而js构造就复杂了,比如换行、注释（//和/*）、引号（包括单引号）等都会改变构造.需要'{在htmlescape外加一层js_encode}'

        |解决
            1.输入验证(客户端,服务器端)
            2.view过滤
            3.html转义+js_encode(import cgi;cgi.escape('<script>') -> &lt;script&gt;)
            4.渲染时用Mako一类的模板库可以避免大部分情况下的XSS,图片URL需要显式防范
            5.jinjia2里safe标签,无法绕过,防范xss的最常见手段

    |csrf(跨站伪造请求) -> 在请求中(url&cookie)插入恶意参数, 破坏服务器
       |解决 -> 提高攻击的门槛
           1.RESTful API
           -> 对发帖等创建资源的操作,应该只接受POST请求,而GET请求应该只浏览而不改变服务器端资源,这样攻击者就不能通过发布链接来伪造请求(屏蔽PUT,DELETE)
           2.请求令牌(服务器端验证过一定记得销毁)
           -> 服务器生成随机令牌(random string-token in Session),在发出请求的页面,把该令牌以隐藏域与其他信息一并发出.在接收请求的页面,把接收到的令牌与Session中的令牌比较,只有一致的时候才处理请求,否则返回403拒绝请求或者要求用户重新登陆验证身份
           3.验证码(服务器端验证过一定记得销毁): 需要手动输入, 用户体验差
           4.django通过'{中间件}'django.middleware.csrf.CsrfViewMiddleware实现防止csrf
           |全局 -> settings->MIDDLEWARE=['django.middleware.csrf.CsrfViewMiddleware']
           |局部 -> from django.views.decorators.csrf import csrf_exempt,csrf_protect
           -> @csrf_protect,为当前函数'{强制设置}'防csrf功能,即便settings中没有设置全局中间件
           -> @csrf_exempt,'{禁用}'当前函数防跨站请求伪造功能,即便settings中设置了全局中间件

    |DDos解决 -> 查询netstat的连接数,同IP超过一定连接的用iptables封禁一段时间,脚本加入cron每分钟执行

    |SQL注入解决 -> 使用参数查询,不要拼接SQL字符串('%s' % args).用现成的SQL封装库
        -> 使用cur.execute+参数预编译,python会自动过滤args中的特殊字符,防止SQL注入的产生
        cur.execute('select id, name from tb where id=%s and name=%s', (id, name))
        cur.execute("insert into people values (?, ?)", (name, age))
        cur.execute("insert into people values (:name, :age)", {'name': name, 'age': age})

    |SYN洪水攻击
    -> SYN洪水攻击属于DOS攻击的一种，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源
    -> 客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN报文，服务器回复ACK确认报文，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN报文被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪

    |死亡值ping
    -> 许多操作系统的TCP/IP协议栈规定ICMP包大小为64KB，且在对包的标题头进行读取之后，要根据该标题头里包含的信息来为有效载荷生成缓冲区。”死亡值ping”就是故意产生畸形的测试ping包，声称自己的尺寸超过ICMP上限，也就是加载的尺寸超过64KB上限，使未采取保护措施的网络系统出现内存分配错误，导致TCP/IP协议栈崩溃，最终接收方宕机

\Encryption
   1.md5(key)
   2.md5(md5(key) + salt) #salt = substr(uniqid(rand()), -6)
