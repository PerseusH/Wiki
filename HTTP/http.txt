|PV(page view) -> 浏览量,用户每打开一个页面就被记录1次.用户多次打开同一页面,浏览量值累计
|UV(user view) -> 访客量,一天之内的独立访客数(以Cookie为依据).一天内同一访客多次访问只算1次
|日活 -> 每日活跃用户数

Socket = Ip address + TCP/UDP + port

\Network Layer
    应用层 -> HTTP/SMTP/FTP/DNS/RPC -> 会话/应用/表现
    传输层 -> TCP/UDP -> TCP/UDP数据报
    网络层 -> IP -> IP数据报
    数据链路层 + 物理层

\HTTP
    -> Web三大组成部分之一 #uri(资源),http(管道),html(容器)
    -> 无状态，基于TCP协议的短连接，1.1版本默认为长连接，应用层的超文本传输协议
    -> 通过cookie, session解决http无状态的问题

    |HTTP2.0 -> 下一代HTTP协议。是由互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis (httpbis)工作小组进行开发。是自1999年http1.1发布后的首个更新。HTTP 2.0在2013年8月进行首次合作共事性测试。在开放互联网上HTTP2.0将只用于https网址，而 http网址将继续使用HTTP1.x，目的是在互联网上增加使用加密技术(默认)，以提供强有力的保护去遏制主动攻击

    |请求报文包括三部分
        1.请求行 -> 包含请求方法,URI,HTTP版本协议
        2.请求首部字段
        3.请求内容实体

    |响应报文包含三部分
        1.状态行 -> 包含HTTP版本,状态码,状态码原因短语
        2.响应首部字段
        3.响应内容实体

    |优化 -> 负载均衡, Cache, 加速应用

    |一次http请求全过程
        1.域名解析(DNS) ->
        2.tcp3次握手
        3.发起http请求
        4.服务器程序按照请求生成响应结果返回给客户端(浏览器)
        5.浏览器解析html代码，并请求其中的资源
        6.浏览器渲染并显示页面

\HTTP1.1
    -> HTTP 1.0规定浏览器与服务器只保持短暂的连接,浏览器的每次请求都需要与服务器建立一个TCP连接,服务器完成请求处理后立即断开TCP连接,服务器不跟踪每个客户也不记录过去的请求
    -> HTTP 1.1支持'{长连接(默认)}',在一个TCP连接上可以传送多个HTTP请求和响应,减少了建立和关闭连接的消耗和延迟
    -> HTTP 1.1还允许客户端不用等待上一次请求结果返回,就可以发出下一次请求('{管线化, 流水线请求}'),但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果,以保证客户端能够区分出每次请求的响应内容,这样也显著地减少了整个下载过程所需要的时间
    -> HTTP 1.1中增加'{Host请求头}'字段,WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点,这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点
    -> HTTP 1.1还提供了与'{身份认证、状态管理和Cache缓存}'等机制相关的请求头和响应头
    -> HTTP 1.1默认支持文件'{断点续传}'
        |请求头 -> Range: bytes=(FirstBytePos)-[LastBytePos]
        Range: bytes=4000- 下载从第4000字节开始到文件结束部分
        Range: bytes=0~N 下载第0-N字节范围的内容
        Range: bytes=M-N 下载第M－N字节范围的内容
        Range: bytes=-N 下载最后N字节内容

        |响应头 -> Content-Range: bytes [FirstBytePos]-[LastBytePos]/[EntityLength]

        -> 请求下载整个文件:
        GET /test.rar HTTP/1.1
        Connection: close
        Host: 116.1.219.219
        Range: bytes=0-801 #一般请求下载整个文件是bytes=0- 或不用这个头

        -> 正常回应:
        HTTP/1.1 200 OK
        Content-Length: 801
        Content-Type: application/octet-stream
        Content-Range: bytes 0-800/801 #801:文件总大小

        -> 断点续传，如果返回文件的一部分，则使用206状态码；如果返回整个文件，则使用200响应码
        HTTP/1.1 200 OK（不使用断点续传）| HTTP/1.1 206 Partial Content（使用断点续传）

\Method
    |GET和POST区别
        |根本区别 -> GET用于获取数据, POST用于修改数据
        1.GET的语义是幂等的, 只读的; POST的语义是非幂等的, 有副作用的(GET可以放心后退, 刷新)
            -> 因为'{幂等性}', GET请求结果大部分都直接被CDN缓存了, 可以大大减少web服务器压力; POST请求因为是非幂等的有副作用的, 所以需要由web服务器来处理. 把所有GET换成POST, 意味着主干网络上所有的CDN都被废掉了
        2.GET结果能被'{缓存}', POST不能被缓存
        3.GET结果能被'{收藏为书签}', 利于传播; POST不行
        '''''''''''''''''''''优势分割线''''''''''''''''''''''
        4.GET只能传ASCII'{字符集}'; POST可以传Unicode字符集和二进制数据
        5.GET参数会保存到'{浏览器历史和服务器日志}'中; POST没有这个问题, 更安全
        6.一般浏览器对GET'{数据长度}'有限制; POST数据长度无限制
        7.GET有'{CSRF}'风险

    |POST和PUT区别
        POST -> 创建或更新
        PUT -> 创建

\Cache
    刷新页面出现from disk/memory cache -> ctrl+shift+r(Chrome) | ctrl+F5
    -> 服务器端返回Etag或Last-Modified后,浏览器再次访问会发送if-none-match或if-modified-since,若前后相等则返回304,否则返回最新资源:

    |Last-Modified -> 获取某文件的最后修改日期作为缓存更新标识
        > response.headers["Last-Modified"] = last_modified_time
        > request.headers["If-Modified-Since"]

    |Etag -> 用唯一标识保证文件的完整性,每次文件有更新该值就会变化(比Last-modified更敏感)
        -> Etag 主要为了解决 Last-Modified 无法解决的一些问题
            1.一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET
            2.某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)
            3.某些服务器不能精确的得到文件的最后修改时间

        > response.headers["Etag"] = hash(data)
        > request.headers["If-None-Match"]

    |Expires: Tue, 20 Mar 2007 04:00:25 GMT
    |Max-age -> 使用秒来计量缓存最大生存期

    Cache-control:public -> 缓存的版本可以被代理服务器或者其他中间服务器识别
    Cache-control:private -> 这个文件对不同的用户是不同的。只有用户自己的浏览器能够进行缓存，公共的代理服务器不允许缓存
    Cache-control:no-cache -> 文件的内容不应当被缓存。这在'{搜索或者翻页}'结果中非常有用，因为同样的URL，对应的内容会发生变化

\HTTP Code
    |300 Multiple Choices
        -> 客户请求的文档可以在多个位置找到,这些位置已经在返回的文档内列出.如果服务器要提出优先选择,则应该在Location应答头指明.
    |301 Moved Permanently -> 永久重定向
        |重定向
            -> 客户请求的文档在其他地方,新的URL在Location头中给出,浏览器应该自动地访问新的URL.
            -> 301重定向是搜索引擎认可的唯一的跳转方式，301跳转可以将原页面的权重转移给新的页面（做301重定向不会导致网站权重或流量的流失, 需要一定的周期）
            1.如果你想为网站更换域名，请千万要记得利用301重定向将原本的域名重定向至现在的域名
            2.如果你想删除网站中的不合理或无意义的目录，请千万要记得利用301重定向到网站首页
            3.如果你想把其他的一些闲置域名共同指向某一个在用的网站，利用301重定向就能够轻松实现
            4.如果你想实现网站URL的规范化，比如xxyfkj.cn和www.xxyfkj.cn的规范化，利用301重定向就可以完成
    |302 Found -> 类似于301,新的URL应该被视为临时性的替代,而不是永久性的.
    |303 See Other
        -> 类似于301/302,不同之处在于,如果原来的请求是POST,Location头指定的重定向目标文档应该通过GET提取
    |304 Not Modified
        -> 客户端有缓冲的文档并发出了一个条件性的请求(一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档).服务器告诉客户,原来缓冲的文档还可以继续使用.
    |305 Use Proxy -> 客户请求的文档应该通过Location头所指明的代理服务器提取
    |307 Temporary Redirect
        -> 和302(Found)相同.许多浏览器会错误地响应302应答进行重定向,即使原来的请求是 POST,即使它实际上只能在POST请求的应答是303时才能重定向.由于这个原因,HTTP 1.1新增了307,以便更加清除地区分几个状态代码 ->  当出现303应答时,浏览器可以跟随重定向的GET和POST请求；如果是307应答,则浏览器只能跟随对GET请求的重定向.
    |403 -> 服务器拒绝执行客户端请求
    |404 -> 请求的资源（网页等）不存在
    |500 -> 内部服务器错误
    |503 -> Service Unavailable	服务器由于系统维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头
    |504 -> Gateway Timeout	由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）。某些代理服务器在DNS查询超时时会返回400或者500错误

\RESTful
    1.一切网络对象都被抽象成一种资源(URI唯一资源标识符, 都是名词)
    2.客户端和服务器之间, 传递这种资源的某种表现层
    3.客户端通过四个HTTP动词, 对服务器端资源进行操作, 实现"表现层状态转化"
    4.http操作无状态, 减少上下文依赖, 降低耦合
    5.目的是简化http操作, 使网站软件化, 防止跨站攻击
