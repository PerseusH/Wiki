# encoding=utf-8


import logging
import random
import re


# 获得一个int型数的二进制中1的个数
def Binary_1_Count():
    n = random.randint(0, 1000)
    logging.info('int: %s', n)
    logging.info('binary: %s', bin(n))

    ### algorithm begin ###
    count = 0

    # 1. complexity: O(log2 N))
    # while n is not 0:
    #     count += n & 1 #验证末位值
    #     n >>= 1

    # 2. complexity: O(1 ~ log2 N)
    while n is not 0:
        n = n & (n - 1) #去除末尾0
        count += 1
    ### algorithm end ###

    logging.info('1 count: %s', count)


# 输入一个数组，实现一个函数，让所有奇数都在偶数前面
def Odd_before_even():
    arr = list(randints(100))
    logging.info('Int Array: %s', arr)

    ### algorithm begin ###
    i, j, length = 0, 0, len(arr)

    while 1:
        if j == length:
            break

        if arr[i] % 2 == 0:
            arr.append(arr.pop(i))
        else:
            i += 1

        j += 1
    ### algorithm end ###

    logging.info('After rebuilding: %s', arr)


# 判断一个字符串是否是另一个字符串的子串
def Is_SubString_Of_Another():
    sample = 'dwaefgfjhgdsfadfgrtygjt435r&Y&*^97987'
    substr = '&Y&'
    logging.info('Sample: %s', sample)
    logging.info('SubString: %s', substr)

    ### algorithm begin ###
    lsub, lsmpl, is_substr = len(substr), len(sample), False
    i = j = 0

    while i < lsmpl:

        while j < lsub:
            if sample[i] == substr[j]:
                i, j = i + 1, j + 1
            else:
                break

            if j == lsub:
                is_substr = True
        i += 1
    ### algorithm end ###

    if is_substr:
        logging.info('"%s" is substring of "%s".', substr, sample)
    else:
        logging.info('"%s" is NOT substring of "%s".', substr, sample)


# Fibonacci
def Fibonacci():
    a, b = 0, 1

    ### algorithm begin ###

    ### algorithm end ###


# 通过两个栈实现一个队列
#
# 把一个int型数组中的数字拼成一个串，这个串代表的数字最小
#
# 倒序打印一个单链表
#
# ListDistinct
#
# ListReverse
#
# 给定一个单链表的头指针和一个指定节点的指针，在O(1)时间删除该节点
#
# 找到链表倒数第K个节点
#
# MergeTwoList
#
# 输入两个链表，找到它们第一个公共节点
#
# 合并排序，将两个已经排序的数组合并成一个数组，其中一个数组能容下两个数组的所有元素
#
# QuickSort
#
# BinarySearch
#
# BinaryTree
#
# MirrorOfABinaryTree（每个节点的左右子节点交换位置）
#
# BTree/B+Tree
#
# RBTree


def randints(*args, length=10, repeatable=False):
    '''
    Generate a set of ints.
    '''
    if args is ():
        raise ValueError('No arguments!')

    len_args = len(args)
    start, stop, length = {
     1: (0, args[0], length if args[0] - 0 > length else args[0] // 2),
     2: (args[0], args[-1], length if args[-1] - args[0] > length else (args[-1] - args[0]) // 2) if args[0] < args[-1] else (0, args[0], args[-1]),
     3: (args[0], len_args > 1 and args[1], args[-1])
    }.get(len_args)

    if stop - start < length:
        length = (stop - start) // 2

    ints = set()
    while 1:
        if len(ints) == length:
            break

        rint = random.randint(start, stop)
        if repeatable or rint not in ints:
            ints.add(rint)

    return ints


def exec(func):
    '''
    Execute a function.
    '''
    logging.info('-- %s --', re.sub(r'_', ' ', func.__name__))
    func()
    logging.info('-- END --')


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
    exec(Odd_before_even)
    # logging.info(randints(300, 20))
