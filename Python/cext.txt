|作用
    1.添加Python没有的'{功能}'. 如创建新数据类型或将Python嵌入到其它应用中
    2.提升程序'{性能}'. 解释型语言一般比编译型语言慢，想要提高性能，全部改写成编译型语言并不划算，好的做法是，先做性能测试，找出性能瓶颈部分，然后把瓶颈部分在扩展中实现
    3.源代码'{保密}'. 脚本语言一个共同的缺陷是，都是执行的源代码，保密性便没有了。把一部分的代码从Python转到编译语言就可以保持源代码私密性。不容易被反向工程，对涉及到特殊算法，加密方法，以及软件安全时，这样做就显得很重要(还可以只发布预编译的*.pyc文件)

|python允许C扩展模块自己对GIL进行临时释放
    -> 在多线程环境下，python虚拟机按照以下方式运行
       1. 设置GIL（全局解释器锁）
       2. 切换到一个线程中去
       3. 运行
            a. 指定数量的字节码的指令，或者
            b. 线程主动让出控制(可以条用time.sleep(0) )
       4. 把线程设置为阻塞模式
       5. 解锁GIL
       6. 再次重复以上步骤
    -> 调用C/C++扩展函数的时候，GIL会被锁定，直到这个函数结束。由于这期间没有python的字节码被运行，所以线程不会切换
    |C扩展代码 -> 在较长时间的C函数调用前，临时释放全局锁，完成后重新获取全局锁，以避免阻塞其他 python的线程继续运行
        Py_BEGIN_ALLOW_THREADS //C宏
        ... Do some blocking IO operation
        Py_END_ALLOW_THREADS //C宏
    |这段代码会被扩展为如下：
        PyThreadState *_save;
        _save = PyEval_SaveThread();
        ... Do some blocking I/O operation
        PyEval_RestoreThread(_save);
    |一种简单的使用多核计算的方法 -> 把任务拆分成多个小份，每个小份都放在一个线程中运行。线程里调用扩展模块中的计算函数，计算函数在实际计算时释放GIL

|内存泄漏
    |引用计数器(Python)
        |C语言宏
            1.Py_INCREF(obj) -> obj引用计数加1. 一般在函数体的返回语句(第一次被使用的位置)之前调用
            2.Py_DECREF(obj) -> obj引用计数减1. 一般在对象最后被使用的位置之后调用

    1.C本身泄露
    2.python中有引用计数的问题，在写C扩展模块时必须非常小心的处理，否则很有容易导致内存泄露
        -> Python的扩展模块在操作Python对象之后，需要改变对象的引用计数器.C扩展程序一旦忘记修改或者不能正确的修改'{引用计数器}'，这些对象就成了僵尸对象(内存泄漏)
        -> 可以借助 Cython、SWIG生成接口代码来尽量避免
    3.悬挂指针 -> 指向非法的内存地址的指针，也叫野指针。意为无法正常使用的指针
        |场景
            1.定义指针变量之后没有对它进行初始化
            2.对象已经消亡后，仍使用指针访问该对象
            3.指针释放后之后未置空
                -> 指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。对指针进行free和delete，只是把指针所指的内存空间给释放掉，但并没有把指针本身置空，此时指针指向的就是“垃圾”内存。释放后的指针应将指针置为NULL，防止产生悬挂指针

Tool           Part of CPython   Compiled   Autogenerated   Numpy Support
-------------- ----------------- ---------- --------------- ---------------
Python-C-Api   True              True       False           True
Ctypes         True              False      False           True
SWIG           False             True       True            True
Cython         False             True       True            True

|Python-C-Api
    1.cext.c -> 按照Python C-API规范编写C代码
    2.编译、打包与生成 -> cext.c同级目录下编写setup.py, 用distutils编译、打包、生成py模块
        # file: setup.py
        from distutils.core import setup, Extension

        module1 = Extension('cext',
                            sources = ['cext.c'])

        setup(name = 'cext',
            version = '1.0',
            description = 'This is a cext package',
            ext_modules= [module1])

        -> 进入cext.c所在目录 -> $ python setup.py build -> build/cext.pyd
    3.import cext #use cext module

|Ctypes

|SWIG ->

|Cython
