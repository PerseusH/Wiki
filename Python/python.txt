\System
    -> 遇到权限问题, 尝试sudo python xxx.py
    monkey patch -> 在运行时动态地对已定义的函数或对象进行修改或添加

\Debug
    PyChecker -> 静态分析工具,它报告源代码中的错误并且会报告错误类型和复杂度
    Pylint -> 检验模块代码是否达到标准的工具

    |iPython, PDB/iPDB
        import [pdb/ipdb]; [pdb/ipdb].set_trace() #设置断点
        ipython test.py --pdb #以调试模式运行程序,发现异常或断点则进入pdb控制台进行调试
        python -m [pdb/ipdb] test.py #以调试模式运行程序,直接进入pdb控制台

    |objgraph #对于查找内存泄露和大内存对象
        import objgraph; objgraph.show_most_common_types(n) #获取前n大内存对象

    |comment for docstring #在class或function内部
    > """
    > xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    > """

    |log级别从高到低: CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET
    -> level以下级别的log不会执行
    > import logging
    > logging.basicConfig(format='%(asctime)s: %(levelname)s:
    >   %(message)s',level=logging.WARNING)
    > logging.debug('This message should appear on the console')
    > logging.info('So should this')
    > logging.warning('And this, too')

\Type
    -> '{python3.x}'默认使用utf-8编码(支持特殊字符集)
    -> '{python3.x}'比'{python2.x}'慢, 主要慢在字符串和整数操作上
    isinstance(a, type_name) #a是否为某类型实例, 对整个继承链的类都有效
    type(a) #获取a的类型信息
    dir(a) #获取a的所有属性和方法, 返回一个list
    hasattr(a, 'xxx'), setattr(a, 'xxx', val), getattr(a, 'xxx') #属性操作
    type(file.py) -> <type 'module'>

    |字符&字符串
        -*- coding:utf-8 -*- #兼容特殊字符集, '{python2.x}'
        (u'\uxxxxxxx').encode('utf-8') -> utf-8字符 #python2.x
        ord('a') #字符转换为数字
        chr(97) #数字转换为字符
        'a' < 'c' #字符直接比较
        list(('sdgfdfgn')) #将字符串转换为单个字符数组, 不能用str.split('')

    |数字
        int('0xFFFF', 16) #16进制转10进制

\Calculation
    +|-|*|/ > and|or|not|== > = #计算顺序
    5/2=2.5('{python2.x}'=2) | 5.0/2=2.5 | 5/2.0=2.5 | 5//2=2 | 5.0//2.0=2.0 | 5.0//2=2.0
    -> is是对比引用地址, ==是对比值
    a, b = i, j #集中赋值
    x ** n #x的n次方
    |短路运算
        None|False|'' or 123 -> 123  None|False|'' and 123 -> None|False|''
        1|True|'a' or 123 -> 1|True|'a'  1|True|'a' and 123 -> 123

    True if 5 else False #True
    True if 0 else False #False
    True if -5 else False #True
    any(i % 3 == 0 for i in data_list) #判断data_list是否包含3的倍数,返回True/False
    2 ** 16 = 65536 | 0xFFFF = 2 ** 16 - 1
    1111 1111 = 2 ** 8 - 1 | 0.1111 1111 = 1 - 2 ** -8
    n/9 = 0.nnnnnnnnnnn...

\Function
    -> 当一个函数调用另一个函数，被调用函数获得控制权。直到它返回或发生异常，才把控制权还给调用者
    -> 每个函数都有一个__name__属性, 即函数签名
    -> 主函数签名为__main__
    -> pass是为了防止报错而占位, 本身没有意义
    -> C++的内联inline是把'{函数体的机器指令}'直接在需要的地方'{复制}'一遍.python是解释语言,运行由运行环境决定.所以没有内联函数
    -> 条件判断语句过长, 可在and|or|not后加 \ 换行

    > def func(*args, **kwargs) #*args为可变数目参数, **kwargs为任意内容字典型参数
        > func(1, 2, 3, a = 'xxx', b = 'yyy', c = 'zzz')

\Class
    -> 类是一个对象,在运行时由type()动态创建,每个class都是type类的一个实例
    -> class的类型是type, 类实例的类型是类名(type(xxx))
    -> 在类中不在self中的属性是类字段, 类的所有实例都能访问, 但只有类才能修改其值
    -> 修改实例中的类字段值后, 该实例的类字段不再受类的影响
    -> 创建一个类时, python会将该类所有'{属性}'收集到一个'{字典dict}'中
    -> python多继承链: super(Parent, self): #mro序列->拓扑排序(从下到上,从左到右)
    -> metaclass的意义在于对'{类属性字典}'的统一抽象操作(数据库读写, orm框架)
    -> 添加了@classmethod的函数的第一个参数总是该函数所在类的类名
    -> 使用了静态方法，则不能再使用self

    |property
    -> @property #为了使对类属性的操作可控, 可以检查参数
    -> 添加了@property的函数可以添加@func_name.setter方法以设置属性值,没添加setter方法的@property函数为只读属性,只有getter方法(@property)


    |variable
    self.__class__ #class_of_self
    self._abc #类的保护变量, 只允许类本身和子类访问, 'from...import...'不能访问
    self.__abc #类的私有变量, 只允许类本身访问
    self.__abc__ #类的特殊变量, 可以被外部直接访问
    -> self代表类的实例, 而非类
    -> '{python3.x}':__next__(), '{python2.x}': next()
    -> 类属性默认用dict存储,__slots__是用list存储属性名,而不会再使用dict,__slots__里没有的属性,类实例不能随便添加.'{节省了内存}', 限制了属性添加

\Container(List & Tuple & Dict & Set)
    -> list是一个数组而不是一个链表
    -> 数组(list)和元组(tuple)之间的区别是数组内容是可以被修改的而元组内容是只读的.元组可以被哈希比如作为字典的关键字
    list(dict.keys()), list(dict.values()), list(dict.items()) #字典对象操作
    l[-n] #倒序取值
    l.pop() #删除并返回list最后一个元素
    dict.iteritems() #迭代器python2.x
    dict.items() #乱序列表python3.x
    dict.clear() #dict -> {}
    -> dict和set都是使用hash表来实现的

    |comprehension
        nums=[i for i in data_list if i%3 == 0] #列表推导式(list comprehension)
        dict={i: i**n for i in data_list if i>0} #字典推导式(dict comprehension)
        [d for d in dict] #return keys of dict
        [dict[key] for key in dict] #return values of dict

    |dict operation
        list(zip((1, 2, 3), ('a', 'b', 'c'))) = [(1, 'a'), (2, 'b'), (3, 'c')]
        dict([(1, 'a'), (2, 'b'), (3, 'c')]) = {1: 'a', 2: 'b', 3: 'c'}
        dict([('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6)]) =
              {'a': 1, 'c': 3, 'b': 2, 'e': 5, 'd': 4, 'f': 6} #无序
        dc={'a': 1, 'b': 2, 'c': 3} #'a' in dc (True) | 1 in dc (False)
        sorted(zip(d.keys(), d.values()), reverse=True) #dict排序

        |设置字典默认值
        > d = {'k': 'value'}
        > x = d.get('k', 'v')
        > y = d.get('k1', 'v1')
        > x = 'value', y = 'v1'

        > equities = {}
        > for key, value in enumerate(data):
        >     equities.setdefault(key, []).append(value) #equities[key]=[value,]
        >  or equities.setdefault(key, value) #equities[key]=value

    |list operation
        > l=[[], [], [], [], []]
        > l[0].append(10) -> l=[[10], [], [], [], []] #普通

    |slice
        data_list[::n] #每隔n-1个数对data_list进行切片
        data_list[1: -1] #去掉头尾

    |*效应
        ['a'] * 5 = ['a', 'a', 'a', 'a', 'a']

        > l=[[]] * 5
        > l.append(10) -> l=[[], [], [], [], [], 10]
        > l[0|1|2|3|4].append(10) -> l=[[10], [10], [10], [10], [10]]
        > l[0|1|2|3|4].append(10); l[0|1|2|3|4].append(20) -> l=[[10,20], [10,20], [10,20], [10,20], [10,20]]

    |sort
        |'{不改变}'列表本身,返回排序后列表
        data_list[::-1] #按原序倒序排列
        sorted(data_list, key=str|int|len|lambda x: x.id, reverse=True) #按key排序
        reversed([1,2,3]) #生成list_reverseiterator, 倒序迭代器

        |'{改变}'列表本身,返回None
        from operator import itemgetter, attrgetter
        data_list.sort(key=itemgetter(0)|attrgetter(key)) #正序排序
        data_list.sort(key=itemgetter(0, 1)|attrgetter(key0, key1)) #多级正序排序
        data_list.reverse(key=itemgetter(0)|attrgetter(key)) #倒序排序
        data_list.reverse(key=itemgetter(0, 1)|attrgetter(key0, key1)) #多级倒序排序

\Lambda
    lambda x: x ** n #匿名函数(lambda), x为参数
    -> lambda的局限主要就是为了防止滥用.所以lambda'{只能写一行,不能赋值}',内部也不能定义等等
    -> Python中lambda函数的限制,是故意这么做的.原因很简单,Python把函数的'{可读性}'看得重.如果一个没名字的函数太长了,容易让程序看起来混乱,不容易看懂
    list(result) #将map, filter返回值转换为list类型

    |函数式编程
    > from functools import reduce
    > num = reduce(lambda i, j: i + j, filter(lambda n: n < 0, data_list))

    |生成匿名函数对象列表
    > def fl():
        > for i in range(4): yield lambda x : i * x #1.generator
        > return [lambda x, i=i: i*x for i in range(4)] #2.i=i闭包,在for之后延迟绑定
    > print([f(2) for f in fl()])

    |_add()返回一个匿名函数对象, _add()(n)为执行匿名函数
      def _add():
          return lambda x: x + 3

\Generator
    -> 生成器每次迭代只生成一个数, 只占用一份内存空间, 随后中断进行下次迭代
    -> list: [x for x in range(n)] | generator: (x for x in range(n))
    -> 包含yield关键字的函数是一个generator
    '{python3.x}' -> range(m, n)生成range对象,list(range(m, n))生成list;xrange去除
    '{python2.x}' -> range(m, n)生成list对象;xrange(m, n)生成一个生成器(generator)

\Regex
    -> 正则表达式中?表示尽可能少地匹配('{非贪婪匹配}')

\DataBase
    conn_str = %(dbn)s://%(user)s:%(pw)s@%(host)s:%(port)s/%(db)s #数据库连接字符串
    -> 数据库增删改操作必须有db.commit()

\File
    open('new.txt', '[w|a][+|b[+]]') #创建一个新文件
    read -> 读取整个文件
    readline -> 读取下一行,使用生成器方法
    readlines -> 读取整个文件到一个迭代器以供我们遍历
    'xt'-> 写一个文件,如果该文件已经存在,则不写

\Time
    > import datetime
    > dt = datetime.datetime.strptime('2017-10-13 10:10:10', '%Y-%m-%d %H:%M:%S')
    > now = datetime.datetime.now()
    > now.strftime('%Y-%m-%d %H:%M:%S')
    >>> 2017-10-13 10:10:10

\Copy
    嵌套items -> 浅copy始终共享,主改从变
    非嵌套items -> 所有copy一开始都是共享,若主对象更改item,会在本容器新建item,从对象不变
    > import copy
    > t = ['abc', [123]]
    > t1=copy.copy(t)|t.copy()(if t is list|dict) #new obj, share nested
    > t2 = copy.deepcopy(t) #absolutely new obj
    > print(t1 == t) #True
    > print(t1 is t) #False
    > print(t1[1] is t[1])#True, share nested
    > print(t2[1] is t[1])#False, absolutely new obj
    > t3 = t #new ref, same obj
    > print(t3 == t) #True
    > print(t3 is t) #True

\Decorator
    -> 装饰器(decorator)通过@function_name, 可以扩展现有函数功能(安全, 追踪, 锁定)
    -> 被装饰后的函数其实是另外一个函数(wrapper),__name__和docstring等属性会发生改变
    -> functools.wraps能保持原函数属性
    |实例
       > from functools import wraps
       > def decorator(func):
       >    @wraps(func)
       >    def wrapper(*args, **kvargs):
       >        # do something
       >        return func(*args, **kvargs)
       >    return wrapper

\Error
    '{python3.x}' -> except SystemExit as e:
    '{python2.x}' -> except SystemExit, e:
    raise ValueError(msg) #主动触发异常
    import traceback; traceback.print_exc() #获取详细异常信息
        format_exc() #返回字符串
        print_exc() #直接打印或写入文件traceback.print_exc(file=open('tb.txt','w+'))

    |用户自定义异常
    > class Networkerror(RuntimeError):
    >     def __init__(self, arg):
    >         self.args = arg

\Arch
    Django -> 大而全,模板引擎运算慢
    Flask -> 小而少,模板引擎运算快
    Celery -> 分布式异步任务队列管理
    Tornado -> 适合大型项目,丰富的异步API
    Asyncio -> 异步框架
    Mako -> 前端模板

\Test
    |pytest -> 测试框架
    $ python -m pytest -v #启动'test_'开头的function,module,'Test'开头的class

    |DocTest -> 在docstring中建立测试用例及期望结果
    $ python -m doctest test.py -v
    > def my_function(a, b):
    >     """
    >     >>> my_function(2, 3)
    >     6
    >     >>> my_function('a', 3)
    >     'aaa'
    >     """
    >     return a * b

    |UnitTest
    > import unittest
    > class XXXTest(unittest.TestCase):
    >     def setUp(self):
    >         pass
    >     def test_ok(self):
    >         self.assertEqual(a, b) #if a == b
    >     def test_ok1(self):
    >         self.assertTrue(if_true) #if if_true
    > if __name__ == '__main__':
    >     unittest.main()
