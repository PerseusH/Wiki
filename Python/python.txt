\Core
    -> Python的内存管理是由私有heap空间管理的
    -> 所有的Python对象和数据结构都在一个私有heap中.程序员没有访问该heap的权限,只有解释器才能对它进行操作
    -> Python的内存管理模块为Python的heap空间分配内存.其核心API提供一些访问该模块的方法供程序员使用
    -> Python的垃圾回收: 1.引用计数 2.标记清除 3.分代回收

\Debug
    PyChecker -> 静态分析工具,它报告源代码中的错误并且会报告错误类型和复杂度
    Pylint -> 检验模块代码是否达到标准的工具

    |iPython, PDB/iPDB
        import [pdb/ipdb]; [pdb/ipdb].set_trace() #设置断点
        ipython test.py --pdb #以调试模式运行程序,发现异常或断点则进入pdb控制台进行调试
        python -m [pdb/ipdb] test.py #以调试模式运行程序,直接进入pdb控制台

\Type
    -> '{python3.x}'默认使用utf-8编码(支持特殊字符集)
    -> '{python3.x}'比'{python2.x}'慢, 主要慢在字符串和整数操作上
    isinstance(a, type_name) #a是否为某类型实例, 对整个继承链的类都有效
    type(a) #获取a的类型信息
    dir(a) #获取a的所有属性和方法, 返回一个list
    hasattr(a, 'xxx'), setattr(a, 'xxx', val), getattr(a, 'xxx') #属性操作

    |字符&字符串
        -*- coding:utf-8 -*- #兼容特殊字符集, '{python2.x}'
        ord('a') #字符转换为数字
        chr(97) #数字转换为字符
        'a' < 'c' #字符直接比较
        list(('sdgfdfgn')) #将字符串转换为单个字符数组, 不能用str.split('')

    |数字
        int('0xFFFF', 16) #16进制转10进制

\Calculation
    +|-|*|/ > and|or|not|== > = #计算顺序
    5/2=2.5('{python2.x}'=2) | 5.0/2=2.5 | 5//2=2 | 5.0//2.0=2.0 | 5.0//2=2.0
    -> is是对比地址, ==是对比值
    a, b = i, j #集中赋值(a, b = b, a #数值互换)
    x ** n #x的n次方
    |短路运算
        None|False|'' or 123 -> 123  None|False|'' and 123 -> None|False|''
        1|True|'a' or 123 -> 1|True|'a'  1|True|'a' and 123 -> 123

    any(i % 3 == 0 for i in data_list) #判断data_list是否包含3的倍数,返回True/False
    2 ** 16 = 65536 | 0xFFFF = 2 ** 16 - 1
    1111 1111 = 2 ** 8 - 1 | 0.1111 1111 = 1 - 2 ** -8

\System
    -> 遇到权限问题, 尝试sudo python xxx.py
    monkey patch -> 在运行时动态地对已定义的函数或对象进行修改或添加
    os.system("ps -ef | grep xxx") #执行shell脚本
    sys.exit() #退出运行环境
    sys.getsizeof(arg) #获取变量所占内存大小

    |logging
    > import logging
    > logging.basicConfig(level = logging.INFO)
    > logging.info('xxx xxx') #调试程序, 记录信息

\Function
    -> 每个函数都有一个__name__属性, 即函数签名
    -> 主函数签名为__main__
    -> pass是为了防止报错而占位, 本身没有意义
        > def func(*args, **kwargs) #*args为可变数目参数, **kwargs为任意内容字典型参数
        eg > func(1, 2, 3, a = 'xxx', b = 'yyy', c = 'zzz')

\Class
    -> 类是一个对象
    -> class是运行时由type()动态创建的, 每个class都是type类的一个对象
    -> class的类型是type, 类实例的类型是类名(type(xxx))
    -> 在类中不在self中的属性是类字段, 类的所有实例都能访问, 但只有类才能修改其值
    -> 创建一个类时, python会将该类所有属性收集到一个字典dict中
    -> python多继承链: super(Parent, self): #mro序列->拓扑排序
    -> metaclass的意义在于对类属性字典的操作(数据库读写, orm框架)

    |property
    -> @property #为了使对类属性的操作可控, 可以检查参数
    -> 添加了@property的函数可以添加@func_name.setter方法以设置属性值,没添加setter方法的@property函数为只读属性,只有getter方法(@property)
    -> 添加了@classmethod的函数的第一个参数总是该函数所在类的类名

    |variable
    self.__class__ == class_of_self
    self._abc #类的保护变量, 只允许类本身和子类访问, 'from...import...'不能访问
    self.__abc #类的私有变量, 只允许类本身访问
    self.__abc__ #类的特殊变量, 可以被外部直接访问
    -> self代表类的实例, 而非类
    -> '{python3.x}':__next__(), '{python2.x}': next()
    -> python类属性默认用dict存储,__slots__是用list存储属性名,而不会再使用dict,__slots__里没有的属性,类实例不能随便添加.节省了内存, 限制了属性添加

\List & Tuple & Dict
    -> 数组(list)和元组(tuple)之间的区别是数组内容是可以被修改的而元组内容是只读的.元组可以被哈希比如作为字典的关键字
    list(dict.keys()), list(dict.values()), list(dict.items()) #字典对象操作
    dict.clear() #dict -> {}

    |list comprehension
        nums=[i for i in data_list if i%3 == 0] #列表推导式(list comprehension)
        dict={i: i**n for i in data_list if i>0} #字典推导式(dict comprehension)
        [d for d in dict] #return keys of dict
        [dict[key] for key in dict] #return values of dict

    |dict operation
        zip((1, 2, 3), ('a', 'b', 'c')) = [(1, 'a'), (2, 'b'), (3, 'c')]
        dict([(1, 'a'), (2, 'b'), (3, 'c')]) = {1: 'a', 2: 'b', 3: 'c'}
        dict([('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6)]) =
              {'a': 1, 'c': 3, 'b': 2, 'e': 5, 'd': 4, 'f': 6} #'{python2.x}'
        dict(data_list)在'{python3.x}'中有序, 在'{python2.x}'中无序
        dc={'a': 1, 'b': 2, 'c': 3} #'a' in dc (True) | 1 in dc (False)

    |list operation
        > l=[[], [], [], [], []]
        > l[0].append(10) -> l=[[10], [], [], [], []] #普通

        data_list[::n] #每隔n-1个数对data_list进行切片

    |*效应
        ['a'] * 5 = ['a', 'a', 'a', 'a', 'a']

        > l=[[]] * 5
        > l.append(10) -> l=[[], [], [], [], [], 10]
        > l[0|1|2|3|4].append(10) -> l=[[10], [10], [10], [10], [10]]
        > l[0|1|2|3|4].append(10) l[0|1|2|3|4].append(20) -> l=[[10,20], [10,20], [10,20], [10,20], [10,20]]

    |sort
        data_list[::-1] #对data_list按原序倒序排列, 不改变列表本身
        data_list.sort() #正序排序, 改变列表本身, 返回值为None
        data_list.reverse() #倒序排序, 改变列表本身, 返回值为None
        sorted(data_list, key=lambda x: x.name reverse=True) #按key排序,不改变列表本身,返回值为排序后列表

\Lambda
    lambda x: x ** n #匿名函数(lambda), x为参数
    -> lambda没有语句的原因是它被用于在代码被执行的时候构建并返回新的函数对象
    list(map_list) #将map, filter返回值转换为list类型

    |函数式编程
    > from functools import reduce
    > num = reduce(lambda i, j: i + j, filter(lambda n: n < 0, data_list))

    |生成匿名函数对象列表
    > def fl():
        > for i in range(4): yield lambda x : i * x #1.generator
        > return [lambda x, i=i: i*x for i in range(4)] #2.i=i闭包,在for之后延迟绑定
    > print([f(2) for f in fl()])

    |_add()返回一个匿名函数对象, _add()(n)为执行匿名函数
      def _add():
          return lambda x: x + 3

\Generator
    -> 生成器每次迭代只生成一个数, 只占用一份内存空间, 随后中断进行下次迭代
    -> list: [x for x in range(n)] | generator: (x for x in range(n))
    -> 包含yield关键字的函数是一个generator
    '{python3.x}' -> range(m, n)生成range对象,list(range(m, n))生成list;xrange去除
    '{python2.x}' -> range(m, n)生成list对象;xrange(m, n)生成一个生成器(generator)

\Regex
    -> 正则表达式中?表示尽可能少地匹配(非贪婪匹配)

\DataBase
    -> 数据库增删改操作必须有 db.commit()

\File
    open('new.txt', '[w|a][+|b[+]]') #创建一个新文件
    read -> 读取整个文件
    readline -> 读取下一行,使用生成器方法
    readlines -> 读取整个文件到一个迭代器以供我们遍历

\Time
    > import datetime
    > dt = datetime.datetime.strptime('2017-10-13 10:10:10', '%Y-%m-%d %H:%M:%S')
    > now = datetime.datetime.now()
    > now.strftime('%Y-%m-%d %H:%M:%S')
    > >>>  2017-10-13 10:10:10

\Copy
    > import copy
    > t = ['abc', [123]]
    > t1 = copy.copy(t) | t.copy()(if t is list|dict) #new obj, share nested obj
    > t2 = copy.deepcopy(t) #absolutely new obj
    > print(t1 == t) #True
    > print(t1 is t) #False
    > print(t1[1] is t[1])#True, share nested obj: ([[123]] | {key: [123]})
    > print(t2[1] is t[1])#False, absolutely new obj
    > t3 = t #new ref, same obj
    > print(t3 == t) #True
    > print(t3 is t) #True

\Decorator
    -> 装饰器(decorator)通过@function_name, 可以扩展现有函数功能(安全, 追踪, 锁定)
    |实例
       > ?????????????

\Arch
    Django -> 大而全,模板引擎运算慢
    Flask -> 小而少,模板引擎运算快
    Tornado -> 适合大型项目
    Mako -> 前端模板

\Test
    框架 -> pytest
    python -m pytest -v #启动'test_'开头的function,module,'Test'开头的class

    |UnitTest
    > import unittest
    > class XXXTest(unittest.TestCase):
    >     def setUp(self):
    >         pass
    >     def test_ok(self):
    >         self.assertEqual(a, b) #if a == b
    >     def test_ok1(self):
    >         self.assertTrue(if_true) #if if_true
    > if __name__ == '__main__':
    >     unittest.main()

\OOP
    -> 控制反转 -> (Inversion of Control,缩写为IoC),是面向对象编程中的一种设计原则
    -> 用来降低代码之间的耦合度
    -> 最常见的方式是依赖注入(Dependency Injection,简称DI)
    -> 还有一种方式是依赖查找(Dependency Lookup)
    -> 通过控制反转,对象在被创建的时候,由一个调控系统内所有对象的外界实体
    -> 将其所依赖的对象的引用传递给它.也可以说,依赖被注入到对象中
