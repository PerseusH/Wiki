\System
    -> 遇到权限问题, 尝试sudo python xxx.py
    monkey patch -> 在运行时动态地对已定义的函数或对象进行修改或添加
    > import sys; sys.path.append(lib_path) #添加库模块路径后可以从其他目录import lib

\Debug
    PyChecker -> 静态分析工具,它报告源代码中的错误并且会报告错误类型和复杂度
    Pylint -> 检验模块代码是否达到标准的工具

    |iPython, PDB/iPDB
        import [pdb/ipdb]; [pdb/ipdb].set_trace() #设置断点
        ipython test.py --pdb #以调试模式运行程序,发现异常或断点则进入pdb控制台进行调试
        python -m [pdb/ipdb] test.py #以调试模式运行程序,直接进入pdb控制台

    |objgraph #用于查找内存泄露和大内存对象
        import objgraph; objgraph.show_most_common_types(n) #获取前n大内存对象

    |comment for docstring #在class或function内部
    > """
    > xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    > """

    |logging
    > #级别从高到低: CRITICAL>ERROR>WARNING>INFO>DEBUG>NOTSET, level以下级别的logging不会执行
    > import logging
    > #name为系统当前用户名
    > logging.basicConfig(level=logging.INFO, format='%(asctime)s %(filename)s: %(lineno)s %(name)s %(levelname)s %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
    > logging.debug('This message should appear on the console')
    > logging.info('So should this')
    > logging.warning('And this, too')

\Type
    |Python3有六个标准的数据类型
        1.Number（数字）int、float、bool、complex（复数 4+3i）
        2.String（字符串）
        3.List（列表）
        4.Tuple（元组）
        5.Set（集合）
        6.Dictionary（字典）

    函数	                   描述
    int(x [,base])          将x转换为整数,默认10进制 int() = 0
    float(x)                将x转换到一个浮点数
    complex(real [,imag])   创建一个复数
    str(x)                  将对象 x 转换为字符串
    repr(x)                 将对象 x 转换为表达式字符串
    eval(str)               计算在字符串中的表达式,并返回一个对象.如 eval(bin(7))->7
    tuple(s)                将序列 s 转换为一个元组
    list(s)                 将序列 s 转换为一个列表
    set(s)                  转换为可变集合
    dict(d)                 创建一个字典。d 必须是一个序列 (key,value)元组。
    frozenset(s)            转换为不可变集合
    chr(x)                  将一个整数转换为一个字符
    ord(x)                  将一个字符转换为整数
    hex(x)                  将整数转换为十六进制字符串 int('0xFFFF', 16) 16进制->10进制
    oct(x)                  将整数转换为八进制字符串 int('0o5', 8) 8进制->10进制
    bin(x)                  将整数转换为二进制字符串 int('0b111', 2) 2进制->10进制

    -> '{python3.x}'默认使用utf-8编码(支持特殊字符集)
    -> '{python3.x}'比'{python2.x}'慢, 主要慢在字符串和整数操作上
    isinstance(a, type_name) #a是否为某类型实例, 对整个继承链的类都有效
    type(a) #获取a的类型信息，不会认为子类是一种父类类型
    dir(a) #获取a的所有属性和方法, 返回一个list
    hasattr(a, 'xxx'), setattr(a, 'xxx', val), getattr(a, 'xxx') #属性操作
    type(file.py) -> <type 'module'>

    |Memory
        -> 数值, 字符串, 元组本身不能被修改; 字典, 列表, Set可以被修改
        id(a) #获取变量的内存地址
        0 is 0; '' is ''; () is () -> True #值类型相同值只分配一块内存, 修改变量值会分配新内存
        [] is []; {} is {}; ([]) is ([]) -> False #引用类型相同值分配多个独立内存
        -> 数值、字符串，元组采用的是复制的方式(深拷贝)，也就是说当将另
    一个变量B赋值给变量A时，虽然A和B的内存空间仍然相同，但当A的值发生变化时，会重新给A分配空间，A和B的地址变得不再相同
        -> 对于字典(dict)，列表(List)等，改变一个就会引起另一个的改变(浅拷贝)

    |字符&字符串
        -*- coding:utf-8 -*- #兼容特殊字符集, '{python2.x}'
        (u'\uxxxxxxx').encode('utf-8') -> utf-8字符 #python2.x

        |统计字符串中子串或字符的个数
            s.count(sub_str) #不重复统计  s.count('') -> len(s) + 1
            import re; len(re.findall(r'(?=word)', s)) #重复统计

        'a' < 'c' #字符直接比较
        'x' * n -> 'xxx...{n}'
        list(('sdgfdfgn')) #将字符串转换为单个字符数组, 不能用str.split('')
        -> 反斜杠可以用来转义，使用'{r}'可以让反斜杠不发生转义
        -> Python 字符串'{不能被改变}'。向一个索引位置赋值，比如word[0] = 'm'会导致错误
            -> 字符串是一种特殊的元组
        -> List中的元素是'{可以改变}'的
        -> Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始
        -> 正则表达式中+?, *?表示尽可能少地匹配('{非贪婪匹配}')

    |Calculation
        +|-|*|/|%|>>|<<|~|&|||^ > is|not|in|==|!= > and > or > = #计算顺序
        5/2=2.5('{python2.x}'=2) | 5.0/2=2.5 | 5/2.0=2.5 | 5//2=2 | 5.0//2.0=2.0 | 5.0//2=2.0
        -> is是对比引用地址, ==是对比值
        a, b = i, j #集中赋值
        a = b = c = 1 #创建一个整型对象，值为1，三个变量被分配到相同的内存空间上
        x ** n -> pow(x, n) #x的n次方
        abs(n) #求绝对值
        None, False, "", 0, [], {}, ()相当于False. not *prev* == True.负数相当于True
            -> if not x 不严谨，这几项都符合; if x is *prev* 只有指定项符合

        |短路运算
            None|False|'' or 123 -> 123  None|False|'' and 123 -> None|False|''
            1|True|'a' or 123 -> 1|True|'a'  1|True|'a' and 123 -> 123

        any(i % 3 == 0 for i in data_list) #判断data_list是否包含3的倍数,返回True/False
        2 ** 16 = 65536 | 0xFFFF = 2 ** 16 - 1
        1111 1111 = 2 ** 8 - 1 | 0.1111 1111 = 1 - 2 ** -8
        n/9 = 0.nnnnnnnnnnn...

        |位运算 -> 数据默认为'{补码}'表示(正数补码为真值, 负数补码为真值'{取反加一}')
            a & b #与运算, 有零得零
                a & 1 #若a末位为1则返回1, 为0则返回零
            a | b #或运算, 有一得一
            a ^ b #异或运算, 相异得一, 相同得零
            ~ a   #非运算, 取反, 结果为 -a-1
            a<<n  #左移n位, 结果为 a * (2 ** n)
            a>>n  #右移n位, 结果为 a / (2 ** n)

\Function
    -> 当一个函数调用另一个函数，被调用函数获得控制权。直到它返回或发生异常，才把控制权还给调用者
    -> 每个函数都有一个__name__属性, 即函数签名
    -> 主函数签名为__main__
    -> pass是为了防止报错而占位, 本身没有意义
    -> C++的内联inline是把'{函数体的机器指令}'直接在需要的地方'{复制}'一遍.python是解释性语言,运行由运行环境决定.所以没有内联函数
    -> 条件判断语句过长, 可在and|or|not后加 \ 换行
    -> 有默认值参数必须在无默认值参数后面

    > def func(*args, **kwargs) #*args为tuple类可变数目参数,**kwargs为任意内容字典型参数
    >     func(1, 2, 3, a = 'xxx', b = 'yyy', c = 'zzz')

\Class
    -> 类是一个对象,在运行时由type()动态创建,每个class都是type类的一个实例
    -> class的类型是type, 类实例的类型是类名(type(xxx))
    -> 在类中不在self中的属性是类字段, 类的所有实例都能访问, 但只有类才能修改其值
    -> 修改实例中的类字段值后, 该实例的类字段不再受类的影响
    -> 创建一个类时, python会将该类所有'{属性}'收集到一个'{字典dict}'中
    -> python多继承链: super(Parent, self): #mro序列->拓扑排序(从下到上,从左到右)
    -> metaclass的意义在于对'{类属性字典}'的统一抽象操作(数据库读写, orm框架)
    -> 添加了@classmethod的函数的第一个参数总是该函数所在类的类名
    -> 使用了静态方法，则不能再使用self

    |property
    -> @property #为了使对类属性的操作可控, 可以检查参数
    -> 添加了@property的函数可以添加@func_name.setter方法以设置属性值,没添加setter方法的@property函数为只读属性,只有getter方法(@property)


    |variable
    self.__class__ #class_of_self
    self._abc #类的保护变量, 只允许类本身和子类访问, 'from...import...'不能访问
    self.__abc #类的私有变量, 只允许类本身访问
    self.__abc__ #类的特殊变量, 可以被外部直接访问
    -> self代表类的实例, 而非类
    -> '{python3.x}':__next__(), '{python2.x}': next()
    -> 类属性默认用dict存储,__slots__是用list存储属性名,而不会再使用dict,__slots__里没有的属性,类实例不能随便添加.'{节省了内存}', 限制了属性添加

\Container(List & Tuple & Dict & Set)
    -> list是一个数组而不是一个链表
    -> 数组(list)和元组(tuple)之间的区别是数组内容是可以被修改的而元组内容是只读的.元组可以被哈希比如作为字典的关键字
    -> dict和set都是使用hash表来实现的

    |comprehension
        nums=[i for i in data_list if i%3 == 0] #列表推导式(list comprehension)
        dict={i: i**n for i in data_list if i>0} #字典推导式(dict comprehension)
        [d for d in dict] #return keys of dict
        [dict[key] for key in dict] #return values of dict

    |dict operation
        dict.iteritems() #迭代器python2.x
        dict.items() #乱序列表python3.x
        dict.clear() #dict -> {}
        dict.update(dict1) #把dict1中的内容更新到dict中
        dict.pop(key, [default_value]) #删除key并返回其value,若key不存在则返回默认值,未设置默认值则报错
        dict(user='root', password='root') -> {'user': 'root', 'password': 'root'}

        zip((1, 2, 3), ('a', 'b', 'c', 'd')) -> [(1, 'a'), (2, 'b'), (3, 'c')]

        list(zip((1, 2, 3), ('a', 'b', 'c'))) -> [(1, 'a'), (2, 'b'), (3, 'c')]
        dict([(1, 'a'), (2, 'b'), (3, 'c')]) -> {1: 'a', 2: 'b', 3: 'c'}
        dict([('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6)]) ->
              {'a': 1, 'c': 3, 'b': 2, 'e': 5, 'd': 4, 'f': 6} #无序
        dc = {'a': 1, 'b': 2, 'c': 3} #'a' in dc (True) | 1 in dc (False)
        sorted(zip(d.keys(), d.values()), reverse=True) #dict排序

        |设置字典默认值
        > d = {'k': 'value'}
        > x = d.get('k', 'v')
        > y = d.get('k1', 'v1')
        > x = 'value', y = 'v1'

        > equities = {}
        > for key, value in enumerate(data):
        >     equities.setdefault(key, []).append(value) #equities[key]=[value,]
        >  or equities.setdefault(key, value) #equities[key]=value

    |list operation
        list(dict.keys() | dict.values() | dict.items()) #字典对象操作
        l[-n] #倒序取值
        l.pop(n) #删除并返回l[n], n为空则默认删除并返回list最后一个元素
        l.pop() ==> l.pop(-1)
        ['a'] + ['b'] -> ['a', 'b']

        > l=[[], [], [], [], []]
        > l[0].append(10) -> l=[[10], [], [], [], []] #普通

    |slice
        data_list[::n] #每隔n-1个数对data_list进行切片
        data_list[1: -1] #去掉头尾

    |*效应
        ['a'] * 5 = ['a', 'a', 'a', 'a', 'a']

        > l=[[]] * 5
        > l.append(10) -> l=[[], [], [], [], [], 10]
        > l[0|1|2|3|4].append(10) -> l=[[10], [10], [10], [10], [10]]
        > l[0|1|2|3|4].append(10); l[0|1|2|3|4].append(20) -> l=[[10,20], [10,20], [10,20], [10,20], [10,20]]

    |sort
        |'{不改变}'列表本身,返回排序后列表
        data_list[::-1] #按原序倒序排列
        sorted(data_list, key=str|int|len|lambda x: x.id, reverse=True) #按key排序
        reversed([1,2,3]) #生成list_reverseiterator, 倒序迭代器

        |'{改变}'列表本身,返回None
        from operator import itemgetter, attrgetter
        data_list.sort(key=itemgetter(0)|attrgetter(key)) #正序排序
        data_list.sort(key=itemgetter(0, 1)|attrgetter(key0, key1)) #多级正序排序
        data_list.reverse(key=itemgetter(0)|attrgetter(key)) #倒序排序
        data_list.reverse(key=itemgetter(0, 1)|attrgetter(key0, key1)) #多级倒序排序

    |tuple
        -> 元组的元素不能修改, 其他操作和List一样
        t = ('x',) #一个元素的元组声明时要在元素后加逗号
        type(('x',)) -> <type 'tuple'>
        type(('x')) -> <type 'str'>

    |set
        -> 集合是一个无序不重复元素的序列. 基本功能是进行成员'{关系测试和删除重复}'元素
        -> 可以用大括号{}或者set(list)函数创建集合({...}或set(val)). 创建一个空集合必须用set(list)而不是{}，因为{}是用来创建一个空字典. set([...]) == {...}

        > student = {'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'}
        > print(student)   #输出集合，重复的元素被自动去掉

        > #成员关系测试
        > if 'Rose' in student:
        >     print('Rose 在集合中')

        > #集合运算
        > a = set('abracadabra')
        > b = set('alacazam')
        > print(a - b)     # a和b的差集
        > print(a | b)     # a和b的并集
        > print(a & b)     # a和b的交集
        > print(a ^ b)     # a和b中不同时存在的元素

\Lambda
    lambda x: x ** n #匿名函数(lambda), x为参数
    -> lambda的局限主要就是为了防止滥用.所以lambda'{只能写一行,不能赋值}',内部也不能定义等等
    -> Python中lambda函数的限制,是故意这么做的.原因很简单,Python把函数的'{可读性}'看得重.如果一个没名字的函数太长了,容易让程序看起来混乱,不容易看懂
    list(result) #将map, filter返回值转换为list类型

    |函数式编程
    > from functools import reduce
    > num = reduce(lambda i, j: i + j, filter(lambda n: n < 0, data_list))

    |生成匿名函数对象列表
    > def fl():
        > for i in range(4): yield lambda x : i * x #1.generator
        > return [lambda x, i=i: i*x for i in range(4)] #2.i=i闭包,在for之后延迟绑定
    > print([f(2) for f in fl()])

    |_add()返回一个匿名函数对象, _add()(n)为执行匿名函数
    > def _add():
    >     return lambda x: x + 3

\Functional
    -> python2.x中map, filter返回'{list}'
    -> python3.x中map, filter返回'{迭代器}'
    -> python2.x中有reduce, python3.x中需from functools import reduce

\Iterator
    |可以直接用于for循环的对象统称为可迭代对象('{Iterable}')
    -> 实现了__iter__方法
    1.集合数据类型,如list、tuple、dict、set、str等
    2.generator,包括生成器和带yield的generator function

    |generator
        |next -> 启动生成器|生成下一个值
            > next(gen) #python3.x
            > gen.next() #python2.x
        |send -> val指定的是上一次被挂起的yield语句的返回值.send返回生成器生成的下一个yield值或者StopIteration异常（如果生成器没有生成下一个yield值就退出了）
            > gen.send(val)
        |throw -> 通过向生成器对象在上次被挂起处，抛出一个异常。之后会继续执行生成器对象中后面的语句，直至遇到下一个yield语句返回。如果在生成器对象方法执行完毕后，依然没有遇到yield语句，抛出StopIteration异常
            > gen.throw(Exception, msg)
        |close -> 在生成器对象方法的挂起处(yield)抛出一个GeneratorExit异常。GeneratorExit异常产生后，系统会继续把生成器对象方法后续的代码执行完毕
            > def myGenerator():
            >     try:
            >         yield 1
            >         print "Statement after yield"
            >     except GeneratorExit:
            >         print "Generator error caught" #生成器对象结束
            >
            >     print "End of myGenerator"
            > #当调用gen.close()时，恢复生成器方法的执行过程。系统在yield语句处抛出GeneratorExit异常，执行过程跳到except语句块。当except语句块处理完毕后，系统会继续往下执行，直至生成器方法执行结束
            > #GeneratorExit异常的产生意味着生成器对象的生命周期已经结束。因此，一旦产生了GeneratorExit异常，生成器方法后续执行的语句中，不能再有yield语句，否则会产生RuntimeError
            > #GeneratorExit异常继承自BaseException类。BaseException类与Exception类不同。一般情况下，BaseException类是所有内建异常类的基类，而Exception类是所有用户定义的异常类的基类
            > except Exception: pass #只能捕获用户定义的异常,不能捕获BaseException

    |yield -> next执行到yield时方法的执行过程被'{挂起}'，而next方法返回值为yield关键字后面表达式的值.gen.next()|gen.send(n)唤醒被挂起的方法继续执行

    |可以被next()函数调用并不断返回下一个值的对象是Iterator(迭代器)
    -> 实现了__iter__和(__next__(python3.x)|next(python2.x))方法
    -> __iter__返回迭代器自身,__next__返回容器中的下一个值
    -> Iterator对象表示的是一个数据流,可以被next()函数调用并不断返回下一个数据,直到没有数据时抛出'{StopIteration}'错误.这个数据流是一个有序序列,我们'{不能提前知道序列长度}',只能不断通过next()函数实现按需计算下一个数据,所以Iterator的计算是'{惰性}'的,只有在需要'{返回下一个数据}'时它才会计算
    -> 生成器是一种特殊的'{Iterator}',不需要实现__iter__和__next__,只需yiled关键字
    -> list、dict、str不是'{Iterator}'
    -> iter()可以把list、dict、str等变成'{Iterator}' -> iter([]),iter('abc')
    -> Python的for循环就是通过不断调用next()函数实现的(for = loop(next(iterator)))
        > for x in [1, 2, 3, 4, 5]:
        >     pass
        -> 等价于
        > it = iter([1, 2, 3, 4, 5]) #首先获得Iterator对象
        > while True: #循环
        >     try:
        >         x = next(it) #获得下一个值
        >     except StopIteration:
        >         break #遇到StopIteration就退出循环

    -> 生成器每次迭代只生成一个数, 只占用一份内存空间, 随后中断进行下次迭代
    -> list: [x for x in range(n)] | generator: (x for x in range(n))
    -> 包含yield关键字的函数是一个generator

    |range(start, stop[, step=1])
        -> 返回从start, start+step,...到'{stop之前}'的所有结果, 最大结果为(stop-1)
        '{python3.x}' -> range生成range对象,list(range(start, stop[, step]))生成list;xrange去除
            -> 返回的range对象是'{迭代器}'
        '{python2.x}' -> range生成list对象;xrange(start, stop[, step])生成一个生成器(generator)

\DataBase
    conn_str = %(dbn)s://%(user)s:%(pw)s@%(host)s:%(port)s/%(db)s #数据库连接字符串
    -> 数据库增删改操作必须有db.commit()

\File
    open('new.txt', '[w|a][+|b[+]]') #创建一个新文件
    read -> 读取整个文件
    readline -> 读取下一行,使用生成器方法
    readlines -> 读取整个文件到一个迭代器以供我们遍历
    'xt'-> 写一个文件,如果该文件已经存在,则不写

\Copy
    嵌套items -> 浅copy始终共享,主改从变; deepcopy不共享
    非嵌套items -> 所有copy一开始都是共享,若主对象更改item,会在本容器新建item,从对象不变
    > import copy
    > t = ['abc', [123]]
    > t1=copy.copy(t)|t.copy()(if t is list|dict) #new obj, share nested
    > t2 = copy.deepcopy(t) #absolutely new obj
    > print(t1 == t) #True
    > print(t1 is t) #False
    > print(t1[1] is t[1])#True, share nested
    > print(t2[1] is t[1])#False, absolutely new obj
    > t3 = t #new ref, same obj
    > print(t3 == t) #True
    > print(t3 is t) #True

\Decorator
    -> 装饰器(decorator)通过@function_name, 可以扩展现有函数功能(安全, 追踪, 锁定)
    -> 被装饰后的函数其实是另外一个函数(wrapper),__name__和docstring等属性会发生改变
    -> functools.wraps能保持原函数属性

    |实例
    > from functools import wraps
    > def decorator(func):
    >    @wraps(func)
    >    def wrapper(*args, **kvargs):
    >        # do something
    >        return func(*args, **kvargs)
    >    return wrapper

\Error
    '{python3.x}' -> except SystemExit as e:
    '{python2.x}' -> except SystemExit, e:
    raise XXXError(msg) #主动触发异常
    import traceback; traceback.print_exc() #获取详细异常信息
        format_exc() #返回字符串
        print_exc() #直接打印或写入文件traceback.print_exc(file=open('tb.txt','w+'))

    |用户自定义异常
    > class Networkerror(RuntimeError):
    >     def __init__(self, arg):
    >         self.args = arg
