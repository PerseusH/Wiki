\System
    -> 遇到权限问题, 尝试sudo python xxx.py
    |monkey patch -> 在运行时动态地对已定义的函数或对象进行修改或添加
    > import sys; sys.path.append(lib_path) #添加库模块路径后可以从其他目录import lib

    |comment for docstring #在class或function内部
        > """
        > xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
        > """

\Type
    |Python3标准数据类型
        Number(int、float、bool、complex(复数 4+3i)), Str, List, Tuple, Set, Dict
        |内建类型 -> numerics(数字)、sequences(序列)、mappings(映射)、classes、instances and exception. 标准数据类型都是内建类型

    -> isinstance(False, int) -> True #bool是int的子类
    -> *.py 文件类型为<type 'module'>
    -> '{python3.x}'默认使用utf-8编码(支持特殊字符集)
    -> '{python3.x}'比'{python2.x}'慢, 主要慢在字符串和整数操作上

    |type & isinstance
        |推荐用'{isinstance}' > type
            1.经典类的实例type都是<type 'instance'>, 容易判断错误
            2.type只能判断直接父类; isinstance对整个继承链都有效

        > class A: pass #old-style class
        > type(A()) -> <type 'instance'>
        > class B: pass
        > type(B()) == type(A()) -> True #结果明显错误

        > class A(object): pass #new-style class
        > type(A()) -> <class '__main__.A'>

    |Calculation
        +|-|*|/|%|>>|<<|~|&|||^ > is|not|in|==|!= > and > or > = #计算顺序
        5/2=2.5('{python2.x}'=2) | 5.0/2=2.5 | 5/2.0=2.5 | 5//2=2 | 5.0//2.0=2.0 | 5.0//2=2.0
        -> is是对比引用地址, ==是对比值
        a, b = i, j #集中赋值
        a = b = c = 1 #创建一个整型对象，值为1，三个变量被分配到相同的内存空间上
        x = 1, 2, 3 -> x -> (1, 2, 3), x = 1, -> x -> (1,)
        eval('9.9')<=>eval('09.9') -> 9.9, eval('09') -> 报错,整数字符串第一位不能为0
        None, False, "", 0, [], {}, ()相当于False. not *prev* == True.负数相当于True
            -> if not x 不严谨，这几项都符合; if x is *prev* 只有指定项符合

        |短路运算
            None|False|'' or 123 -> 123  None|False|'' and 123 -> None|False|''
            1|True|'a' or 123 -> 1|True|'a'  1|True|'a' and 123 -> 123

        2 ** 16 = 65536 | 0xFFFF = 2 ** 16 - 1
        1111 1111 = 2 ** 8 - 1 | 0.1111 1111 = 1 - 2 ** -8
        n/9 = 0.nnnnnnnnnnn...

\Function
    -> 当一个函数调用另一个函数，被调用函数获得控制权。直到它返回或发生异常，才把控制权还给调用者
    -> 每个函数都有一个__name__属性, 即函数签名. 主函数签名为__main__
    -> pass是为了防止报错而占位, 本身没有意义
    -> C++的内联inline是把'{函数体的机器指令}'直接在需要的地方'{复制}'一遍.python是解释性语言,运行由运行环境决定.所以没有内联函数
    -> 条件判断语句过长, 可在and|or|not后加 \ 换行
    -> 有默认值参数必须在无默认值参数'{后面}' 如 def func(*args, name='', age=0): pass
    -> func.__class__ -> <class 'function'>
    -> func.__class__.__name__ -> 'function'
    -> func.__name__ -> 'FuncName'

    |First-Class Function(作为一等公民的函数)
        -> 支持高阶函数, 实现了函数复用
        |First-Class Function -> 可以被当作其他函数参数, 可以被当作返回值, 可以赋值给变量
        |Second-Class Function -> 可以被当作其他函数参数
        |Third-Class Function -> 三者都不可以

    |Variable
        -> 可变和不可变类型指的是'{值}'是否可变
        a = 1; b = a; a = 2; c = 1 -> id(1) == id(b) == id(c)
        l = []; l1 = l; l.append(1) -> l == l1 == [1]
            l = [3] -> l != l1, l == [3], l1 == [1]
        l = []; idl = id([]); l.append(1); idl1 = id([]) -> id(l) == idl != idl1

        |赋值 -> 拷贝对象的引用(内存地址)给变量. 赋值就是一种非原地修改
        |重新定义 -> 修改不可变变量, 不改变对象本身内存, 重新分配一块内存赋值给变量
        |原地操作 -> 修改可变变量, 在对象本身内存做修改

        |Copy
            |嵌套items -> 浅copy始终共享,主改从变; deepcopy不共享
            |非嵌套items -> 所有copy一开始都是共享,若主对象更改item,会在本容器新建item,从对象不变
            > import copy
            > t = ['abc', [123]]
            > t1=copy.copy(t)|t.copy()(if t is list|dict) #new obj, share nested
            > t2 = copy.deepcopy(t) #absolutely new obj
            > print(t1 == t) #True
            > print(t1 is t) #False
            > print(t1[1] is t[1])#True, share nested
            > print(t2[1] is t[1])#False, absolutely new obj
            > t3 = t #new ref, same obj
            > print(t3 == t) #True
            > print(t3 is t) #True

    |作用域 -> 某作用域的变量一旦'{被赋值}', 就是一个'{局部变量}'
        |引用传递 -> 可变类型作为函数参数时, 对其作原地修改, 修改的是变量指向的内存内容
            > def func(mylist):
            >     mylist = [1, 2, 3] #在函数中重新定义一个mylist, 覆盖掉参数变量mylist
            >     mylist[:] = [1, 2, 3] #原地修改, 变量内存地址不变, 没有重新定义变量
            >     mylist[0], mylist[1] = mylist[1], mylist[0] #原地修改

            |可变对象留存
                1.函数默认值
                    -> 字典,列表,time.time()作为函数默认值时,在函数定义时就已经在内存中生成
                    -> 可变对象作为函数参数默认值时若隐式访问foo()或l=[];foo(l),该对象会一直留在内存中; foo([])会覆盖默认值, 不会有默认值留存
                    > def foo(l=[]):
                    >     l.append(1) #原地操作 才会生成 “缓存”(append, extend, +=)
                    > [foo() for i in range(3)] -> l -> [1, 1, 1]
                    -> 正确做法
                    > def foo(l=None):
                    >     if l is None:
                    >         l = []

                    > def foo(t=time.time()): print(t) #一直是第一次的时间

                2.函数外声明可变对象, 函数内作原地操作(函数没有定义默认值)
                    > l = [] #[]可换成任意类型值
                    > def foo():
                    >     l.append(1) #l.extend([1])原地操作不报错; 赋值操作报错
                    >     logging.info(l)
                    > [foo() for i in range(3)] -> [1, 1, 1]
                    >>> 报错: "local variable 'l' referenced before assignment"

        |在当前作用域修改其他作用域变量 -> 在函数中直接引用全局变量或在嵌套函数中直接引用父级函数局部变量都没问题; 但是要修改的话需要分别加上'{global xxx | nonlocal xxx}', 否则报错. python2.x中不能用nonlocal

        -> 当函数/方法, 变量等发生重复命名时, python会按照以下顺序查找, 以第一个找到该变量的命名空间为准
            1.local namespace -> 当前函数或类方法
            2.local-parent namespace -> 父级函数或类方法
            3.global namespace -> 当前模块
            4.build-in namespace -> 所有模块

        |Closure -> 嵌套函数留存对父级函数作用域的变量引用,父级函数返回嵌套函数.装饰器就是闭包
            |nonlocal -> python3.x主要用于修改外层(父级)函数变量.不能在module level使用
            > def closure(): #c = closure(), c中会有一个闭包属性元组: __closure__
            >     num = 0
            >     def sub_closure():
            >         nonlocal num #指示变量不在当前函数作用域, 没有会报错
            >         num += 1
            >         print(num)
            >     return sub_closure

            |Decorator -> 装饰器(decorator)通过@func_name, 可以扩展现有函数功能(安全, 追踪, 锁定). 也可以装饰类
                -> 被装饰后的函数其实是另外一个函数(wrapper),__name__和docstring等属性会发生改变. functools.wraps能保持原函数属性

                > from functools import wraps
                > def decorator(func):
                >    @wraps(func)
                >    def wrapper(*args, **kvargs):
                >        # do something
                >        return func(*args, **kvargs)
                >    return wrapper

    |with -> 实现了一个上下文管理器, 保证了退出时会自动执行上下文管理器的__exit__释放资源

    > def func(*args, **kw): pass #*args为任意数目元素元组, **kw为任意内容字典
    > func(1, 2, 3, a='xxx', b='yyy', c='zzz') #args=(1, 2, 3), kw={'a':'xxx',...}

    |duck-typing -> 动态类型风格. 一个对象的有效语义, 不是由继承自特定的父类或实现特定的接口, 而是由'{当前方法和属性}'的集合决定. 使用对象时不关心其类型, 只关心其方法和属性
        |可以当作File用的类型 -> StringIO, GzipFile, Socket
        |Iterable -> list,str,tuple,dict,set,Iterator,generator都可以list.extend(*)

    |Lambda(匿名函数)
        lambda x=1: x ** n #参数x默认值为1
        lambda: 1 -> 1
        -> lambda的局限主要就是为了防止滥用.所以lambda'{只能写一行,不能赋值}',内部也不能定义等等
        -> lambda函数的限制,是故意这么做的.Python把函数的'{可读性}'看得重.如果一个没名字的函数太长了,容易让程序看起来混乱,不容易看懂

        |for循环延迟计算问题
            > l = [lambda: i for i in range(5)] #闭包
            > for l in l:
            >     print(l())
            >>> 4, 4, 4, 4, 4

            -> 正确做法

            > l = (lambda: i for i in range(5)) #生成器
            > for l in l:
            >     print(l())
            >>> 0, 1, 2, 3, 4

            > l = [lambda n=i: n for i in range(5)] #每次循环给匿名函数都加一个默认值
            > for l in l:
            >     print(l())
            >>> 0, 1, 2, 3, 4

    |Functional
        -> python2.x中map, filter返回'{list}'; python3.x中map, filter返回'{迭代器}'
        -> python2.x可直接使用reduce; python3.x中需from functools import reduce
            > from functools import reduce
            > num = reduce(lambda i, j: i + j, filter(lambda n: n < 0, data_list))

\Class
    -> 类是一个对象,在运行时由type()动态创建, 每个class都是type类的一个实例
    -> class的类型是type, 类实例的类型是类名(type(xxx))
    -> 创建一个类时, python会默认将该类所有'{属性}'收集到一个'{字典__dict__}'中
    -> self代表类的实例, 而非类

    |__slots__(类属性)
        -> 类属性默认用dict存储(内存: {} > [] > ()), __slots__是用'{list或元组}'存储属性名, 而不会再使用__dict__, __slots__里没有的属性, 类实例不能随便添加
        -> 优点: '{节省了内存}', 限制了属性添加
        -> 定义了__slots__后, slots中的变量就变成了类描述符
        -> 定义了__slots__后__dict__, __weakref__会消失. 如果还想在之后添加新变量或使用__weakref__, 则需要把'__dict__', '__weakref__'添加到__slots__中
        -> __slots__只影响本类, '{不影响父类和子类}'
        -> 在类的'{属性固定且经常生成大量实例}'的情况下适合使用__slots__
        > class Test(object):
        >     __slots__ = ['a', 'b', 'c'] | 'a', 'b', 'c'

    |多继承 -> 多继承链为'{mro序列}'
        > class D(A, B, C): pass
        -> '{经典类}'的继承链遍历是'{深度优先}'; '{新式类}'是广度优先, '{拓扑排序}'(从下到上, 按括号内父类顺序从左到右或从右到左)

    |类变量 -> 在类中不在self中的属性是类变量, 类的所有实例都能访问
        -> 修改'{类本身}'的类变量值后, 所有与该变量相关的子类和实例都受影响
        -> '{原地操作修改实例或子类}'中的类变量值后,所有与该变量相关的子类和实例都受影响
        -> '{非原地操作修改实例或子类}'中的类变量值后,只改变实例或子类本身,且不再受基类的影响

    |attr
        self.__class__ -> <class '__[module]__.ClassName'> #class of self
        self.__class__.__name__ -> 'ClassName' #class name
        self.__module__ #ModuleName
        self._abc #类的保护变量, 只允许类本身和子类访问, 'from...import...'不能访问
        self.__abc #类的私有变量, 只允许类本身访问
        self.__abc__ #类的特殊变量, 可以被外部直接访问
        self.__bases__ #'{直接父类对象}'的元组, 不包含更上层的父类对象
        self.__dict__ #类的所有属性, 方法字典
        self.__name__ #类名
        cls.__mro__ #继承链父类元组, 多继承按此元组元素次序解析

    |Wierd
        > class A(object):
        >     def foo(self): pass
        > a = A()
        > a.foo == a.foo #True
        > a.foo is a.foo #False
        > id(a.foo) == id(a.foo) #True

        > x, y = a.foo, a.foo
        > x == y #True
        > x is y #False
        > id(x) == id(y) #False

    |MetaClass -> metaclass的意义在于对'{类属性字典}'的统一抽象操作(数据库读写, orm框架)
        > class TestMetaClass(type):
        >     def __new__(cls, name, bases, attrs):pass
        >         # cls -> <class '__main__.TestMetaClass'>
        >         # name -> 'Test' #派生类类名
        >         # bases -> (<class 'dict'>,) #派生类的父类序列
        >         # attrs -> {'__init__': ..., '__doc__': '...',...} #派生类属性

        >     def __call__(cls, *args, **kw): #派生类实例化时执行, cls为派生类
        >         obj = cls.__new__(cls, *args, **kw)
        >         cls.__init__(obj, *args, **kw)
        >         <=>
        >         obj = super().__call__(*args, **kw) #type.__call__(*args, **kw)
        >         return obj

        > class Test(dict): #python2.x
        >     __metaclass__ = TestMetaClass

        > class Test(dict, metaclass=TestMetaClass): #python3.x

    |Descriptor -> 定义了__set__, __get__, __delete__方法的类, 用来拦截对实例字典的访问
        -> 只对新式类和实例有效, 因为__getattribute__是新式类特性
        |数据描述符 -> 定义了__set__, __delete__方法的描述符
        |非数据描述符 -> 只定义了__get__, 未定义__set__, __delete__方法的描述符
        |实例__dict__默认为{}
        |obj.bar <=> obj.__dict__['bar'], 访问obj.bar实例属性时不会直接访问实例字典, 而是先调用__getattribute__获取属性, 通过__setattribute__修改属性, 这两个方法的作用对象是obj.__dict__. 如果找不到属性, 则抛异常AttributeError; 如果定义了__getattr__, 则不会抛异常
        |子类定义的__getattribute__, __getattr__会覆盖父类. 父类定义子类未定义则调用父类
        |实例属性查找优先顺序(查找链最长)
            1.__getattribute__方法(无条件自动调用)
            2.实例__dict__
            3.类__dict__
            4.继承链父类__dict__
            5.__getattr__方法, 如果定义了该方法, 找不到属性的情况下调用该方法(未定义则报错)

        |描述符查找优先顺序
            1.__getattribute__方法(无条件自动调用, 若人为重载该方法会导致无法调用描述符)
            2.数据描述符(由__getattribute__触发, 调用desc.__get__())
            3.实例__dict__
            4.类__dict__
            5.非数据描述符
            6.继承链父类__dict__
            7.__getattr__方法, 如果定义了该方法, 找不到属性的情况下调用该方法(未定义则报错)

        |作用 -> 拦截对实例属性的访问(hook), 控制属性读写
            > class RevealAccess(object): #Descriptor
            >     def __init__(self, initval=None, name='var'):
            >         self.val = initval
            >         self.name = name
            >     def __get__(self, obj, objtype):
            >         print "Retrieving val"
            >         return self.val
            >     def __set__(self, obj, value):
            >         print "Updating val"
            >         self.val = value
            >     def __delete__(self):
            >         print "Deleting val"
            >         del self.val
            > class MyClass(object):
            >     x = RevealAccess(10, 'var "x"')
            > c = MyClass(); c.x; c.x = 20

        |实际应用 -> 实例方法, 静态方法, 类方法, super, property

    |New-style class(新型类) -> class C:(Classic) | class C(object):(New-style)
        -> new-style classes是python在2.2版本开始加入的一个重要特性。所有的内建类型都是new-style classes。所有新型类都可以使用type
        -> '{object}'和所有直接或间接以它为'{基类}'的类是new-style classes
        -> python2.x新式类需显式继承object, python3.x默认为新式类, 不需要显式继承object
        -> 在经典类中，任意instance的type都是'instance'。所以不能用type判断类型
        -> 引入new-style classes，就是为了逐步弥合python中内建类型和classic classes之间的鸿沟。至此，内建类型终于可以和classic classes一样，在定义类时作为基类被继承
        -> 新型类的元类是type; 经典类的元类是types.ClassType
        -> 新型类新增了许多特性: 特殊方法, descriptor, classmethod, staticmethod, property, super

        |特殊方法(除了'{经典类}'的__doc__, __module__外其余都属于'{新式类}'新增属性)
            > def __call__(self, *args, **kw): pass #for instance(args), 实例方法
            > def __new__(cls, *args, **kw): pass #before __init__, 静态方法
            |__new__ -> __init__用来控制类的实例的初始化，而__new__控制初始化之前的行为(也就是实例的生成). __new__的第一个参数是类(cls)，而不是self, (普通类)每次传入的cls都是同一个对象. __new__的作用是拦截实例初始化过程(hook), 返回一个cls实例, 这个实例就是__init__方法接收的默认参数self
            -> 派生类__new__在类实例化时运行, 除cls外参数默认为空; 元类__new__在元类定义时运行, 除cls外参数默认不为空(每个派生类都会执行一遍元类__new__, 本质是元类实例化为派生类, 派生类为元类实例)
            -> __init__(self)只能返回None, 否则报错; 若__new__返回值类型与父类不同或没有返回值或返回None,则__init__不会被调用(没有创建实例对象, init也没有意义)
            -> 元类__call__首参数为派生类(派生类为元类实例), 派生类__call__首参数为类实例
            -> 元类调用type.__call__等价于调用派生类的__new__加__init__.元类定义了__call__则优先执行元类__call__, 派生类__new__和__init__只能在元类__call__中调用, 否则不会执行; 元类未定义__call__则优先执行派生类__new__
            -> __call__ <=> callable(obj)
            > class Test(object): pass <=> type.__new__ + type.__init__
            > t = Test() <=> type.__call__ <=> Test.__new__ + Test.__init__
            -> 实例值(self)获取顺序依次是:
                1.元类__call__返回值
                2.元类__call__未定义则为派生类__new__返回值
                3.派生类__new__未定义则为父类默认值(dict:{}, int:0, str:'')
                4.父类为object或为空则为<__main__.Test object at 0x0000014D41B53630>

        |classmethod -> 添加了@classmethod的函数的第一个参数总是该函数所在类的类名
        |staticmethod -> 使用了静态方法@staticmethod，则不能再使用self

        |property -> 为了使对类属性的操作可控, 可以检查参数
            -> 添加了@property的函数可以添加@attr_name.setter方法以设置属性值,没添加setter方法的@property函数为只读属性,只有getter方法(@property)
            > @property #getter
            > def value(self):
            >     return self._value

            > @value.setter #setter
            > def value(self, val):
            >     self._value = val

            |内建函数property -> 对类属性的读写控制
                > class MyClass(object):
                >     def __init__(self):
                >         self.__x = 1
                >     def getx(self):
                >         print "Retrieving x"
                >         return self.__x
                >     def setx(self, value):
                >         print "Updating x"
                >         self.__x = value
                >     def delx(self):
                >         print "Deleting x"
                >         del self.__x
                >     x = property(getx, setx, delx, "I'm the x property")
                > c = MyClass(); c.x; c.x = 20; del c.x

        |super -> 继承链父类对象(cls.__mro__)
            -> super(Class,self).xxx(python2.x)<=>super().xxx(python3.x)
            -> 根据MRO序列保证继承链上的每个父类方法只调用一次
            >  super().__new__(cls, *args, **kw)
            >  super().__init__(*args, **kw)
            >  super().__call__(*args, **kw)

\DataBase
    conn_str = %(dbn)s://%(user)s:%(pw)s@%(host)s:%(port)s/%(db)s #数据库连接字符串
    -> 数据库对象db未设置autocimmit=True的话, 增删改操作必须有db.commit()

\File
    open('new.txt', '[w|a][+|b[+]]') #创建一个新文件
    |read -> 读取整个文件
    |readline -> 读取下一行, 使用生成器方法
    |readlines -> 读取整个文件到一个迭代器以供我们遍历
    |'xt'-> 写文件, 如果该文件已经存在,则不写

\Error
    -> except后跟异常列表, 用来捕获try中的异常
    -> python2.x中e可以在except模块外部被访问, python3.x不可以
    > except [Exception [, e | as e]]: #捕获所有异常
    > except (SystemError,...) [as e]: #python2.x, python3.x
    > except SystemError, IndexError: #python2.x
        <=> except SystemError as IndexError #只捕获SystemError
    > except (SystemError,...)[, e | as e]: #python2.x 捕获异常列表
    > raise XXXError(msg) #主动触发异常
    > import traceback; traceback.print_exc() #打印详细异常信息
        format_exc() #返回字符串
        print_exc() #直接打印或写入文件traceback.print_exc(file=open('tb.txt','w+'))

    |用户自定义异常
    > class NetworkError(Exception):
    >     def __init__(self, arg):
    >         self.args = arg
