-> 模板引擎Jinja2和Mako的使用

\上下文设计
    -> Flask提供了两种上下文，一种是应用'{上下文(Application Context)}'，一种是'{请求上下文(Request Context)}'
    -> application指的就是当你调用app = Flask(name)创建的这个对象app
    -> request指的是每次http请求发生时，WSGI server(比如gunicorn)调Flask.call()之后，在Flask对象内部创建的Request对象
    -> application表示用于响应WSGI请求的应用本身，request表示每次http请求
    -> application的生命周期大于request，一个application存活期间，可能发生多次http请求，所以，也就会有多个request
    -> Flask通过'{_RequestContext}'将App与Request关联起来

    |上下文钩子(decorator)
        |请求hook
        1.@before_first_request -> 注册一个在处理第一个请求之前运行的函数
        2.@before_request -> 注册一个在处理请求之前运行的函数
        3.@after_request -> 注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行
        4.@teardown_request -> 注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行

-> 利用'{信号机制}'可以实现一部分的业务解耦
|常用扩展 -> Flask-SQLAlchemy、Flask-Script、Flask-DebugToolbar、Flask-Migrate、Flask-WTF、Flask-Security、Flask-RESTful、Flask-Admin和Flask-Asset
-> 依赖库Werkzeug的使用
-> RESTful API

|SQLAlchemy
    -> python操作数据库的一个库.能够进行orm映射.采用简单的Python语言,为高效和高性能的数据库访问设计,实现了完整的企业级持久模型.SQLAlchemy的理念是,SQL数据库的量级和性能重要于对象集合,而对象集合的抽象又重要于表和行

-> Celery
