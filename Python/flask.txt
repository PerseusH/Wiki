import flask; flask.__version__ #查看版本

-> 模板引擎Jinja2和Mako的使用

\上下文设计
    |Flask两种上下文
        |应用上下文(Application Context) -> 字面意思是应用上下文，但它不是一直存在的，它只是request context中的一个对app的代理，所谓local proxy。它的作用主要是帮助request获取当前的应用，它是伴request而生，随request而灭的
        |请求上下文(Request Context) ->

    |Thread local context
        -> 全局对象，你可以往里面保存东西，a线程保存到local对象的，只有a线程能取到，b线程的只有b线程能取到，如果，a，b保存了名字相同的东西，比如x，a取到的值是自己保存的，不会和b保存的混淆，修改操作也一样。 request，session，g都是用相同的原理实现的，都是保存在local对象里的线程（包括greenlet协程）安全的变量。 flask自己实现了local对象而不是使用标准库的threading.Local对象

        |LocalStack -> 线程有个叫做ThreadLocal的类，也就是实现'{线程隔离}'的类。werkzeug自己实现了线程隔离类：werkzeug.local.Local。LocalStack就是用Local实现的
            -> flask.globals模块中定义了两个LocalStack用来存储各上下文对象
                _request_ctx_stack = LocalStack() | _request_ctx_stack.top #栈顶
                _app_ctx_stack = LocalStack() | _app_ctx_stack.top #栈顶
            -> LocalStack是flask定义的线程隔离的栈存储对象，分别用来存储应用和请求上下文。这是根据pid的不同实现的，类似于门牌号
            -> Flask是一个基于WerkZeug实现的框架，因此Flask的App Context和Request Context是基于WerkZeug的Local Stack的实现。这两种上下文对象类定义在flask.ctx中，ctx.push会将当前的上下文对象压栈压入flask._request_ctx_stack中，这个_request_ctx_stack同样也是个Thread Local对象，也就是在每个线程中都不一样，上下文压入栈后，再次请求的时候都是通过_request_ctx_stack.top在栈的顶端取，所取到的永远是属于自己线程的对象，这样不同线程之间的上下文就做到了隔离。请求结束后，线程退出，ThreadLocal本地变量也随即销毁，然后调用ctx.pop()弹出上下文对象并回收内存
            -> 每个传给flask对象的请求，都是在不同的线程中处理，而且同一时刻每个线程只处理一个请求. 因此g、session、request、current_app能做到同一个对象在所有请求中使用并且不会冲突.这几个对象还是定义在flask.globals中
                current_app = LocalProxy(_find_app)
                request = LocalProxy(partial(_lookup_req_object, 'request'))
                session = LocalProxy(partial(_lookup_req_object, 'session'))
                g = LocalProxy(partial(_lookup_app_object, 'g'))

                def _lookup_req_object(name):
                    top = _request_ctx_stack.top
                    if top is None:
                        raise RuntimeError('working outside of request context')
                    return getattr(top, name)

                def _lookup_app_object(name):
                    top = _app_ctx_stack.top
                    if top is None:
                        raise RuntimeError('working outside of application context')
                    return getattr(top, name)

                def _find_app():
                    top = _app_ctx_stack.top
                    if top is None:
                        raise RuntimeError('working outside of application context')
                    return top.app
                -> 可以看出，Flask中使用的一些“全局变量”，包括current_app、request、session、g等都来自于上下文对象。其中current_app一直指向_app_ctx_stack栈顶的“应用上下文”对象，是对当前应用的引用。而request、session、g等一直指向_request_ctx_stack栈顶的“请求上下文”对象，分别引用请求上下文的request、session和g。不过，从 Flask 0.10 起，对象 g 存储在应用上下文中而不再是请求上下文中
            -> 对g的调用就是这样一个过程，可以线程隔离的访问自己的g
                访问g-->从当前线程的应用上下文栈顶获取应用上下文-->取出其中的g对象-->进行操作

    -> application指的就是当你调用app = Flask(name)创建的这个对象app
    -> application表示用于响应WSGI请求的应用本身，request表示每次http请求
    -> request指的是每次http请求发生时，WSGI server(比如gunicorn)调Flask.call()之后，在Flask对象内部创建的Request对象
    -> application的生命周期大于request，一个application存活期间，可能发生多次http请求，所以，也就会有多个request
    -> Flask通过'{_RequestContext}'将App与Request关联起来

    -> 钩子用于改变行为（比如身份验证或错误处理）,信号用于记录事件（比如记录日志）

    |上下文钩子
        |请求hook
            1.@before_first_request -> 注册一个在处理第一个请求之前运行的函数
            2.@before_request -> 注册一个在处理请求之前运行的函数
            3.@after_request -> 注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行
            4.@teardown_request -> 注册一个函数,即使有未处理的异常抛出,也在每次请求之后运行

    |信号机制 -> 允许特定的发送端通知订阅者发生了什么(既然知道发生了什么,那我们可以知道接下来该做什么了),可以实现一部分的业务解耦.信号依赖于Blinker库

\全局变量
    |current_app -> 代表当前的flask程序实例,使用时需要flask的程序上下文激活
        from test import app
        from flask import current_app
        #current_app.name #应用上下文未激活，会报错
        ctx=app.app_context()
        ctx.push() #激活应用上下文

        @app.route('/')
        def index():
            return 'Hello, %s!' % current_app.name #正常运行

    |g -> 作为flask程序全局的一个临时变量,充当者中间媒介的作用,可以通过它传递一些数据
        -> 在'{请求钩子函数和视图函数之间共享数据}'一般使用上下文全局变量g。如before_request程序从数据库中加载已登录用户并保存到g.user中。随后在视图函数中使用g.user获取
        -> flask从0.10开始g是和app绑定在一起的，g是AppContext的一个成员变量。虽然说g是和app绑定在一起的，但不同请求的AppContext是不同的，所以g还是不同。也就是说你不能在一个视图中设置g.name，然后在另一个视图中使用g.name，否则会提示AttributeError
        -> g保存的是'{当前请求}'的全局变量，不同的请求会有不同的全局变量，通过thread id区别
        g.name='Hyman' | logging.info(g.name)

    |request -> 请求对象,封装了客户端发送的HTTP请求的内容

    |session -> 字典类型用户会话,记录各请求间的值。属私有存储，保存在cookie中
        @app.route('/', methods=['GET','POST'])
        def index():
            form = NameForm()
            if form.validate_on_submit():
                session['name']=form.name.data
                return redirect(url_for('index'))
            return render_template('xxx.html',form=form,name=session.get('name'))

\Route


|常用扩展 -> Flask-SQLAlchemy、Flask-Script、Flask-DebugToolbar、Flask-Migrate、Flask-WTF、Flask-Security、Flask-RESTful、Flask-Admin和Flask-Asset
-> 依赖库Werkzeug的使用

|SQLAlchemy
    -> python操作数据库的一个库.能够进行orm映射.采用简单的Python语言,为高效和高性能的数据库访问设计,实现了完整的企业级持久模型.SQLAlchemy的理念是,SQL数据库的量级和性能重要于对象集合,而对象集合的抽象又重要于表和行

-> Celery
