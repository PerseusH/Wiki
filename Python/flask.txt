import flask; flask.__version__ #查看版本

-> 模板引擎Jinja2和Mako的使用

\上下文设计
    |Flask两种上下文
        |应用上下文(Application Context) -> 字面意思是应用上下文，但它不是一直存在的，它只是request context中的一个对app的代理，所谓local proxy。它的作用主要是帮助request获取当前的应用，它是伴request而生，随request而灭的
        |请求上下文(Request Context) ->

    |Thread local context
        -> 全局对象，你可以往里面保存东西，a线程保存到local对象的，只有a线程能取到，b线程的只有b线程能取到，如果，a，b保存了名字相同的东西，比如x，a取到的值是自己保存的，不会和b保存的混淆，修改操作也一样。 request，session，g都是用相同的原理实现的，都是保存在local对象里的线程（包括greenlet协程）安全的变量。 flask自己实现了local对象而不是使用标准库的threading.Local对象

        |LocalStack -> 线程有个叫做ThreadLocal的类，也就是实现'{线程隔离}'的类。werkzeug自己实现了线程隔离类：werkzeug.local.Local。LocalStack就是用Local实现的
            -> flask.globals模块中定义了两个LocalStack用来存储各上下文对象
                _request_ctx_stack = LocalStack() | _request_ctx_stack.top #栈顶
                _app_ctx_stack = LocalStack() | _app_ctx_stack.top #栈顶
            -> LocalStack是flask定义的线程隔离的栈存储对象，分别用来存储应用和请求上下文。这是根据pid的不同实现的，类似于门牌号
            -> Flask是一个基于WerkZeug实现的框架，因此Flask的App Context和Request Context是基于WerkZeug的Local Stack的实现。这两种上下文对象类定义在flask.ctx中，ctx.push会将当前的上下文对象压栈压入flask._request_ctx_stack中，这个_request_ctx_stack同样也是个Thread Local对象，也就是在每个线程中都不一样，上下文压入栈后，再次请求的时候都是通过_request_ctx_stack.top在栈的顶端取，所取到的永远是属于自己线程的对象，这样不同线程之间的上下文就做到了隔离。请求结束后，线程退出，ThreadLocal本地变量也随即销毁，然后调用ctx.pop()弹出上下文对象并回收内存
            -> 每个传给flask对象的请求，都是在不同的线程中处理，而且同一时刻每个线程只处理一个请求. 因此g、session、request、current_app能做到同一个对象在所有请求中使用并且不会冲突.这几个对象还是定义在flask.globals中
                current_app = LocalProxy(_find_app)
                request = LocalProxy(partial(_lookup_req_object, 'request'))
                session = LocalProxy(partial(_lookup_req_object, 'session'))
                g = LocalProxy(partial(_lookup_app_object, 'g'))

                def _lookup_req_object(name):
                    top = _request_ctx_stack.top
                    if top is None:
                        raise RuntimeError('working outside of request context')
                    return getattr(top, name)

                def _lookup_app_object(name):
                    top = _app_ctx_stack.top
                    if top is None:
                        raise RuntimeError('working outside of application context')
                    return getattr(top, name)

                def _find_app():
                    top = _app_ctx_stack.top
                    if top is None:
                        raise RuntimeError('working outside of application context')
                    return top.app
                -> 可以看出，Flask中使用的一些“全局变量”，包括current_app、request、session、g等都来自于上下文对象。其中current_app一直指向_app_ctx_stack栈顶的“应用上下文”对象，是对当前应用的引用。而request、session、g等一直指向_request_ctx_stack栈顶的“请求上下文”对象，分别引用请求上下文的request、session和g。从Flask0.10 起，对象 g 存储在应用上下文中而不再是请求上下文中
            -> 对g的调用就是这样一个过程，可以线程隔离的访问自己的g
                访问g-->从当前线程的应用上下文栈顶获取应用上下文-->取出其中的g对象-->进行操作

    -> application指的就是当你调用app = Flask(name)创建的这个对象app
    -> application表示用于响应WSGI请求的应用本身，request表示每次http请求
    -> request指的是每次http请求发生时，WSGI server(比如gunicorn)调Flask.call()之后，在Flask对象内部创建的Request对象
    -> application的生命周期大于request，一个application存活期间，可能发生多次http请求，所以，也就会有多个request
    -> Flask通过'{_RequestContext}'将App与Request关联起来

    -> 钩子用于改变行为（比如身份验证或错误处理）,信号用于记录事件（比如记录日志）

    |上下文钩子
        |请求hook
            1.@before_first_request -> 注册一个在处理第一个请求之前运行的函数
            2.@before_request -> 注册一个在处理请求之前运行的函数
            3.@after_request -> 注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行
            4.@teardown_request -> 注册一个函数,即使有未处理的异常抛出,也在每次请求之后运行

    |信号机制 -> 允许特定的发送端通知订阅者发生了什么(既然知道发生了什么,那我们可以知道接下来该做什么了),可以实现一部分的业务解耦.信号依赖于Blinker库

\全局对象
    -> Flask 在分发请求之前激活（push）程序和请求上下文，请求处理完成后再将其删除。程序/请求上下文被推送后，就可使用全局对象

    |current_app -> 代表当前的flask程序实例
        from test import app
        from flask import current_app
        #current_app.name #应用上下文未激活，会报错
        ctx=app.app_context()
        ctx.push() #激活应用上下文

        @app.route('/')
        def index():
            return 'Hello, %s!' % current_app.name #正常运行

    |g -> 作为flask程序全局的一个临时变量,充当者中间媒介的作用,可以通过它传递一些数据
        -> 在'{请求钩子函数和视图函数之间共享数据}'一般使用上下文全局变量g。如before_request程序从数据库中加载已登录用户并保存到g.user中。随后在视图函数中使用g.user获取
        -> flask从0.10开始g是和app绑定在一起的，g是AppContext的一个成员变量。虽然说g是和app绑定在一起的，但不同请求的AppContext是不同的，所以g还是不同。也就是说你不能在一个视图中设置g.name，然后在另一个视图中使用g.name，否则会提示AttributeError
        -> g保存的是'{当前请求}'的全局变量，不同的请求会有不同的全局变量，通过thread id区别
        g.name='Hyman' | logging.info(g.name)

    |request -> 请求对象,封装了客户端发送的HTTP请求的内容

    |session -> 字典类型用户会话,记录各请求间的值。属私有存储，保存在cookie中
        @app.route('/', methods=['GET','POST'])
        def index():
            form = NameForm()
            if form.validate_on_submit():
                session['name']=form.name.data
                return redirect(url_for('index'))
            return render_template('xxx.html',form=form,name=session.get('name'))

\Route
    Werkzeug中间件 -> endpoint-view mapping 自由绑定url和视图函数. 自动根据复杂度为路由排序

    |核心代码
        self.url_map.add(rule)
        rule = self.url_rule_class(rule, methods=methods, **options)
        self.view_functions[endpoint] = view_func

    |应用方式
        1.装饰器
            def route(self, rule, **options):
                def decorator(f):
                    endpoint = options.pop('endpoint', None)
                    self.add_url_rule(rule, endpoint, f, **options)
                    return f
                return decorator

            @app.route('/xxx')
            def view(): pass
        2.视图类
            class CounterAPI(MethodView):
                def get(self):
                    return session.get('counter', 0)
                def post(self):
                    session['counter'] = session.get('counter', 0) + 1
                    return 'OK'
            app.add_url_rule('/counter', view_func=CounterAPI.as_view('counter'))

\WSGI
    -> Web Server Gateway Interface是服务器和web框架或web应用之间建立的一种通用接口规范
    -> WSGI不是服务器，不是API，不是模块，更不是框架，而是一种服务器和客户端交互的'{接口规范}'
    -> WSGI接口规范的目的就是规范Web服务器与Web应用之间的交互，在协议之间进行转换
    -> 主要由三大部分组成WSGI SERVER、WSGI Middleware 、WSGI Application
        |server -> 接收来自客户端的request请求，封装environ环境变量，给app提供回调函数；调用app,并将environ和回调函数一起传递给app；最后接收来自app的header/status/body响应信息，传给客户端
        |Middleware -> 是Server和app之间的桥梁，中间件同时扮演两种角色，在服务端看来，中间是app能够被调用，在应用程序看来，它是服务端，能够进一步包装需要出来的信息，并将出来的信息传递调用app
            -> 如服务器拿到了请求的URL, 不同URL需要交由不同函数处理，这个功能叫URLRouting
        |app -> 是开发程序的主体，必须可调用，必须能够接受服务端传过来的两个参数environ和callback函数。将传入进来的参数，进一步出来生成response响应信息，传回服务器端

    |Server
        def run(application):
            # 准备 environ 参数，这是一个字典，里面的内容是一次 HTTP 请求的环境变量
            environ={}                                   #设定环境信息
            environ = dict(os.environ.items())
            environ['wsgi.input']        = sys.stdin
            environ['wsgi.errors']       = sys.stderr
            environ['wsgi.version']      = (1, 0)
            environ['wsgi.multithread']  = False
            environ['wsgi.multiprocess'] = True
            environ['wsgi.run_once']     = True
            environ['wsgi.url_scheme'] = 'http'

            def start_response(status,headers):          #define callback function
                pass

            result=application(environ,start_response)   #call application

            def write(data):                             #把应答的结果输出到终端
                sys.stdout.write(data)
                sys.stdout.flush()

            for data in result:                          #访问result iterator
                write(data)
        -> run是服务端程序，调用可调用应用程序application。定义一个start_response函数传递给application,作为回调函数。run调用application后，返回一个iterator 迭代对象，将其赋值给result。write()函数在start_response将响应头信息发送后，发送响应body信息

    |Middleware -> 处于服务器和应用两侧，起粘合作用，具体包括：请求处理、environ处理
        def dispatch(url_app_mapping):
            def midware_app(environ,start_response):      #callable function
                url=environ['PATH_INFO']
                app=url_app_mapping[url]                 #get the view function
                result=app(environ, start_response)      #call app
                return result
            return midware_app

        class dispatch():
            def __init__(self,application):              #调用合适的app
                self.app=application
            def __call__(self,environ,start_response):
                #do sometiong
                return self.app(environ,start_response)  #自身可调用
        -> middleware既是服务端又是应用端。那么就应满足 服务端条件：能够配置environ,具有start_response并将其传递给应用程序调用应用程序；应用端条件：可调用，接收两个参数，返回迭代对象

    |Application -> '{可被调用}'的对象，一般指包含__call__方法(实例可以当作函数调用)的对象
        def application(environ,start_response):         #可调用接收两个参数
            status='200 ok'
            headers=[('Content-type','text/plain')]      #设置响应状态码和响应信息
            start_response(status,headers)               #调用回调函数
            return ["hello world"]                       #返回body 可迭代对象
        -> 一个简易的app应用程序，注意返回的body要是一个可迭代对象

|常用扩展 -> Flask-SQLAlchemy、Flask-Script、Flask-DebugToolbar、Flask-Migrate、Flask-WTF、Flask-Security、Flask-RESTful、Flask-Admin和Flask-Asset
-> 依赖库Werkzeug的使用

|SQLAlchemy
    -> python操作数据库的一个库.能够进行orm映射.采用简单的Python语言,为高效和高性能的数据库访问设计,实现了完整的企业级持久模型.SQLAlchemy的理念是,SQL数据库的量级和性能重要于对象集合,而对象集合的抽象又重要于表和行
