\python
    python manage.py runserver 0.0.0.0:8000 # 启动一个web项目 | manage.py: 项目启动文件

    # deployment
    使用 Debian 基于包的部署是部署 Python 应用的一个极佳方案, 最重要的是它可以平稳而快速的迁移代码

    ＃ 包:
    package是模块的集合, 当解释器发现目录下有__init__.py时, 它就会认为这个目录是一个Package

    # 发布
        python的很多库, 内部其实是C语言的, 使用easy_install/pip安装的时候, 往往是下载源码然后本机编译的. 如果打包了, 可能会出现一些莫名奇妙的问题, 比如 32.64位的兼容问题, 不同的操作系统的路径查找问题等等. 正确的方式就是在setup.py文件中写明依赖的库和版本, 然后到目标机器上安装, 反正就一句python setup.py install, 不算复杂.

        python setup.py bdist_egg # 将python代码打包成egg文件, 类似Java的jar
        python setup.py install # 在服务器或VirtualEnv上安装,  完成部署

        pip freeze > requirements.txt # 生成requirements.txt(包含本地Python库所有依赖包及其精确的版本号)
        pip install -r requirements.txt # 在服务器或VirtualEnv上从requirements.txt安装依赖

        vitualenv新建环境里根目录在bin/activate文件中配置:
            VIRTUAL_ENV="/Users/username/env_x" => VIRTUAL_ENV=`pwd`
            这样就把静态根目录改成了动态获取, 就能把虚拟环境打包部署到其他机器
            创建虚拟环境时加--no-site-packages, 就不会用主系统python里的库, 环境自带lib/site-packages

        假如你的项目需要保存为系统模块, 或者可安装为系统命令的 setup.py 就必不可少了
        假如你的项目是可以直接运行的, 那么 requirements.txt 也是必不可少.
        如果你两种功能都需要, 那么就两个文件都不能少.

\pytest
    python测试框架
    python -m pytest -v # 自动查找'test_'开头的function, module, file, 'Test'开头的class

\pyenv
    source .pyenvrc && pyenv local 3.6.3 ＃ python版本切换
    ~/.pyenv/versions/3.6.3/lib/python3.6/site-packages

\travis-ci
    travis-ci.org => settings, 连接github
    ssh-keygen -t rsa ＃ 生成密钥~/.ssh/id_rsa, ~/.ssh/id_rsa.pub
    将id_rsa.pub内容copy到github的repo => settings => deploy keys
    cd myproject
    travis encrypt-file ~/.ssh/id_rsa --add # 加密, 生成id_rsa.enc
    add .travis.yml配置文件, 修改id_rsa.enc路径
    git push [.travis.yml, id_rsa.enc] to github
    git push, travis开始build, 结果联动到github

\fabric
    远程部署工具, run(shell cmd), 将程序包同时分发到多个hosts

\gunicorn # 默认长连接
    gunicorn是一个高效的 Python WSGI Server, 我们通常用它来运行 WSGI(Web Server Gateway Interface, Web 服务器网关接口)应用
    gunicorn mypy.wsgi:application -b 127.0.0.1[:8000] --reload # 启动Django
    gunicorn -w 3 -b 127.0.0.1:5000 start-file-name:app -k gevent # 启动Flask

\Nginx
    Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件(IMAP/POP3)代理服务器, 并在一个BSD-like 协议下发行. 其特点是占有内存少, 并发能力强, 事实上nginx的并发能力确实在同类型的网页服务器中表现较好

    location / {
        #设置主机头和客户端真实地址,以便服务器获取客户端真实IP
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        #禁用缓存???
        proxy_buffering off;

        #禁用缓存
        add_header Cache-Control no-store;

        #反向代理的地址
        proxy_pass ip | http://xxx.xxx;
    }

    功能:
        反向代理:
            通过接收Internet上的连接请求, 将请求转发给内网中(nginx.conf)的目标服务器, 再将从目标服务器得到的结果返回给Internet上请求连接的客户端(比如浏览器）
        静态缓存:
            将指定类型的静态文件缓存到浏览器端
        负载均衡:
            nginx的upstream默认是以轮询的方式实现负载均衡,这种方式中,每个请求按时间顺序逐一分配到不同的后端服务器,如果后端服务器down掉,能自动剔除。
                upstream test.com {
                    server 192.168.232.132:80;
                    server 192.168.232.133:80;
                }
            另外一种方式是ip_hash -> 每个请求按访问ip的hash结果分配,这样每个访客固定访问一个服务器,可以解决session的问题
                upstream test.com {
                     ip_hash;
                     server 192.168.1.251;
                     server 192.168.1.252;
                     server 192.168.1.247;
                 }
                 当后端服务器宕机后,session会丢失；
                 来自同一局域网的客户端会被转发到同一个后端服务器,可能导致负载失衡；
                 不适用于CDN网络,不适用于前段还有代理的情况

    /usr/local/bin/nginx # 主文件(非目录)
    /usr/local/etc/nginx ＃ 安装目录(含配置文件nginx.conf)
    /usr/local/cellar
    /usr/local/var/log/nginx/ # access.log, error.log etc.

    sudo /usr/local/bin/nginx # 启动
    ps -ef | grep nginx, sudo kill --QUIT[--TERM] [PID] # 关闭
    sudo /usr/local/bin/nginx -s reload # 重启

    Django的部署可以有很多方式,采用nginx+uwsgi的方式是其中比较常见的一种方式
    在这种方式中,我们的通常做法是,将nginx作为服务器最前端,它将接收WEB的所有请求,统一管理请求
    nginx把所有静态请求自己来处理(这是NGINX的强项).然后,NGINX将所有非静态请求通过uwsgi传递给Django,由Django来进行处理,从而完成一次WEB请求
    可见,uwsgi的作用就类似一个桥接器.起到桥梁的作用

\supervisor
    supervisor是一个进程管理工具,可以很方便地启动、关闭和重启进程等
    /usr/local/etc/supervisord.ini # 配置文件

    # 启动／关闭supervisor
    brew services start supervisord
    brew services stop supervisord
    brew services restart supervisord

    # 添加进程模块(在supervisord.ini中添加或者在/usr/local/etc/supervisor.d/目录下添加myapp.ini)
        [program:myapp]
        directory = path
        command = linux_cmd

\HTTP CODE
    300 Multiple Choices
      客户请求的文档可以在多个位置找到,这些位置已经在返回的文档内列出。如果服务器要提出优先选择,则应该在Location应答头指明。
    301 Moved Permanently
      客户请求的文档在其他地方,新的URL在Location头中给出,浏览器应该自动地访问新的URL。
    302 Found
      类似于301,但新的URL应该被视为临时性的替代,而不是永久性的。
    303 See Other
      类似于301/302,不同之处在于,如果原来的请求是POST,Location头指定的重定向目标文档应该通过GET提取
    304 Not Modified
      客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户,原来缓冲的文档还可以继续使用。
    305 Use Proxy
      客户请求的文档应该通过Location头所指明的代理服务器提取
    307 Temporary Redirect
      和302（Found）相同。许多浏览器会错误地响应302应答进行重定向,即使原来的请求是 POST,即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因,HTTP 1.1新增了307,以便更加清除地区分几个状态代码 ->  当出现303应答时,浏览器可以跟随重定向的GET和POST请求；如果是307应答,则浏览器只能跟随对GET请求的重定向。

\UWSGI:
    uwsgi是一个快速的.纯C语言开发的.自维护.对开发者友好的WSGI服务器, 旨在提供专业的Python Web应用和发布功能(源码安装或pip安装).

    uwsgi --ini HelloWorld/hw_uwsgi.ini # 使用uwsgi启动监听服务
    uwsgi --http :8001 --wsgi-file test.py # 使用uwsgi启动web服务

    # 使用uwsgi启动项目:
        uwsgi --http :8001 --chdir ~/HelloWorld --wsgi-file mypy/wsgi.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191

\vim
    ~/.vimrc # 配置文件
    F2 -> i -> ctl+v # 外部文本完美粘贴
    shift+a, 就是A, 即可直接到真正的行尾添加内容

    # 多行注释 ->
        1.进入命令行模式, 按ctrl+v进入 visual block模式, 然后按j, 或者k选中多行, 把需要注释的行标记起来
        2.按大写字母I, 再插入注释符, 例如#
        3.按esc键就会全部注释了

    # 取消多行注释 ->
        1.进入命令行模式, 按ctrl+v进入 visual block模式, 按字母l横向选中列的个数, 例如#需要选中2列
        2.按字母j, 或者k选中注释符号
        3.按d键就可全部取消注释

    :wq 保存并退出
    ZZ 保存并退出
    :q 如果是最后一个被关闭的窗口, 那么将退出vim
    :q! 强制退出并忽略所有更改
    :e! 放弃所有修改, 并打开原来文件

\Mac CMD
    Finder->Go: /etc/hosts # hosts
    opt+cmd+i: es6 console

\Terminal CMD
    1.将光标移动到行首 -> ctrl + a
    2.将光标移动到行尾 -> ctrl + e
    3.清除屏幕 ->        ctrl + l
    4.搜索以前使用命令 -> ctrl + r
    5.清除当前行 ->      ctrl + u
    6.清除至当前行尾 ->   ctrl + k
    7.单词为单位移动 ->   option + 方向键

\shell脚本
    参数: 命令行输入, 以空格分割
    $0  ->  ./test.sh,即命令本身, 相当于c/c++中的argv[0]
    $1  ->  -f,第一个参数.
    $2  ->  config.conf
    $3, $4 ...  -> 类推。
    $#  参数的个数, 不包括命令本身, 上例中$#为4.
    $@  -> 参数本身的列表, 也不包括命令本身, 如上例为 -f config.conf -v --prefix=/home
    $*  -> 和$@相同, 但"$*" 和 "$@"(加引号)并不同, "$*"将所有的参数解释成一个字符串, 而"$@"是一个参数数组。

\Jenkins 是一个可扩展的持续集成引擎。
    主要用于 ->
        持续、自动地构建/测试软件项目。
        监控一些定时执行的任务。

    特性包括 ->
        易于安装-只要把jenkins.war部署到servlet容器, 不需要数据库支持。
        易于配置-所有配置都是通过其提供的web界面实现。
        集成RSS/E-mail通过RSS发布构建结果或当构建完成时通过e-mail通知。
        生成JUnit/TestNG测试报告。
        分布式构建支持Jenkins能够让多台计算机一起构建/测试。
        文件识别:Jenkins能够跟踪哪次构建生成哪些jar, 哪次构建使用哪个版本的jar等。
        插件支持:支持扩展插件, 你可以开发适合自己团队使用的工具。

    c1c72cb093864f19b9ff83306d4ef135 # admin-pwd
    $Jenkins_home: ~/.jenkins
    java -jar jenkins.war --httpPort=8888 # 启动
    /Library/Application Support/Jenkins/Uninstall.command # 删除
    restart或者安全重启: safe-restart # 重启
    safe-shutdown # 停止

\Docker
    user: perseush | pwd:  hui_123
    /usr/local/bin/docker # docker地址
    /Library/Containers/com.docker.docker/Data # 镜像地址

    docker build -t runoob/ubuntu:v1 . # 使用当前目录的Dockerfile创建镜像
    docker run image_name[:tag] # 根据镜像启动一个Container
    docker ps -a # 查看所有Containers
    Docker Daemon # docker 的守护进程
    # 重启一个Exited Container:
        docker start con_name | ContainerID;(&&) docker attach con_name| ContainerID
    # 把容器保存成新镜像mynewimage:
        docker commit ContainerID mynewimage

    ＃ 打包／恢复 一个镜像
    docker save -o myubt.tar myubt:latest
    docker save myubt:latest > myubt.tar
    docker load < my_ubt.tar

    docker tag my_image username/my_image # 修改自建镜像的名字, 否则会被hub.docker.com拒绝
    docker login ＃ 登录到hub.docker.com
    docker push username/my_image # 将自建镜像上传到hub.docker.com

    无论是Mac, Windows或是Linux, 你都可以在其上安装Docker Machine, 使用docker-machine命令来创建和管理大量的Docker hosts. 它会自动创建主机, 在主机上安装Docker Engine, 然后配置docker client. 每个被管理的主机(“machine”）都是一个Docker 主机和一个配置过的client的组合

    # docker_clean.sh: (source docker_clean.sh ImageID1 ImageID2 ImageID3)
        基本原理是用 docker save 命令保存要保留的image, 然后关闭Docker, 删除Docker.qcow2, 再启动Docker, 它会自动重建, 最后用 docker load 命令恢复保留的image
