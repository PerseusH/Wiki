\python
    python manage.py runserver 0.0.0.0:8000 #启动一个web项目|manage.py:项目启动文件

    |NetworkCoding
    -> 进程间通信
    -> socket编程
    -> 多线程
    -> Coroutine

    |Deployment
    -> 使用Debian基于包的部署是部署Python应用的极佳方案,最重要的是它可以平稳而快速的迁移代码

    |包
    -> Package是模块的集合,当解释器发现目录下有'{__init__.py}',就会认为此目录是一个Package

    |Build
        python setup.py bdist_egg #将python代码打包成egg文件,类似Java的jar
        python setup.py install #在服务器或VirtualEnv上安装, 完成部署

        pip freeze > requirements.txt #生成requirements.txt(含本地所有依赖包及版本号)
        pip install -r requirements.txt #在服务器或venv上从requirements.txt安装依赖
        -> 假如项目需要保存为'{系统模块}'(打包),或者可安装为系统命令的'{setup.py}'就必不可少
        -> 假如项目需要可以'{直接运行}',那么'{requirements.txt}'就必不可少
        -> 如果你两种功能都需要,那么就两个文件都不能少

        -> python的很多库,内部其实是C语言的,使用easy_install/pip安装的时候,往往是下载源码然后本机编译的.如果打包了,可能会出现一些莫名奇妙的问题,比如 32.64位的兼容问题,不同的操作系统的路径查找问题等等.正确的方式就是在setup.py文件中写明依赖的库和版本,然后到目标机器上安装,反正就一句python setup.py install,不算复杂

        -> vitualenv新建环境里根目录在bin/activate文件中配置
            -> VIRTUAL_ENV="/Users/username/env_x" -> VIRTUAL_ENV=`pwd`
            -> 这样就把静态根目录改成了动态获取,就能把虚拟环境打包部署到其他机器
            -> 创建虚拟环境时加--no-site-packages,就不会用主系统python里的库,环境自带lib/site-packages

\pytest
    -> python测试框架
    python -m pytest -v #自动查找'test_'开头的function,module,file,'Test'开头的class

\pyenv
    source .pyenvrc && pyenv local 3.6.3 #python版本切换
    ~/.pyenv/versions/3.6.3/lib/python3.6/site-packages

\travis-ci
    1.travis-ci.org -> settings,连接github
    2.ssh-keygen -t rsa #生成密钥~/.ssh/id_rsa,~/.ssh/id_rsa.pub
    3.将id_rsa.pub内容copy到github的repo -> settings -> deploy keys
    4.cd myproject
    5.travis encrypt-file ~/.ssh/id_rsa --add #加密,生成id_rsa.enc
    6.add .travis.yml配置文件,修改id_rsa.enc路径
    7.git push [.travis.yml,id_rsa.enc] to github
    8.git push,travis开始build,结果联动到github

\fabric
    远程部署工具,run(shell cmd),将程序包同时分发到多个hosts

\gunicorn
    -> gunicorn是一个高效的Python WSGI Server,通常用来运行WSGI(Web Server Gateway Interface,Web服务器网关接口)应用,默认长连接
    gunicorn mypy.wsgi:application -b 127.0.0.1[:8000] --reload #启动Django
    gunicorn -w 3 -b 127.0.0.1:5000 start-file-name:app -k gevent #启动Flask

\Nginx
    -> Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件(IMAP/POP3)代理服务器,并在一个BSD-like协议下发行.其特点是占有内存少,并发能力强,事实上nginx的并发能力确实在同类型的网页服务器中表现较好

    sudo /usr/local/bin/nginx #启动
    ps -ef | grep nginx,sudo kill --QUIT[--TERM] [PID] #关闭
    sudo /usr/local/bin/nginx -s reload #重启

    /usr/local/bin/nginx #主文件(非目录)
    /usr/local/etc/nginx #安装目录(含配置文件nginx.conf)
    /usr/local/cellar
    /usr/local/var/log/nginx/ #access.log,error.log etc.

    |nginx.conf
    -> location / {
            #设置主机头和客户端真实地址,以便服务器获取客户端真实IP
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            #禁用缓存???
            proxy_buffering off;

            #禁用缓存
            add_header Cache-Control no-store;

            #反向代理的地址
            proxy_pass ip | http://xxx.xxx;
        }

    |功能
    -> 反向代理 -> 通过接收Internet上的连接请求,将请求转发给内网中(nginx.conf)的目标服务器,再将从目标服务器得到的结果返回给Internet上请求连接的客户端(比如浏览器)
    -> 静态缓存 -> 将指定类型的静态文件缓存到浏览器端
    -> 负载均衡
        -> nginx的upstream默认是以轮询的方式实现负载均衡,这种方式中,每个请求按时间顺序逐一分配到不同的后端服务器,如果后端服务器down掉,能自动剔除
            upstream test.com {
                server 192.168.232.132:80;
                server 192.168.232.133:80;
            }
        -> 另外一种方式是ip_hash -> 每个请求按访问ip的hash结果分配,这样每个访客固定访问一个服务器,可以解决session的问题
            upstream test.com {
                 ip_hash;
                 server 192.168.1.251;
                 server 192.168.1.252;
                 server 192.168.1.247;
             }
             -> 当后端服务器宕机后,session会丢失
             -> 来自同一局域网的客户端会被转发到同一个后端服务器,可能导致负载失衡
             -> 不适用于CDN网络,不适用于前段还有代理的情况

    -> Django的部署可以有很多方式,采用nginx+uwsgi的方式是其中比较常见的一种方式
    -> 在这种方式中,通常做法是将nginx作为服务器最前端,它将接收WEB的所有请求,统一管理请求
    -> nginx把所有静态请求自己来处理(这是NGINX的强项).然后,NGINX将所有非静态请求通过uwsgi传递给Django,由Django来进行处理,从而完成一次WEB请求
    -> uwsgi的作用就类似一个桥接器,起到桥梁的作用

\supervisor
    -> supervisor是一个web可视化进程管理工具,可以很方便地启动、关闭和重启进程等
    /usr/local/etc/supervisord.ini #配置文件

    brew services start supervisord
    brew services stop supervisord
    brew services restart supervisord

    |添加进程模块(在supervisord.ini中添加或者在/usr/local/etc/supervisor.d/目录下添加myapp.ini)
     -> [program:myapp]
        directory = path
        command = shell_cmd

\HTTP CODE
    |300 Multiple Choices
    -> 客户请求的文档可以在多个位置找到,这些位置已经在返回的文档内列出.如果服务器要提出优先选择,则应该在Location应答头指明.
    |301 Moved Permanently
    -> 客户请求的文档在其他地方,新的URL在Location头中给出,浏览器应该自动地访问新的URL.
    |302 Found
    -> 类似于301,但新的URL应该被视为临时性的替代,而不是永久性的.
    |303 See Other
    -> 类似于301/302,不同之处在于,如果原来的请求是POST,Location头指定的重定向目标文档应该通过GET提取
    |304 Not Modified
    -> 客户端有缓冲的文档并发出了一个条件性的请求(一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档).服务器告诉客户,原来缓冲的文档还可以继续使用.
    |305 Use Proxy
    -> 客户请求的文档应该通过Location头所指明的代理服务器提取
    |307 Temporary Redirect
    -> 和302(Found)相同.许多浏览器会错误地响应302应答进行重定向,即使原来的请求是 POST,即使它实际上只能在POST请求的应答是303时才能重定向.由于这个原因,HTTP 1.1新增了307,以便更加清除地区分几个状态代码 ->  当出现303应答时,浏览器可以跟随重定向的GET和POST请求；如果是307应答,则浏览器只能跟随对GET请求的重定向.

\UWSGI:
    -> uwsgi是一个快速的.纯C语言开发的.自维护.对开发者友好的WSGI服务器,旨在提供专业的Python Web应用和发布功能(源码安装或pip安装).

    uwsgi --ini HelloWorld/hw_uwsgi.ini #使用uwsgi启动监听服务
    uwsgi --http :8001 --wsgi-file test.py #使用uwsgi启动web服务
    uwsgi --http :8001 --chdir ~/HelloWorld --wsgi-file mypy/wsgi.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191 #启动项目

\Jenkins
    -> 一个可扩展的持续集成引擎

    $Jenkins_home: ~/.jenkins
    java -jar jenkins.war --httpPort=8888 #启动
    /Library/Application Support/Jenkins/Uninstall.command #删除
    restart或者安全重启: safe-restart #重启
    safe-shutdown #停止

    |主要用于
        1.持续、自动地构建/测试软件项目
        2.监控一些定时执行的任务

    |特性包括
        1.易于安装-只要把jenkins.war部署到servlet容器,不需要数据库支持
        2.易于配置-所有配置都是通过其提供的web界面实现
        3.集成RSS/E-mail通过RSS发布构建结果或当构建完成时通过e-mail通知
        4.生成JUnit/TestNG测试报告
        5.分布式构建支持Jenkins能够让多台计算机一起构建/测试
        6.文件识别:Jenkins能够跟踪哪次构建生成哪些jar,哪次构建使用哪个版本的jar等
        7.插件支持:支持扩展插件,你可以开发适合自己团队使用的工具

\Docker
    user: perseush | pwd:  hui_123
    /usr/local/bin/docker #docker地址
    /Library/Containers/com.docker.docker/Data #镜像地址

    docker build -t runoob/ubuntu:v1 .#使用当前目录的Dockerfile创建镜像
    docker run image_name[:tag] #根据镜像启动一个Container
    docker ps -a #查看所有Containers
    Docker Daemon #docker 的守护进程
    docker tag my_img username/my_img #修改自建镜像的名字,否则会被hub.docker.com拒绝
    docker login ＃ 登录到hub.docker.com
    docker push username/my_image #将自建镜像上传到hub.docker.com

    |重启一个Exited Container
        docker start con_name | ContainerID;(&&) docker attach con_name| ContainerID
    |把容器保存成新镜像mynewimage
        docker commit ContainerID mynewimage

    |打包／恢复 一个镜像
        docker save -o myubt.tar myubt:latest
        docker save myubt:latest > myubt.tar
        docker load < my_ubt.tar

    -> 无论是Mac,Windows或是Linux,你都可以在其上安装Docker Machine,使用docker-machine命令来创建和管理大量的Docker hosts.它会自动创建主机,在主机上安装Docker Engine,然后配置docker client.每个被管理的主机(“machine”)都是一个Docker 主机和一个配置过的client的组合

    |docker_clean.sh: (source docker_clean.sh ImageID1 ImageID2 ImageID3)
        -> 基本原理是用 docker save 命令保存要保留的image,然后关闭Docker,删除Docker.qcow2,再启动Docker,它会自动重建,最后用 docker load 命令恢复保留的image
