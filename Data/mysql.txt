\CMD
    /usr/local/mysql/bin #程序目录,含mysql,mysqld,mysqiadmin等
    /usr/local/mysql/support-files/ #含mysql.server等
    mysql [-hIP] -uuser -p[pwd] [-Pport] #进入mysql | pwd: root
    mysqladmin -uusr -p[pwd] shutdown或brew services mysqld restart #重启mysql服务器
    brew services mysqld restart|brew services start|stop|restart mysql #Mac
    sudo /etc/init.d/mysql start|stop|restart #Ubuntu
    mysql.server [start|stop|restart|status]
    mysqlslap -a -c 100 -uroot -proot #压力测试工具, -c 100为并发连接数
    -> MySQL服务器允许的最大连接数16384

    mysql> show variables like 'xxx%'; #查看参数'xxxabcd'
    mysql> select version(); #查看Mysql服务器上的版本
    mysql> show engins; #查看存储引擎
    mysql> explain select ... #query性能分析
    mysql> set profiling=1; #query性能分析
    mysql> [query] \G; #竖直显示结果列表
    mysql> select found_rows(); #select后获取结果行数
    mysql> select row_count(); #update|insert|delete后获取更新的行数.高并发下可以此判断秒杀是否成功(1:修改成功, 0:未修改数据, -1:SQL错误或未执行修改SQL)
        1.update 商品表 set 库存-1 where id=商品id AND 库存!=0;
        2.select row_count(); 如果不为1，就是抢购失败。为1，就是抢购成功
    mysql> desc table_name; #显示表结构，字段类型，主键，是否为空等属性，但不显示外键
    mysql> show create table table_name; #显示建表命令语句
    mysql> show variables like '%max_connections%'; #查看最大连接数(最大并发数)
    mysql> set global max_connections=1000 #重新设置最大连接数
    mysql> show processlist; #显示当前正在执行的MySQL连接
    mysql> show status like 'Threads%'; #查看连接状态
        | Variable_name     | Value
        ---------------------------
        | Threads_cached    | 58
        | Threads_connected | 57     #打开的连接数
        | Threads_created   | 3676
        | Threads_running   | 4      #激活的连接数，一般远低于connected数值

    |TransactionIsolation
    mysql> select @@tx_isolation; #查看当前会话隔离级别
    mysql> select @@global.tx_isolation; #查看系统当前隔离级别
    mysql> set session transaction isolatin level repeatable read; #设置当前会话隔离级别
    mysql> set global transaction isolation level repeatable read; #设置系统当前隔离级别
    mysql> set autocommit=off 或者 start transaction #命令行，开始事务时

    |查看mysql服务器支持的字符集
    mysql> show character set;
    mysql> select * from information_schema.character_sets;
    mysql> select character_set_name, default_collate_name, description, maxlen from information_schema.character_sets;

    |查看字符集的排序(校对)规则
    mysql> show collation;
    mysql> show collation like 'utf8';

    |函数 -> COUNT SUM AVG MAX MIN

\配置文件/etc/my.cnf
    [mysqld]
    max_connections = 2000              //最大连接数
    lower_case_table_names = 1            //不区分大小写, 0为要区分.
    #mysql5.5以后用character_set_server=utf8 取代default-character-set=utf8
    character-set-server = utf8           //设置服务端的默认字符集
    default-collation = utf8_general_ci //排序规则

    [client]
    character-set-server = utf8           //设置客户端默认字符集

    -> mac上mysql没有自带配置文件，需手动生成/etc/my.cnf
    -> linux上mysql自带配置文件在/etc/mysql下,my.cnf和./mysql.conf.d/mysqld.cnf
    -> mysql'{默认只允许本机访问}'.在[mysqld]下设置'{bind-address=0.0.0.0}'后能远程访问
        > [mysqld]
        > skip_networking #使MySQL只能通过本机Socket连接(socket连接也是本地连接的默认方式），放弃对TCP/IP的监听
        > bind_address=127.0.0.1 #只允许本机访问.远程访问会拒绝连接(errcode:111/10061)
    -> 远程访问一个MySQL-server时需要在server上添加客户端用户和权限,'%'指所有IP都能访问
        grant all privileges on *.* to client_user@'%' identified by 'pwd';

\master-slave -> 同步前需确保主从库有相同的数据库/表结构.第一个数据行不能为空,否则报1032
    |master
        > [mysqld]
        > bind-address=0.0.0.0
        > log-bin=mysql-bin
        > server-id=last_num_of_IP

        mysql> grant all privileges on *.* to client_usr@'%' identified by 'pwd';
        mysql> show master status; #查看master状态

    |slave
        > [mysqld]
        > log-bin=mysql-bin
        > server-id=last_num_of_IP

        mysql> change master to
                master_host='IP',
                master_user='client_usr',
                master_password='pwd',
                master_log_file='mysql-bin-file',
                MASTER_LOG_POS=master-pos;
        mysql> stop slave; #终止slave
        mysql> start slave; #启动slave
        mysql> show slave status; #查看slave状态

    |errcode:1032 -> slave缺少master中数据行对象，同步失败
        |解决(slave)
        1.手动在slave中添加指定数据行
        2.mysql> stop slave;
        3.mysql> set global sql_slave_skip_counter=1; #跳过本次同步,转向下一次
        3.mysql> start slave;

\设计范式
    1.字段原子性 -> 表字段'{不能再分}'成其他几列
    2.字段依赖主键 -> 表字段直接'{依赖主键}',服务于同一功能或领域
    3.字段与主键直接相关 -> 表'{没有冗余字段}'
    反范式 -> 实际应用中常设置'{冗余字段减少联表}'查询

\命名规则
    1.数据库和表名和业务模块名一致;服务与同一个子模块的一类表应尽量以子模块名为前缀或后缀
    2.联合索引名称应尽量包含所有索引键字段名或缩写,且各字段名在索引名中的顺序应与索引键在索引中的索引顺序一致,并尽量包含一个类似idx的前缀或后缀,以表明期对象类型是索引.
    3.约束等其他对象也应该尽可能包含所属表或其他对象的名称,以表明各自的关系

\锁
    |悲观锁(Pessimistic Lock) -> 先获取锁，再进行业务操作
    -> 顾名思义,就是很悲观,'{每次}'去拿数据的时候'{都认为别人会修改}',所以每次在拿数据的时候都会上锁,这样别人想拿这个数据就会block直到它拿到锁.传统的关系型数据库里边就用到了很多这种锁机制,比如'{行锁,表锁,读锁,写锁}'等,都是在做操作之前先上锁

    |乐观锁(Optimistic Lock) -> 先进行业务操作，不到万不得已不去拿锁
    -> 顾名思义,就是很乐观,'{每次}'去拿数据的时候'{都认为别人不会修改}',所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用版本号比较等机制.乐观锁适用于多读的应用类型,这样可以提高吞吐量,像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁
    -> 版本号比较机制是在读数据的时候，将读到的数据的版本号一起读出来，当对数据的操作结束后，准备写数据的时候，再进行一次数据版本号的比较，若版本号没有变化，即认为数据是一致的，没有更改，可以直接写入，若版本号有变化，则认为数据被更新，不能写入，防止脏写
    > SELECT data AS old_data, version AS old_version FROM …;
    > 根据获取的数据进行业务操作，得到new_data和new_version
    > UPDATE SET data = new_data, version = new_version WHERE version=old_version
    > if (updated row > 0) {
    >     // 乐观锁获取成功，操作完成
    > } else {
    >     // 乐观锁获取失败，回滚并重试
    > }
    -> 乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改。如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程

    -> 两种锁各有优缺点,不可认为一种好于另一种.'{乐观锁}'适用于'{写比较少}'的情况下,即冲突很少发生的时候,这样可以省去了锁的开销,加大了系统的整个吞吐量.但如果'{经常产生冲突}',上层应用会不断的进行retry,这样反倒是降低了性能,所以这种情况下用'{悲观锁}'就比较合适

    |共享锁(S锁,读锁) -> 相互不阻塞的.其他事务'{可读不可写}'加锁对象
    -> 若事务T对对象A加上S锁,则T可以读A但不能修改A,其他事务只能再对A加S锁,而不能加X锁,直到T释放A上的S锁

    |排他锁(X锁,写锁) -> 会阻塞其他的写锁和读锁.其他事务'{不可读写}'加锁对象
    -> 若事务T对对象A加上X锁,则T可以读A也能修改A,其他事务不能再对A加任何锁,直到T释放A上的锁
    -> Mysql InnoDB 排他锁
    -> 用法: select … for update;
        > begin;
        > select * from goods where id = 1 for update;
        > update goods set stock = stock - 1 where id = 1;
        > commit;
    -> 在高并发的时候，这些业务逻辑受到 CPU 及网络等资源的限制可能会被拖慢，业务逻辑处理慢倒没什么，可怕的是数据库被拖慢，反过来又影响这些业务逻辑，形成一个滚雪球的效应，直至系统故障(假死)

    |锁的粒度和锁的策略
    -> '{MyISAM和MEMORY}'存储引擎采用的是'{表级锁}'(table-level locking);'{BDB}'存储引擎采用的是'{页面锁}'(page-level locking),但也支持表级锁;'{InnoDB}'存储引擎既支持行级锁(row-level locking),也支持表级锁,但'{默认情况下}'是采用'{行级锁}'
        |表级锁 -> 开销小,加锁快;不会出现死锁;锁定粒度大,发生锁冲突的概率最高,并发度最低
        |行级锁 -> 开销大,加锁慢;会出现死锁;锁定粒度最小,发生锁冲突的概率最低,并发度也最高
        |页面锁 -> 开销、加锁时间和锁定粒度界于表锁和行锁之间;会出现死锁;并发度一般

\事务
    |ACID
    A(Atomicity,原子性)
    -> 事务开始后所有操作,要么全部做完,要么全部不做,不可能停滞在中间环节.事务执行过程中出错,会回滚到事务开始前的状态,所有的操作就像没有发生一样
    C(Consistency,一致性)
    -> 事务开始前和结束后,数据库的完整性约束没有被破坏.比如A向B转账,不可能A扣了钱,B却没收到
    I(Isolation,隔离性)
    -> 同一时间,只允许一个事务请求同一数据,不同的事务之间彼此没有任何干扰.比如A正在从一张银行卡中取钱,在A取钱的过程结束前,B不能向这张卡转账
    D(Durability,持久性)
    -> 事务完成后,事务对数据库的所有更新将被保存到数据库,不能回滚
    -> '{原子性}'是事务隔离的'{基础}',隔离性和持久性是手段,'{最终目的}'是保持数据的'{一致性}'

    |事务隔离级别
    1.Read_Uncommitted(读取未提交内容)
    -> 在该隔离级别,所有事务都可以看到其他未提交事务的执行结果.本隔离级别很少用于实际应用,因为它的性能也不比其他级别好多少.读取未提交的数据,也被称之为脏读(Dirty Read)
    2.Read_Committed(读取提交内容)
    -> 这是'{大多数数据库系统}'的'{默认隔离级别}'(但不是MySQL默认的).它满足了'{隔离}'的简单定义:'{一个事务只能看见已提交事务所做的改变}'.这种隔离级别也支持所谓的不可重复读(Nonrepeatable Read),因为同一事务的其他实例在该实例处理期间可能有新的commit,所以同一select可能返回不同结果
    3.Repeatable_Read(可重读)
    -> 这是'{MySQL}'的'{默认事务隔离级别}',它确保同一事务的多个实例在并发读取数据时,会看到同样的数据行.不过理论上,这会导致另一个棘手的问题:幻读(Phantom Read).简单的说,幻读指当用户读取某一范围的数据行时,另一个事务又在该范围内插入了新行,当用户再读取该范围的数据行时,会发现有新的“幻影” 行.InnoDB和Falcon存储引擎通过多版本并发控制(MVCC,Multiversion Concurrency Control)机制解决了该问题
    4.Serializable(可串行化)
    -> 这是最高的隔离级别,它通过'{强制事务排序}',使之不可能相互冲突,从而'{解决幻读问题}'.简言之,它是在每个读的数据行上加上共享锁.在这个级别,可能导致大量的超时现象和锁竞争

    |事务的并发问题
    1.'脏读' -> 事务A读取了事务B更新的数据,若B回滚,那么A读取的数据就是脏数据('{绝对拒绝}')
    2.'不可重复读' -> 事务A多次读取同一{据,事务B在事务A多次读取的过程中,对数据作了更新并提交,导致事务A多次读取同一数据时,结果不一致
    3.'幻读' -> 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级,但是系统管理员B就在这个时候插入了一条具体分数的记录,当系统管理员A改结束后发现还有一条记录没有改过来,就好像发生了幻觉一样,这就叫幻读
    -> 不可重复读的和幻读很容易混淆,不可重复读侧重于修改,幻读侧重于新增或删除.解决不可重复读的问题只需锁住满足条件的行,解决幻读需要锁表

    事务隔离级别	               脏读	不可重复读	幻读
    读未提交(read-uncommitted)  是	   是	    是
    不可重复读(read-committed)  否	  是        是
    可重复读(repeatable-read)   否	   否        是
    串行化(serializable)	     否	    否        否

\存储引擎
    1.MyIASM管理非事务表,提供高速存储和检索以及全文搜索能力,如果执行大量select,应选MyIASM
    2.InnoDB用于事务处理,具有ACID事务支持等特性,如果执行大量insert和update,应选InnoDB

    |关闭Innodb引擎方法
    1.关闭mysql服务 -> net stop mysql
    2.找到mysql安装目录下的my.ini文件 ->
    3.找到default-storage-engine=INNODB 改为default-storage-engine=MYISAM
    4.找到#skip-innodb 改为skip-innodb
    5.启动mysql服务 -> net start mysql

\Sort
    |文件排序(filesort)
    -> 通过相应的排序算法,将取得的数据在内存中进行排序.MySQL需要将数据在内存中进行排序，使用的内存区域也就是我们通过sort_buffer_size系统变量设置的排序区。这个排序区是每个Thread独享的,所以说可能在同一时刻在MySQL中可能存在多个sort buffer内存区域
    -> 不能利用索引来实现排序的情况都叫做文件排序.本质上是quicksort

    |索引排序(indexsort)
    -> 比filesort快得多

\索引
    |聚簇(cluster)索引 -> 实际上是在'{同一个结构}'中保存了btree'{索引和数据行}'.叶节点就是数据节点,但是节点页只包含了索引列（或者说非叶子节点的节点页包含的是索引值的索引,因为这些节点页包含的值是从索引列中提取出来的）.键值的逻辑顺序决定了表中相应行的物理顺序
    -> 当表有索引时,它的数据行实际上存放在索引的叶子页中.聚簇表示数据行和相邻的键值紧凑地存储在一起,因为无法同时把数据行存放在两个不同的地方,所以'{一个表只能有一个聚簇索引}'
    -> '{InnoDB}'的数据存储是按聚簇索引有序排列的,'{主键是默认的聚簇索引}',因此MyISAM虽然在一般情况下查询性能高,但InnoDB的主键查询性能是非常高的

    |非聚簇索引 -> 非聚簇索引的叶节点仍然是索引节点,只不过有一个'{指针}'指向对应的'{数据块}'.逻辑顺序与磁盘上行的物理存储顺序不同

    |聚簇索引优点
    　　1.可以把相关数据保存在一起.如可以根据userid来聚集数据,这样只需要从磁盘读取少量的数据页就能获取某个用户全部数据,如果不使用聚集索引,则每获取一个数据行都可能导致一次磁盘IO
    　　2.数据访问更快.索引和数据保存在同一个btree中,因此获取数据很快
    　　3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值

    |聚集索引的缺点
    　　1.如果数据全部放在内存中,则访问的顺序就没有那么重要了,聚集索引也没有什么优势了
    　　2.'{插入速度严重依赖于插入顺序}',按照主键的顺序插入是速度最快的方式.但如果不是按照主键顺序加载数据,在加载完成后最好使用'{optimize table命令}'重新组织一下表
    　　3.更新聚集索引列的代价很高,因为会强制innodb将每个被更新的行移动到新的位置
    　　4.基于聚集索引的表在插入新行,或者主键被更新导致需要移动行的时候,可能面临页分裂的问题,当行的主键值要求必须将这一行插入到某个已满的页中时,存储引擎会将该页分裂成两个页面来容纳该行,这就是一次'{页分裂}'操作,页分裂会导致表占用更多的磁盘空间
    　　5.聚集索引可能导致'{全表扫描}'变慢,尤其是行比较稀疏,或者由于页分裂导致数据存储不连续的时候
    　　6.二级索引可能比想象的更大,因为在二级索引的叶子节点包含了引用行的主键列
    　　7.二级索引访问需要两次索引查找,而不是一次

    |索引的选择性 -> 不重复的索引值(也称为基数,cardinality)和数据表的记录总数的比值,范围从1/nT到1之间.索引的选择性越高则查询效率越高,因为选择性高的索引可以让MySQL在查找时过滤掉更多的行.唯一索引的选择性是1,这是最好的索引选择性,性能也是最好的

    |前缀索引 -> MySQL 前缀索引能有效减小索引文件的大小,提高索引的速度.但是前缀索引也有坏处->MySQL不能在ORDER BY或GROUP BY中使用前缀索引,也不能把它们用作覆盖索引(Covering Index).当前缀的选择性越接近全列选择性的时候,索引效果越好
        ALTER TABLE city ADD KEY(cityname(7)); #取城市名的前7位作为前缀索引

    |全文本索引 -> 主要用于'{关键词}'查询
    > create fulltext index idx_name on tbl(col1,[col2,col3])
    > select * from tbl where match(fulltext_col_name) against('keyword')
    -> match函数返回浮点数,表示相关度,返回的结果集相关度由高到低.相关度与关键词的次数、位置都有关系
    -> 全文索引返回的结果集是按照'{相关度}'排列的,这一点区别like、正则表达式;like、正则表达式按顺序返回,没有相关度的概念
    -> 将索引列拼成一个字符串,建立索引.索引是双b-tree(平衡树)结构,索引词是一棵树,文档指针一棵树.类似聚簇索引和二级索引,聚簇索引相当于文档指针树,二级指针相当于关键词索引树.关键词索引有些规则,太常用的词、太短的词、在停用词表中收录的词都不予生成索引
    -> innodb从5.6.4开始支持全文索引,之前版本都不支持.myisam一直支持全文索引

    |联合索引(以下均假设在数据库表的字段a,b,c上建立联合索引(a,b,c))
        alter table tbl add index idx_id_createtime(id, createtime)
    -> 联合索引中的字段应满足'{过滤数据从多到少}'的顺序,也就是说差异最大的字段应该是第一个字段
    -> 联合索引(或联合主键)的数据库要注意索引的顺序.必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引.'{SQL语句的条件顺序}'尽量'{与索引的顺序一致}',使SQL语句尽量'{以整个索引为条件}',尽量'{避免}'以索引的一部分(特别是'{首个条件与索引首字段不一致}'时)作为查询的条件
    -> Where a=1,where a>=12 and a<15,where a=1 and b<5 ,where a=1 and b=7 and c>=40为条件'{可以用到abc联合索引}'；而这些语句where b=10,where c=221,where b>=12 and c=2则'{无法用到abc联合索引}'
    -> 当需要查询的数据库字段全部在索引中体现时,数据库可以直接查询索引得到查询信息无须对整个表进行扫描(这就是所谓的key-only),能大大的提高查询效率
    -> 当a,ab,abc与其他表字段关联查询时可以用到索引
    -> 当a,ab,abc顺序而不是b,c,bc,ac为顺序执行Order by或者group by时可以用到索引
    -> 以下情况时,进行表扫描然后排序可能比使用联合索引更加有效
    1.表已经按照索引组织好了
    2.被查询的数据站所有数据的很多比例
