\CMD
    mysql -u user -p pwd #进入mysql | pwd: root
    mysqladmin -u root -p shutdown或者brew services mysqld restart #重启mysql服务器
    mysql > mysql.server [start|stop|restart|status] #mysql控制台
    -> 程序中增删改操作必需db.commit(), 否则无效
    show variables like 'xxx%'; #查看参数'xxxabcd'
    select version(); #查看Mysql服务器上的版本
    show engins; #查看存储引擎

\锁
    |悲观锁(Pessimistic Lock)
    -> 顾名思义,就是很悲观,'{每次}'去拿数据的时候'{都认为别人会修改}',所以每次在拿数据的时候都会上锁,这样别人想拿这个数据就会block直到它拿到锁.传统的关系型数据库里边就用到了很多这种锁机制,比如'{行锁,表锁,读锁,写锁}'等,都是在做操作之前先上锁

    |乐观锁(Optimistic Lock)
    -> 顾名思义,就是很乐观,'{每次}'去拿数据的时候'{都认为别人不会修改}',所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用版本号等机制.乐观锁适用于多读的应用类型,这样可以提高吞吐量,像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁

    -> 两种锁各有优缺点,不可认为一种好于另一种.'{乐观锁}'适用于'{写比较少}'的情况下,即冲突很少发生的时候,这样可以省去了锁的开销,加大了系统的整个吞吐量.但如果'{经常产生冲突}',上层应用会不断的进行retry,这样反倒是降低了性能,所以这种情况下用'{悲观锁}'就比较合适

\事务
    |ACID
    A(Atomicity,原子性)
    -> 事务开始后所有操作,要么全部做完,要么全部不做,不可能停滞在中间环节.事务执行过程中出错,会回滚到事务开始前的状态,所有的操作就像没有发生一样
    C(Consistency,一致性)
    -> 事务开始前和结束后,数据库的完整性约束没有被破坏.比如A向B转账,不可能A扣了钱,B却没收到
    I(Isolation,隔离性)
    -> 同一时间,只允许一个事务请求同一数据,不同的事务之间彼此没有任何干扰.比如A正在从一张银行卡中取钱,在A取钱的过程结束前,B不能向这张卡转账
    D(Durability,持久性)
    -> 事务完成后,事务对数据库的所有更新将被保存到数据库,不能回滚
    -> '{原子性}'是事务隔离的'{基础}',隔离性和持久性是手段,'{最终目的}'是保持数据的'{一致性}'

    |隔离级别
    1.Read_Uncommitted(读取未提交内容)
    -> 在该隔离级别,所有事务都可以看到其他未提交事务的执行结果.本隔离级别很少用于实际应用,因为它的性能也不比其他级别好多少.读取未提交的数据,也被称之为脏读(Dirty Read)
    2.Read_Committed(读取提交内容)
    -> 这是'{大多数数据库系统}'的'{默认隔离级别}'(但不是MySQL默认的).它满足了'{隔离}'的简单定义:'{一个事务只能看见已提交事务所做的改变}'.这种隔离级别也支持所谓的不可重复读(Nonrepeatable Read),因为同一事务的其他实例在该实例处理期间可能有新的commit,所以同一select可能返回不同结果
    3.Repeatable_Read(可重读)
    -> 这是'{MySQL}'的'{默认事务隔离级别}',它确保同一事务的多个实例在并发读取数据时,会看到同样的数据行.不过理论上,这会导致另一个棘手的问题:幻读(Phantom Read).简单的说,幻读指当用户读取某一范围的数据行时,另一个事务又在该范围内插入了新行,当用户再读取该范围的数据行时,会发现有新的“幻影” 行.InnoDB和Falcon存储引擎通过多版本并发控制(MVCC,Multiversion Concurrency Control)机制解决了该问题
    4.Serializable(可串行化)
    -> 这是最高的隔离级别,它通过'{强制事务排序}',使之不可能相互冲突,从而'{解决幻读问题}'.简言之,它是在每个读的数据行上加上共享锁.在这个级别,可能导致大量的超时现象和锁竞争

    |事务的并发问题
    1.'脏读' -> 事务A读取了事务B更新的数据,然后B回滚操作,那么A读取到的数据是脏数据
    2.'不可重复读' -> 事务A多次读取同一{据,事务B在事务A多次读取的过程中,对数据作了更新并提交,导致事务A多次读取同一数据时,结果不一致
    3.'幻读' -> 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级,但是系统管理员B就在这个时候插入了一条具体分数的记录,当系统管理员A改结束后发现还有一条记录没有改过来,就好像发生了幻觉一样,这就叫幻读
    -> 不可重复读的和幻读很容易混淆,不可重复读侧重于修改,幻读侧重于新增或删除.解决不可重复读的问题只需锁住满足条件的行,解决幻读需要锁表

    事务隔离级别	               脏读	不可重复读	幻读
    读未提交(read-uncommitted)  是	   是	    是
    不可重复读(read-committed)  否	  是        是
    可重复读(repeatable-read)   否	   否        是
    串行化(serializable)	     否	    否        否

\存储引擎
    1.MyIASM管理非事务表,提供高速存储和检索以及全文搜索能力,如果执行大量select,应选MyIASM
    2.InnoDB用于事务处理,具有ACID事务支持等特性,如果执行大量insert和update,应选InnoDB

    |关闭Innodb引擎方法
    1.关闭mysql服务 ->  net stop mysql
    2.找到mysql安装目录下的my.ini文件 ->
    3.找到default-storage-engine=INNODB 改为default-storage-engine=MYISAM
    4.找到#skip-innodb 改为skip-innodb
    5.启动mysql服务 -> net start mysql

\linux下设置mysql大小写敏感的问题和设置默认字体集的问题
    -> vi /etc/my.cnf:
        [mysqld]
        lower_case_table_names=1//不区分大小写, 0为要区分.
        default-character-set=utf8//设置服务端的字符集为***
        [client]
        default-character-set=utf8
