\Redis(Remote Dictionary Server)
	redis-server /etc/redis.conf #start redis
	redis-cli [-h IP] [-p port] #客户端连接
	pkill redis-server | redis-cli > shutdown #stop redis-server
	redis-cli > info #查看redis信息
	redis-sentinel /etc/sentinel.conf #start sentinel

    |特性
    1.开源免费
    2.原子性 -> 事务操作命令('{单线程}',不能打断,不能回滚,支持多操作合并后事务操作)
    3.多数据类型 -> string,list,set,sorted-set,hashset,'{比memcached多很多}'
    4.快速运算 -> '{内存}'数据库(读的速度是110000次/s,写的速度是81000次/s)
    5.数据持久化 -> 保存数据(rdb | aof)文件到磁盘,重启时再次加载使用
    6.丰富的特性 -> 支持publish/subscribe,通知,key过期等特性
    7.master-slave模式数据备份 -> 可建立高性能读写分离服务器集群
    8.'{单线程问题}'
    -> 一条命令搞死Redis.例如:keys * (建议禁用该命令并用scan替代)、对一个巨大的hash key(例如含有上亿元素的hash key)执行hget all、执行一个巨型的set bit等等,因为Redis是单线程的,在出现这些请求的时候由于它们执行速度极其缓慢而Redis的每秒请求量又比较大,因此在这些请求执行完毕前其它所有请求都会被阻塞住

	|数据存储模式
		1.cache-only
		-> 只做为'{缓存}'服务,不持久数据,数据在服务终止后将消失,此模式下也将不存在'{数据恢复}'的手,是一种安全性低/效率高/容易扩展的方式
		2.persistence
		-> 为内存中的数据持久备份到磁盘文件,在服务重启后可以恢复,此模式下数据相对安全
		|方式 -> rdb | aof

\rdb(Redis DataBase)
	|主要在
		1.客户端发起bgsave命令后
		2.instance间建立master-slave架构, master对slave的复制(replication)时
		3.配置文件中指定的save parameters满足时
		-> Redis实例会启动rdb持久化

	-> 在检测到需要产生rdb文件时,fork出一个子进程做rdb持久化,将数据写入一个临时文件,持久化结束后,用这个临时文件替换上次持久化的文件.然后Redis父进程会检测到子进程是否正常结束,对产生对rdb文件做处理

	|优点 -> 使用单独子进程来进行持久化,主进程不会进行任何IO操作,保证了redis的高性能
	|缺点 -> RDB是间隔一段时间进行持久化,如果持久化之间redis发生故障,会发生数据丢失.所以这种方式更适合数据要求不严谨的时候

	-> 这里说的执行数据写入到临时文件的时间点是可以通过配置来自己确定的,通过配置redis在n秒内如果超过m个key被修改这执行一次RDB操作.这个操作就类似于在这个时间点来保存一次Redis的所有数据,一次快照数据.所有这个持久化方法也通常叫做snapshot(快照)

\AOF(Append-Only File)
	-> 将'{操作+数据}'以格式化指令的方式追加到操作日志文件的尾部,在append操作返回后(已经写入到文件或者即将写入),才进行实际的数据变更,日志文件保存了历史所有的操作过程
	-> 类似于log的机制,每次写操作都会写到硬盘上,当系统崩溃时,可以通过AOF来恢复数据.每个带有写操作的命令被Redis服务器端收到运行时,该命令都会被记录到AOF文件上.由于只是一个append到文件操作,所以写到硬盘上的操作往往非常快

	-> aof机制包括了两件事,rewrite和AOF.
	-> rewrite类似于普通数据库管理系统日志恢复点,当AOF文件随着写命令的运行膨胀时,当文件大小触碰到临界时,rewrite会被运行
	-> rewrite操作就是'{压缩}'AOF文件的过程
	-> rewrite过程并不阻塞客户端请求,系统会开启一个子进程来完成
	-> rewrite会像replication一样,fork出一个子进程,创建一个临时文件,遍历数据库,将每个key-value对输出到临时文件.输出格式就是Redis的命令,但是为了减小文件大小,会将多个key-value对集合起来用一条命令表达.在rewrite期间的写操作会保存在内存的rewrite buffer中,rewrite成功后这些操作也会复制到临时文件中,在最后临时文件会代替AOF文件
	-> 以上在AOF打开的情况下,如果AOF是关闭的,那么rewrite操作可以通过bgrewriteaof命令来进行

	|流程
		1.Redis Server启动,如果AOF机制打开那么初始化AOF状态,并且如果存在AOF文件,读取AOF文件
		2.随着Redis不断接受命令,每个写命令都被添加到AOF文件,AOF文件膨胀到需要rewrite时又或者接收到客户端的bgrewriteaof命令
		3.fork出一个子进程进行rewrite,而父进程继续接受命令,现在的写操作命令都会被额外添加到一个aof_rewrite_buf_blocks缓冲中
		4.当子进程rewrite结束后,父进程收到子进程退出信号,把aof_rewrite_buf_blocks的缓冲添加到rewrite后的文件中,然后切换AOF的文件fd. rewrite任务完成,继续第二个步骤

	|优点
		1.可以保持更高的数据完整性(安全性),如果设置追加file的时间是1s,发生故障最多丢失1s的数据
		2.如果日志写入不完整支持redis-check-aof来进行日志修复
		3.AOF文件没被rewrite之前(文件过大时会对命令进行合并重写),可以删除其中的某些命令(比如误操作的flushall)
	|缺点 -> AOF文件比RDB文件大,且恢复速度慢

\Persistence
	-> 在架构良好的环境中,master通常使用AOF,slave使用snapshot,主要原因是master需要首先确保数据完整性,它作为数据备份的第一选择;slave提供只读服务(目前slave只能提供读取服务),它的主要目的就是快速响应客户端read请求
	-> 但是如果你的redis运行在网络稳定性差/物理环境糟糕情况下,建议你master和slave均采取AOF,这个在master和slave角色切换时,可以减少'{人工数据备份}'/'{人工引导数据恢复}'的时间成本
	-> 如果你的环境一切非常良好,且服务需要接收密集性的write操作,那么建议master采取snapshot,而slave采用AOF

\双机热备
	-> 也就是一台主服务器对外提供访问,而从服务器stand by,当主服务器挂了,然后从服务器自动升为主服务器,保证系统能正常运行,而原来的主服务器修复好了之后,变为从服务器.双机热备,能提高项目的高可用
	-> 为了解决服务器单点风险问题
	-> 单点问题,也就是说在真实的生产环境中,只有一台服务器使用,然而服务器不可能永远不出问题,当服务器由于某种原因不能正确响应请求,或者宕机了,整个应用就无法使用了,这存在着很大的风险.在生产环境中,无论哪一层,都应该规避单点问题,包括数据库层,负载均衡层,中间件层等
	-> 对于redis而言,实现双机热备功能有很多实现方式,可用通过keepalived+redis,zookeeper+redis,或者redis本身自带的sentinel都是可以实现的

\主从同步
	|redis.conf
	-> daemonize yes #redis server后台运行
	-> 需要bind 本机外网IP [127.0.0.1], protect-mode -> no, requirepass -> pwd
	-> slave -> slaveof MasterIP Port

\Sentinel
	-> protected-mode no #sentinel.conf添加
	-> Redis实例的监控管理、通知和实例失效备援服务,是Redis集群的管理工具.在一般的分布式中心节点数据库中,Sentinel的作用是中心节点的工作,监控各个其他节点的工作情况并且进行故障恢复,主从切换,来提高集群的高可用性

\Keepalived
	|作用
		-> 是检测服务器的状态,如果有一台web服务器宕机,或工作出现故障,Keepalived将检测到,并将有故障的服务器从系统中剔除,同时使用其他服务器代替该服务器的工作,当服务器工作正常后Keepalived自动将服务器加入到服务器群中,这些工作全部自动完成,不需要人工干涉,需要人工做的只是修复故障的服务器
	|原理分析
		1.keepalived主要是虚拟ip(VIP),两台服务器虚拟出一个共同的ip,但是同一时间只能有一台服务器拥有此虚拟ip,当主服务器挂了,自动进行ip漂移
		2.keepalived主要采取的是健康检测方式,检测本身redis服务是否正常,如果出现了异常,则降低自己的优先级(和weight做加法),然后keepavlied内部进行推选新的主服务器

\mysql-redis集群
	?????
