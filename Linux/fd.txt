|FD(file descriptor文件描述符) -> 一个和打开的文件相关联的整数, 是内核为了高效管理已被打开的文件所创建的索引.Unix程序在执行任何形式的'IO系统调用'时,程序是在读写一个文件描述符. 这个文件可能是一个网络连接，FIFO，管道，终端，磁盘上的文件. Unix系统中一切皆可看成是文件
-> 程序刚启动时，0是标准输入，1是标准输出，2是标准错误. 如果此时打开一个新文件，文件描述符为3

|系统级限制 -> 一般最大打开文件数会是系统内存的10%（以KB来计算）sysctl -a | grep fs.file-max
|用户级限制 -> 默认值一般是1024，使用ulimit -n 查看

-> 每一个文件描述符会与一个打开文件相对应，不同的文件描述符也会指向同一个文件.系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符

|内核维护3个数据结构
    1. 进程级的文件描述符表. 每个条目记录了单个文件描述符的相关信息(控制文件描述符操作的一组标志和'对系统级打开文件描述符表的打开文件句柄的引用')
    2. 系统级的打开文件描述符表(也称为打开文件表 open file table)
        内核维护了一个系统级打开文件描述符表(open file description table).表格中各条目称为'打开文件句柄（open file handle）', 这个句柄存储了一个打开文件的信息.如下所示
            1. 当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）
            2. 打开文件时所使用的状态标识（open()的flags参数）
            3. 文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）
            4. 与信号驱动相关的设置
            5. 一个指向打开文件inode对象的指针
            6. 文件类型（例如：常规文件、套接字或FIFO）和访问权限
            7. 一个指针，指向该文件所持有的锁列表
            8. 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳
    3. 文件系统的'inode表'(系统级)

|inode -> 重要概念，是理解Unix/Linux文件系统和硬盘储存的基础
    -> 硬盘的最小存储单位叫做'扇区 Sector'。每个扇区储存512字节（0.5KB）
    -> 操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个'块 block'。这种由多个扇区组成的"块"，是文件存取的最小单位。"块"的大小，最常见的是4KB，即'连续八个sector组成一个block'
    -> 文件数据都储存在块中，很显然我们还必须找到一个地方储存文件的元信息，'比如文件的创建者、创建日期、大小(没有文件名)'等。'储存文件元信息的区域就叫做inode'，中文译名为"索引节点"
    -> '每一个文件都有对应的inode, Unix/linux系统内部不使用文件名, 用inode号码来识别不同的文件'. 对于系统来说，文件名只是inode号码便于识别的别称
        -> 系统内部'打开文件的过程'分成三步
            1.系统在系统索引表中找到这个文件名对应的inode号码
            2.通过inode号码，获取文件的inode table
            3.根据文件的inode table中的Pointer，找到文件数据所在的block，读出数据
        -> 'Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件'. 目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码
        -> 一个文件系统里的文件分为目录文件和普通文件这两类。 如果文件分配方式是索引分配的话，则有索引节点这个概念的出现
        -> inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。每个inode节点的大小一般是128字节或256字节
        -> 目录文件的'读权限（r）和写权限（w）'，都是针对'目录文件'本身（即不同用户能以什么权限访问操作对该目录文件，例如这里不同用户对tmp目录文件（d可以查出tmp是目录文件，d表示directory，即目录）分别为rwxr-xr-x，第一组的三个字符，即rwx，表示文件拥有者用户的对该文件的读写权限，第二组的三个字符，即r-x，表示文件拥有者用户所在的用户组里的其他用户对该文件的读写权限，第三组的三个字符，即r-x，表示文件拥有者用户所在的用户组以外的用户对该文件的读写权限。一个某个用户下运行的进程访问操作该目录文件只能以该用户所具有的对该目录文件的权限进行操作）。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）

        |文件创建过程 -> 先查找一个空的Inode，写入新的Inode table，在系统索引表中创建文件名和Inode码的对应关系，向block中写入文件内容
        |在同一个文件系统中移动文件过程 -> 在系统索引表中创建一个新的文件名和Inode的对应关系，然后在系统索引表中删除旧的信息，更新CTIME，其他的信息如Inode等等均无任何影响
        |删除文件过程 -> 实质上是减少link count，当link count为0时，就表示这个Inode可以使用，并把Block标记为可写,但'并不清除Block里面数据'，只有在有新文件需要占用block时，才会被覆盖

        |硬链接 -> 不同的文件名访问同样的内容(多个文件名指向同一个inode号码). inode信息中有一项叫做"链接数"，指向该inode的文件名总数，新建一个硬链接时就会加1, 删除一个文件名就会减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码及其对应的block区域
            -> link不依赖源文件存在, 删除源文件再访问link不会报错. 但是对文件内容进行修改，会影响到所有文件. '不能对目录进行创建，只能对文件创建硬链接'. 只能对已存在的文件进行创建
            -> 创建目录时，默认会生成两个目录项："."和".."。前者的inode号码就是当前目录的inode号码，等同于当前目录的硬链接；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的硬链接。任何一个'目录的硬链接'总数总是等于2（当前目录和父目录）
            -> 硬链接其实不是创建新文件，只是在系统索引表中写入了新文件名和Inode码的对应关系而已
        |软链接 -> link指向源文件的文件名，而不是源文件的inode号码，inode"链接数"不会发生变化
            -> link赖源文件存在, 删除源文件再访问link会报错. '软链接可以对文件或目录创建'. 可以对不存在的文件或目录创建

        |inode的特殊作用 -> 'inode号码与文件名分离'的机制导致了一些Unix/Linux系统特有的现象
        　　1. 有时文件名包含特殊字符，无法正常删除。这时'直接删除inode节点'，就能删除文件
        　　2. '移动文件或重命名文件'，只是改变文件名，'不影响inode号码'
        　　3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此'系统无法从inode号码得知文件名'
            -> 第3点使得'软件更新'变得简单，可以在'不关闭软件的情况下进行更新'，不需要重启。因为'系统通过inode号码，识别运行中的文件'，不通过文件名。更新的时候，新版文件'以同样的文件名，生成一个新的inode'，不会影响到运行中的文件。等到下一次运行这个软件的时候，'文件名就自动指向新版的inode，旧版文件的inode则被回收'
    -> 由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时就'无法在硬盘上创建新文件'

    |i-node内容
    　　* 文件的字节数
    　　* 文件拥有者的User ID
    　　* 文件的Group ID
    　　* 文件的读、写、执行权限
    　　* 文件的时间戳，共有三个：ctime指inode上一次修改的时间，mtime指文件内容上一次修改的时间，atime指文件上一次打开的时间
    　　* 链接数，即有多少文件名指向这个inode
    　　* 文件数据block的位置

    |CMD
        $ stat example.txt #查看某个文件的inode信息
        $ ls -i example.txt #查看文件名对应的inode号码
        $ ls -i /etc #列出整个目录的文件名和inode号码
        $ df -i #查看每个硬盘分区的inode总数和已经使用的数量
        $ sudo dumpe2fs -h /dev/hda | grep "Inode size" #查看每个inode节点的大小
