|CAP原理 -> 分布式系统架构不可能同时满足一致性, 可用性和分区容错性
    |一致性 -> 所有数据更新都是同步的
    |可用性 -> 好的响应性能. 每个请求都会收到一个（非错误）响应 - 不保证它包含最新的写入
    |分区容错性 -> 尽管任意数量的消息被节点之间的网络丢弃（或延迟），系统仍继续运行

    -> 架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍

|幂等性(Idempotence) -> 操作一次和操作多次的副作用一样(接口支持重入: 防止某长时间操作等待过程中, 用户多次刷新页面提交重试, 每次重试都返回第一次操作的结果)
    |http -> 获取用GET, 更新用PUT
    |数据库阻挡重试 -> Insert:依赖唯一键,冲突回滚掉 Update:消息状态表(状态机)+消息队列

    -> 通过引入支持分布式事务的中间件来保证更新的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，但却无法提供性能和可用性的保证
    -> 和分布式事务(中间件)相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择
    -> 实际情况下消息很难具有幂等性，解决方法是使用另一个表记录已经被成功应用的消息，即消息队列和消息应用状态表一起来解决问题

|BASE
    |Basically Available -> 基本可用 支持分区失败(e.g. sharding碎片划分数据库)
    |Soft state -> 软状态 状态可以有一段时间不同步，异步
    |Eventually consistent -> 最终一致性 最终数据是一致的就可以了，而不是时时高一致
        -> 通过异步事件实现
        -> 电商的很多业务，考虑更多的是'BASE'，而不是ACID(Atomicity、Consistency、Isolation和 Durability)。即为了满足高负载的用户访问，可以容忍短暂的数据不一致
            1.不做分布式事务，代价太大
            2.不一定需要实时一致性，只需要保证最终一致性即可
            3.通过状态机和严格的有序操作，来最大限度地降低不一致性

        -> 如果消息具有操作幂等性，也就是一个消息被应用多次与应用一次产生的效果是一样的话，那么把不需要同步执行的事务交给异步消息推送(MQ中间件)和订阅者集群(服务架构功能模块)来处理即可。假如消息处理失败，那么就消息重播，由于幂等性，应用多次也能产生正确的结果
