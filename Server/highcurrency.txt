\系统吞吐量
    -> 从业务上来讲，可以理解为系统每秒钟最大能接受的用户访问量。或者每秒钟最大能处理的请求数
    |QPS: 每秒钟'处理完成'请求的次数。具体是指发出请求到服务器处理完成功返回结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS.多用于衡量'单个接口'的处理能力
    |TPS：每秒钟'处理完成'的事务次数(系统1s能完成多少事务处理). 一个事务在分布式处理中，可能会对应多个请求. TPS多用于衡量整个系统的处理能力
    |并发量：(在平均响应时间内)系统能同时处理的请求数 | 并发量 = QPS * 平均响应时间
    |RT：响应时间，处理一次请求所需要的平均处理时间

\DataStructure
    -> 高并发系统的设计，关键在合理的'数据结构'的设计，而不在架构的套用
    |Bitmap -> 每个位代表一个数据(40亿个数据大概要 40*10^8 bit = 0.5GB)
        -> 若给定空间有限, 则可将数据集分块筛选后再进行位图运算
        -> 如: 从40亿数据找出一个不存在的数据
            1.将数据分成许多块，每块大小是1000，第一块代表0到999，第2块代表1000到1999 ……
            2.实际上我们并不保存这些数，而是给每一个块设置一个计数器。这样每读入一个数，就在它所在的块对应的计数器加1。处理完成后找到计数器值小于块大小(1000)的块，其中一定有数字是数据集所不包含的。然后我们单独处理这个块即可
            3.接下来用BitMap算法。再次遍历数据，把落在选定块的数对应的bit置1(先把这个数归约到0到blocksize之间)。 最后找到这个块中第一个为0的位，其对应的数就是数据集中没有出现的数
        |实现
            N / coresize = array-number <=> N >> n
            N % coresize = index-of-array <=> N & 11111...
            arr[N>>n] |= 1 << (N&11111...) #将对应数组的对应位置1
            arr[N>>n] &= ~(1 << (N&11111...)) #将对应数组的对应位置0

        |应用
            1.空闲内存管理
            2.空闲磁盘块管理
            3.大数据排序, 查找, 去重

    |RB-Tree -> epoll fd tree

    |TrieTree -> 又称字典树, 前缀树, 单词查找树或键树，是哈希树的变种。典型应用是用于统计和排序大量的字符串(但不仅限于字符串),经常用于搜索引擎词频统计。优点是最大限度地减少无谓的字符串比较，查询效率比哈希表高; 缺点是空间消耗很大
        -> TrieTree的插入和查询时间复杂度都为O(k), k为字符串的长度，与Tree中保存了多少个元素无关。Hash表号称是O(1)的，但在计算hash的时候就肯定会是O(k)，因为有碰撞之类的问题
        -> 核心思想是空间换时间。利用字符串的'公共前缀'来降低查询时间的开销, 提高效率
        -> 根结点为空; 非根节点标识是否为单词
        int trie[maxn][26]; # TrieTree是一个二维数组或动态指针结点嵌套
        trie[i][j] = k; # i: 字符输入序号, j: 0-25字母表序号, k: i字符的子节点编号

        |代码
            class Node:
                def __init__(self, chr=''):
                    self.chr = chr
                    self.childList = []
                    self.isEnd = False

                def findNode(self, chr):
                    for node in self.childList:
                        if node.chr == chr:
                            return node
                    return None

            class TrieTree:
                ... ...

                root = Node()

                #构建Trie Tree
                def insert(words):
                    currentNode = root
                    for c in words:
                        node = currentNode.findNode(c)
                        #如果不存在该节点则添加
                        if not node:
                            n = Node(c)
                            currentNode.childList.append(n)
                            currentNode = n
                        else
                            currentNode = node
                    currentNode.isEnd = True #在词的最后一个字符节点标记为true

                #判断Trie Tree中是否包含该词
                def search(word):
                    currentNode = root
                    for i in word:
                        node = currentNode.findNode(i)
                        if node:
                            currentNode = node
                            #判断是否为词的尾节点
                            if node.isEnd and node.chr == word[-1]:
                                return True
                        else:
                            return False

        |应用
            1.串的快速检索 -> 给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。输入框智能提示
                -> 在这道题中，我们可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。
            2.串排序 -> 给定N个互不相同的仅由一个单词构成的英文名，按字典顺序从小到大输出
                -> 用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可。
            3.最长公共前缀 -> 对所有串建立字典树，对于两个串的最长公共前缀的长度即他们所在的结点的公共祖先个数，于是问题就转化为当时公共祖先问题

    |B-Tree/B+Tree
        -> B-Tree每个节点都有数据
        -> B+Tree只在叶子结点存储数据, 查找效率比较平均. 非叶子结点(索引)体积小, 可以一次性被更多地读进内存, 从而减少磁盘IO; 叶子结点间有(链表)指针连接, 实现了范围查询. 数据结构为链表

        |应用 -> 文件系统, 数据库索引

    |Queue

    |Hashmap

    |Stack

    |Heap

    |ConsistentHashing

\Pattern
    |生产者消费者模式

    |发布订阅模式

\Cache
    |CDN -> 内容分发网络（Content delivery network或Content distribution network）。把内容分发到世界各地的节点上，让各地的人都可以在距离最近的节点拿到需要的内容，减少网络传输距离从而达到加速的目的（需要提过资源绝对地址告诉cdn厂商，让厂商去智能拉取）
        -> CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有'内容存储和分发'
        -> CDN是一个经策略性部署的整体系统，包括'分布式存储、负载均衡、网络请求的重定向和内容管理'4个要件，而'内容管理和全局流量管理(Traffic Management)'是CDN的核心所在
        -> 当用户发起内容请求时，通过cdn厂商的智能DNS域名解析拿到cdn厂商边缘节点服务器的ip（cdn厂商会在运营商注册），然后向边缘节点服务器发起请求，请求内容数据(这件事情由浏览器完成)，边缘节点会检测当前节点是否有数据，如果没有就去front（父级节点，父级可能还会有父级节点，不同的网络环境策略会略有不同）节点要，如果还找不到就去源站拿，并依次序返回。如果某个边缘节点可以找到，会先校验内容有效期，当确定有效期之后返回给用户
        -> 适用于静态的，改动较小的资源(html/js/css/影音), 服务端收到请求时不做渲染直接返回给用户. 动态页面不适合做cdn加速, 因为经常变动导致边缘节点验证资源有效期容易失效然后请求源站

        |关键技术
            （1）内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处；
            （2）内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，以使用户请求得到最近内容源的响应；
            （3）内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在POP的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；
            （4）性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态

        |主要特点
            1、本地Cache加速 提高了企业站点(尤其含有大量图片和静态页面站点)的访问速度，并大大提高以上性质站点的稳定性
            2、镜像服务 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。
            3、远程加速 远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度
            4、带宽优化 自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。
            5、集群抗攻击 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量

    |Redis

    |StaticCache

    |HttpCache

    |LRU-Cache

\Distribute


\Database


\Middleware


\MultipleIPs
    |浏览器并发数 -> 如果页面静态资源（图片等）过多（大于6个）会存在资源请求等待的情况。目前现实状况是大多用户带宽越来越大，但是静态资源并非那么大，很多文件都是几k或者几十k，6个文件加起来都小于带宽。这样就导致了资源的浪费。解决方案是：用多个不同IP的服务器来存储这些文件，并在页面中通过绝对路径的方式引用（要求同一IP的文件不超过6个）。这样就可以尽可能的减少资源请求等待的情况
