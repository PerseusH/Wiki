-> http是Web三大组成部分之一 #uri(资源)，http(管道)，html(容器)
-> GET和POST只有一点根本区别, GET用于获取数据, POST用于修改数据

\HTTP Code
    |300 Multiple Choices
    -> 客户请求的文档可以在多个位置找到,这些位置已经在返回的文档内列出.如果服务器要提出优先选择,则应该在Location应答头指明.
    |301 Moved Permanently
    -> 客户请求的文档在其他地方,新的URL在Location头中给出,浏览器应该自动地访问新的URL.
    |302 Found
    -> 类似于301,但新的URL应该被视为临时性的替代,而不是永久性的.
    |303 See Other
    -> 类似于301/302,不同之处在于,如果原来的请求是POST,Location头指定的重定向目标文档应该通过GET提取
    |304 Not Modified
    -> 客户端有缓冲的文档并发出了一个条件性的请求(一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档).服务器告诉客户,原来缓冲的文档还可以继续使用.
    |305 Use Proxy
    -> 客户请求的文档应该通过Location头所指明的代理服务器提取
    |307 Temporary Redirect
    -> 和302(Found)相同.许多浏览器会错误地响应302应答进行重定向,即使原来的请求是 POST,即使它实际上只能在POST请求的应答是303时才能重定向.由于这个原因,HTTP 1.1新增了307,以便更加清除地区分几个状态代码 ->  当出现303应答时,浏览器可以跟随重定向的GET和POST请求；如果是307应答,则浏览器只能跟随对GET请求的重定向.

\HTTP1.1
    -> HTTP 1.0规定浏览器与服务器只保持短暂的连接,浏览器的每次请求都需要与服务器建立一个TCP连接,服务器完成请求处理后立即断开TCP连接,服务器不跟踪每个客户也不记录过去的请求
    -> HTTP 1.1支持长连接,在一个TCP连接上可以传送多个HTTP请求和响应,减少了建立和关闭连接的消耗和延迟
    -> HTTP 1.1还允许客户端不用等待上一次请求结果返回,就可以发出下一次请求,但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果,以保证客户端能够区分出每次请求的响应内容,这样也显著地减少了整个下载过程所需要的时间
    -> HTTP 1.1中增加Host请求头字段,WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点,这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点
    -> HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头

\RESTful
    1.一切网络对象都被抽象成一种资源(URI唯一资源标识符, 都是名词)
    2.客户端和服务器之间, 传递这种资源的某种表现层
    3.客户端通过四个HTTP动词, 对服务器端资源进行操作, 实现"表现层状态转化"
    4.http操作无状态, 减少上下文依赖, 降低耦合
    5.目的是简化http操作, 使网站软件化, 防止跨站攻击

\Network Attack
    |中间人攻击 -> 把目标计算机放在两台计算机中间, 劫持信息
       |解决 -> https(由SSL(安全套接层)进行网站身份验证和加密传输数据)
           https原理 -> 客户端与服务器端握手交换对称密钥, 接下来传输加密信息
           -> https协议需要到ca申请证书,一般免费证书很少,需要交费
           -> http是超文本传输协议,信息是明文传输,https则是具有安全性的ssl加密传输协议
           -> http和https使用的是完全不同的连接方式,用的端口也不一样,前者是80,后者是443
           -> http的连接很简单,是无状态的;HTTPS协议是由SSL+HTTP协议构建的可进行加密传输,身份认证的网络协议,比http协议安全
       -> 如何生成共享秘钥???
       -> 什么是分组加密？加密模式有哪些？ecb和cbc模式有什么区别？为什么需要iv向量？
       -> 对称加密与非对称加密区别？

    |跨站攻击 -> 脚本注入(js死循环|js生成隐藏iframe,用表单将用户输入发送到ifr.src所指服务器)
       |解决 -> 用户输入html转义(import cgi;cgi.escape('<script>') -> &lt;script&gt;)
       -> htmlescape后能否避免xss????????

    |伪造请求 -> 在请求中插入恶意参数, 破坏服务器
       |解决 -> 提高攻击的门槛
       1.RESTful API
       -> 对发帖等创建资源的操作,应该只接受POST请求,而GET请求应该只浏览而不改变服务器端资源,这样攻击者就不能通过发布链接来伪造请求(屏蔽PUT,DELETE)
       2.请求令牌(服务器端验证过一定记得销毁)
       -> 服务器生成随机令牌(random string-token in Session),在发出请求的页面,把该令牌以隐藏域与其他信息一并发出.在接收请求的页面,把接收到的令牌与Session中的令牌比较,只有一致的时候才处理请求,否则返回403拒绝请求或者要求用户重新登陆验证身份
       3.验证码(服务器端验证过一定记得销毁): ?????????需要手动输入, 用户体验差

    |DDos??????????????

    |csrf?????????????
    -> django是如何防范的???

    |SQL Inject?????????????

\Encryption
   1.md5(key)
   2.md5(md5(key) + salt) #salt = substr(uniqid(rand()), -6)
