-> http是Web三大组成部分之一 #uri(资源),http(管道),html(容器)
-> GET和POST只有一点根本区别, GET用于获取数据, POST用于修改数据
PV(page view) -> 浏览量,用户每打开一个页面就被记录1次.用户多次打开同一页面,浏览量值累计
UV(user view) -> 访客量,一天之内的独立访客数(以Cookie为依据).一天内同一访客多次访问只计算1个
日活 -> 每日活跃用户数

刷新页面出现from disk/memory cache -> ctrl+shift+r(Chrome) | ctrl+F5

-> 服务器端返回Etag或Last-Modified后,浏览器再次访问会发送if-none-match或if-modified-since,若前后相等则返回304,否则返回最新资源:
    > response.headers["Etag"] = datahash
    > response.headers["Last-Modified"] = modified_time

    > request.headers["If-None-Match"]
    > request.headers["If-Modified-Since"]
-> Etag 主要为了解决 Last-Modified 无法解决的一些问题:
    1.一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET;
    2.某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)
    3.某些服务器不能精确的得到文件的最后修改时间

\HTTP Code
    |300 Multiple Choices
    -> 客户请求的文档可以在多个位置找到,这些位置已经在返回的文档内列出.如果服务器要提出优先选择,则应该在Location应答头指明.
    |301 Moved Permanently
    -> 客户请求的文档在其他地方,新的URL在Location头中给出,浏览器应该自动地访问新的URL.
    |302 Found
    -> 类似于301,但新的URL应该被视为临时性的替代,而不是永久性的.
    |303 See Other
    -> 类似于301/302,不同之处在于,如果原来的请求是POST,Location头指定的重定向目标文档应该通过GET提取
    |304 Not Modified
    -> 客户端有缓冲的文档并发出了一个条件性的请求(一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档).服务器告诉客户,原来缓冲的文档还可以继续使用.
    |305 Use Proxy
    -> 客户请求的文档应该通过Location头所指明的代理服务器提取
    |307 Temporary Redirect
    -> 和302(Found)相同.许多浏览器会错误地响应302应答进行重定向,即使原来的请求是 POST,即使它实际上只能在POST请求的应答是303时才能重定向.由于这个原因,HTTP 1.1新增了307,以便更加清除地区分几个状态代码 ->  当出现303应答时,浏览器可以跟随重定向的GET和POST请求；如果是307应答,则浏览器只能跟随对GET请求的重定向.

\HTTP1.1
    -> HTTP 1.0规定浏览器与服务器只保持短暂的连接,浏览器的每次请求都需要与服务器建立一个TCP连接,服务器完成请求处理后立即断开TCP连接,服务器不跟踪每个客户也不记录过去的请求
    -> HTTP 1.1支持长连接,在一个TCP连接上可以传送多个HTTP请求和响应,减少了建立和关闭连接的消耗和延迟
    -> HTTP 1.1还允许客户端不用等待上一次请求结果返回,就可以发出下一次请求,但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果,以保证客户端能够区分出每次请求的响应内容,这样也显著地减少了整个下载过程所需要的时间
    -> HTTP 1.1中增加Host请求头字段,WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点,这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点
    -> HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头

\RESTful
    1.一切网络对象都被抽象成一种资源(URI唯一资源标识符, 都是名词)
    2.客户端和服务器之间, 传递这种资源的某种表现层
    3.客户端通过四个HTTP动词, 对服务器端资源进行操作, 实现"表现层状态转化"
    4.http操作无状态, 减少上下文依赖, 降低耦合
    5.目的是简化http操作, 使网站软件化, 防止跨站攻击

\Network Attack
    |中间人攻击 -> 把目标计算机放在两台计算机中间, 劫持信息
       |解决 -> https(由SSL(安全套接层)进行网站身份验证和加密传输数据)
           |https原理 -> 客户端与服务器端握手交换'{对称密钥}', 接下来传输加密信息
           -> https协议需要到ca申请证书,一般免费证书很少,需要交费
           -> http是超文本传输协议,信息是明文传输,https则是具有安全性的ssl加密传输协议
           -> http和https使用的端口不一样,前者是80,后者是443
           -> http的连接很简单,是无状态的;HTTPS协议是由SSL+HTTP协议构建的可进行加密传输,身份认证的网络协议,比http协议安全

       -> 如何生成共享秘钥?
           |共享秘钥 -> 服务器端和用户共同拥有一个或一组密码
           -> IPSec协议中引入了一个密钥管理协议,称'{Internet密钥交换协议IKE}',该协议可以动态认证IPSec对等体,协商安全服务,并自动生成共享密钥

       -> 什么是分组加密？加密模式有哪些？ecb和cbc模式有什么区别？为什么需要iv向量？
           |分组密码 -> 将明文消息编码表示后的数字（简称明文数字）序列，'{划分成长度为n的组}'（可看成长度为n的矢量），每组分别在密钥的控制下变换成等长的输出数字（简称密文数字）序列.明文组经过加密得到密文组，密文组经过解密，还原成明文组

           |加密模式 -> ECB,CBC,CFB,OFB
               |ecb -> 将明文切分成若干小段，再进行加密
               |cbc -> 将明文切分成若干小段，然后每一小段与'{初始块(iv向量)}'或者上一段的密文段进行'{异或}'运算后，再进行加密

           |iv向量 -> cbc'{初始加密}'时进行异或运算

       -> 对称加密与非对称加密区别？
           |对称加密 -> 采用单钥密码系统的加密方法,同一个密钥可以同时用作信息的加密和解密.'{加密与解密速度快}',但由于需要将'{密钥在网络传输}',所以安全性不高
           |非对称加密 -> 为数据的加密与解密提供了一个'{非常安全}'的方法,它使用了一对密钥,公钥(public key)和私钥(private key).私钥只能由一方安全保管,不能外泄,而公钥则可以发给任何请求它的人.非对称加密使用这对密钥中的一个进行加密,而'{解密则需要另一个密钥}'.比如,你向银行请求公钥,银行将公钥发给你,你使用公钥对消息加密,那么只有私钥的持有人--银行才能对你的消息解密。银行不需要将私钥通过网络发送出去,因此安全性大大提高,但'{加密与解密速度慢}'
           |Best Practice -> 将'{对称密钥}'使用'{非对称加密的公钥}'进行加密,然后发送出去,接收方使用'{私钥解密}'得到对称加密的密钥,然后双方可以使用'{对称加密}'进行安全的沟通(用非对称加密封装对称加密)

    |xss -> js脚本注入
        |反射型 -> js死循环|js生成隐藏iframe,提交到服务器,服务器把恶意脚本渲染出来,再用表单将用户输入发送到iframe.src所指服务器
        |DOM型 -> 不经过服务器端,直接在客户端完成
        |存储型 -> 将脚本存入数据库

    -> htmlescape后能否避免xss?
        -> 替换尖括号、引号等特殊符号,只解决了'{html}'的问题,'{不能完全防御XSS}'.因为<script>是javascript输出点,xss的'{目标是破坏js构造}'而不是html构造.html构造中的关键字符是尖括号、双引号、“&”符号等.而js构造就复杂了,比如换行、注释（//和/*）、引号（包括单引号）等都会改变构造.需要'{在htmlescape外加一层js_encode}'

        |解决
        1.输入验证(客户端,服务器端)
        2.view过滤
        3.html转义+js_encode(import cgi;cgi.escape('<script>') -> &lt;script&gt;)
        4.渲染时用Mako一类的模板库可以避免大部分情况下的XSS,图片URL需要显式防范
        5.jinjia2里safe标签,无法绕过,防范xss的最常见手段

    |csrf(跨站伪造请求) -> 在请求中(url&cookie)插入恶意参数, 破坏服务器
       |解决 -> 提高攻击的门槛
       1.RESTful API
       -> 对发帖等创建资源的操作,应该只接受POST请求,而GET请求应该只浏览而不改变服务器端资源,这样攻击者就不能通过发布链接来伪造请求(屏蔽PUT,DELETE)
       2.请求令牌(服务器端验证过一定记得销毁)
       -> 服务器生成随机令牌(random string-token in Session),在发出请求的页面,把该令牌以隐藏域与其他信息一并发出.在接收请求的页面,把接收到的令牌与Session中的令牌比较,只有一致的时候才处理请求,否则返回403拒绝请求或者要求用户重新登陆验证身份
       3.验证码(服务器端验证过一定记得销毁): 需要手动输入, 用户体验差
       4.django通过'{中间件}'django.middleware.csrf.CsrfViewMiddleware实现防止csrf
       |全局 -> settings->MIDDLEWARE=['django.middleware.csrf.CsrfViewMiddleware']
       |局部 -> from django.views.decorators.csrf import csrf_exempt,csrf_protect
       -> @csrf_protect,为当前函数'{强制设置}'防csrf功能,即便settings中没有设置全局中间件
       -> @csrf_exempt,'{禁用}'当前函数防跨站请求伪造功能,即便settings中设置了全局中间件

    |DDos
        |解决 -> 查询netstat的连接数,同IP超过一定连接的用iptables封禁一段时间,脚本加入cron每分钟执行

    |SQL Inject
        |解决
        -> 使用参数查询,不要拼接SQL字符串('%s' % args).用现成的SQL封装库
        -> 使用cur.execute+参数预编译,python会自动过滤args中的特殊字符,防止SQL注入的产生
        cur.execute('select id, name from tb where id=%s and name=%s', (id, name))

\Encryption
   1.md5(key)
   2.md5(md5(key) + salt) #salt = substr(uniqid(rand()), -6)
