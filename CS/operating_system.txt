-> 批处理系统

|指令的执行状态 -> 用户态

-> 计算机指令执行过程的控制信号

\进程
	|并行 -> 两个或两个以上事件或活动在同一时刻发生. 在多道程序环境下, 并行性使'多个程序同一时刻'可在不同CPU上同时执行
	|并发 -> 实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用, 并发性是对'有限物理资源'强制行使'多用户共享'以提高效率
		|进程/线程间的互斥和同步
			|临界区 -> 缓冲区, 消息队列
			|生产者消费者模式 ->
			|互斥锁 -> 不可跨线程访问. 只允许一个线程进入临界区
			|信号量 -> 可跨进程/线程访问. 同时允许多个进程/线程进入临界区. 计数器 + 等待队列

	缓冲区的出现是为了减少频繁的系统调用，由于系统调用需要保存之前的进程数据和状态等信息，而结束调用之后回来还需要回复之前的信息，为了减少这种耗时耗性能的调用于是出现了缓冲区。在linux系统中，每个进程有自己独立的缓冲区，叫做进程缓冲区，而系统内核也有个缓冲区叫做内核缓冲区

	|内核缓冲区 -> 主要思想就是一次读入大量的数据放在缓冲区，需要的时候从缓冲区取得数据
		-> 管理员模式和用户模式之间的切换需要消耗时间，但相比之下，磁盘的IO操作消耗的时间更多，为了提高效率，内核也使用缓冲区技术来提高对磁盘的访问速度。磁盘是数据块的集合，内核会对磁盘上的数据块做缓冲。内核将磁盘上的数据块复制到内核缓冲区中，当一个用户空间中的进程要从磁盘上读数据时，内核一般不直接读磁盘，而是'将内核缓冲区的数据复制到进程缓冲区'中。当进程所要求的数据块不在内核缓冲区时，内核会把相应的数据块加入到请求队列，然后把该进程挂起，接着为其他进程服务。一段时间之后(其实很短的时间)，内核把相应的数据块从磁盘读到内核缓冲区，然后再把数据复制到进程的缓冲区中，最后唤醒被挂起的进程

	当'进程'需要指定的'磁盘数据'的时候，进程'先到内核缓冲区'去看看数据是否在内核缓冲区，如果没有，内核把读取磁盘中此数据的请求添加到内核的请求队列，然后挂起此进程，等解决了别的进程的问题之后，磁盘中的数据也读取到了内核缓冲区，然后复制数据到进程缓冲区，接着唤醒这个被挂起的进程，进程从自己的进程缓冲区中拿到数据，然后继续工作

	但是一般的操作系统在存储数据的时候也并不是立即存储的，这个是磁盘文件系统设计的问题，有些UNIX操作系统除外，相对数据安全，但是IO不可避免的会降低。'操作系统使用read函数把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区中'。至于什么时候读取和存储则由内核来决定，内核缓冲区满则存储到磁盘，读取的时候内核缓冲区空则从磁盘读取到内核缓冲区中，当然，在写入的时候如果系统突然关闭则会造成内核缓冲区的数据无法存储到磁盘的事情发生

\内存管理
	|重定位 -> 将逻辑地址转换为物理地址
		|公式 -> 物理地址 = 起始物理地址 + 逻辑地址

	|虚拟内存
		-> 通过地址映射将离散的物理地址组织为面向程序的连续逻辑地址
	 	-> 内存满时在磁盘上开辟临时空间存储内存交换出的数据
		|地址映射 -> 逻辑地址 -> 物理地址(主存内地址, 磁盘外地址)

		|连续内存分配 -> 固定分区和可变分区

		|非连续内存分配
			|请求分页存储管理 -> 将逻辑地址空间分成固定大小的页,将内存分成页大小的物理块(页帧)
				-> 逻辑地址=高位逻辑页号*2**偏移位数+低位页内偏移(2**偏移位数=每页容量大小)
				-> 物理地址 = 物理页帧号*2**偏移位数 + 页内偏移
				|页表 -> 每个进程都有一张, 内容为每个页对应的'物理页帧号'
					-> 多个进程可共享同一页帧
				|快表 -> 如果页表在内存中, 那么每次访问内存物理块时, CPU需要先查询页表, 再根据得到的物理地址访问内存, 实际访问了两次内存. 为了提高访问速度, 可以把页表暂存到Cache
					-> TLB(Translation Lookaside Buffer)转换检测缓冲区是一个内存管理单元,用于改进虚拟地址到物理地址转换速度的缓存。
					-> TLB是一个小的，虚拟寻址的缓存，其中每一行都保存着一个由单个PTE(Page Table Entry,页表项)组成的块。如果没有TLB，则每次取数据都需要两次访问内存，即查页表获得物理地址和取数据
				|地址变换机构 -> 页表寄存器. 利用页表把程序逻辑地址转换为内存物理地址
				-> 只有作业的最后一页可能产生零头(碎片)

			|请求分段存储管理 -> 根据程序逻辑结构将内存分段

			|段页式存储管理 -> 先按照程序逻辑结构分段, 每个段再按照单位页大小分页. 计算开销大, 方便调度, 数据安全和共享

		|零头(碎片) -> 内零头指分配给进程的未被利用的存储空间，外零头指系统中无法利用的小存储块
			-> 内零头: 固定分区和请求页式存储; 外零头: 可变分区和请求段式存储
			-> 解决方法是移动所有已占用区域, 使所有碎片拼接成连续区域

		|局部性原理
			|时间局部性 -> 当前被访问的数据近期很可能再次被访问.产生原因: 程序循环,堆栈等
			|空间局部性 -> 当前被访问的存储地址临近的地址近期很可能被访问
			|顺序局部性 -> 除跳转指令外,大部分程序指令都是顺序执行的(包括数组的顺序访问)

		|LRU算法 -> 利用时间戳选出上次使用时间最远的内存页进行调度交换.'系统开销巨大'
			|硬件
				|移位寄存器 -> 记录某进程中各内存页的使用情况，每个内存页都会配置一个
				|栈 -> 利用一个特殊的栈来保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶(重复访问不会新增页面)。因此栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面
			|替代方案
				1.最不经常使用页面置换算法
				2.最近没有使用页面置换算法
				3.最优页面置换算法 -> 难以实现. 仅用于评估其他算法

		|页面分配策略 -> 进程生命周期内根据进程情况固定分配页帧数; 可变分配进程页帧数
		|页面置换策略 -> 页面置换算法作用于整个系统的为全局置换; 只作用于本进程的为局部置换

		|缺页中断 -> 一个页是一个固定容量的内存区块，是物理内存和外部存储(如硬盘等) 传输的单位。当程序访问一个映射到地址空间但实际上并未加载到物理内存的页时，硬件向软件发出的一次中断（或异常）就是一个缺页中断或叫页错误（page fault）
		|缺页率 -> 可变分配局部置换策略可获得较高的内存空间利用率又能保证每个进程较低的缺页率
		|抖动(thrashing) -> 在分页存储管理系统中，内存中只存放了那些经常使用的页面，而其它页面则存放在外存中，当进程运行需要的内容不在内存时，便启动磁盘读操作将所需内容调入内存，若内存中没有空闲物理块，还需要将内存中的某页面置换出去。也就是说，系统需要不断地在内外存之间交换信息。若在系统运行过程中，刚被淘汰出内存的页面，过后不久又要访问它，需要再次将其调入。而该页面调入内存后不久又再次被淘汰出内存，然后又要访问它。如此'反复访问磁盘'，使得系统把大部分时间用在了页面的调入/换出上，而几乎不能完成任何有效的工作，这种现象称为抖动
			|产生原因 -> 同时运行的进程数过多，进程频繁访问的页面数高于可用的物理块数，造成进程运行时'频繁缺页'。CPU利用率太低时，调度程序就会增加多道程序度，将新进程引入系统中，反而进一步导致处理机利用率的下降
			|解决方法
				1.工作集 -> 一段时间内, 进程实际要访问的页面集合. 引入虚拟内存后, 程序只需少量内存就可运行, 但是为了使程序较少产生缺页中断, 需保证进程的工作集页都分配到物理块(系统为每个工作集分配不小于其本身的物理块). 应限制进程数, 使所有工作集的总尺寸不超过内存
					|工作集窗口 -> 一个时间概念，不是说动态集合分配的页框数。而是过去k次（不含当前）访问的页面记号。比如工作集窗口大小是3，那么一个访问串为：0，2，3，2，1，4 则当访问页面4时，往前看3个，1，2，3在被窗口覆盖，因此驻留集中页面是3，2，1
					-> 工作集精确度与窗口尺寸 ∆ 的选择有关。如果 ∆ 太小，那么它不能表示进程的局部特征；如果 ∆ 为无穷大，那么工作集合是进程执行需要的所有页面的集合
					-> 每个进程都有一个工作集. 如果所有工作集之和增加到超过了可用物理块的总数，操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动
					-> 工作集页面置换法的基本思想：找出一个不在工作集中的页面，把它淘汰
					-> 根据局部性原理，进程会在一段时间内相对稳定在某些页面构成的工作集上
					|驻留集 -> 每个进程当前驻留在物理内存中的页面子集
					-> 缺页率与系统为进程分配物理块的多少（驻留集的大小）有关。缺页率随着分配物理块的增加而减少

					|利用工作集进行驻留集调整的策略
						-> 操作系统监视每个进程的工作集变化情况
						-> 只有当一个进程的工作集在内存中时才执行该进程
						-> 定期淘汰驻留集中不在工作集中的页面
						-> 总是让驻留集包含工作集(不能包含时则增大驻留集)
				2.采用局部置换策略 -> 仅允许进程在自身范围内进行置换。即使发生抖动，也可以把影响限制在较小范围内
				3.挂起优先级低的进程, 将释放的内存分配给其他进程

\IO
	-> 磁盘空间被划分为许多大小相同的块（Block）或者页(Page), 这些块以链表的方式串联在一起
	|磁盘缓存 -> 将磁盘上与当前数据块关联的数据块(都是连续存储)拷贝到内存中, 可'减少IO'次数
		-> 高速缓存即Cache是为了解决CPU主频与内存运行速度相差太大的问题。磁盘缓存是在用户态动态分配的内存. 缓存都偏重于'读操作'
		-> 磁盘高速缓存在逻辑上属于磁盘，物理上则是驻留在内存中的数据块
		-> 存放的是从别处拷贝的数据

	|磁盘缓冲区Buffer -> 内存区域, 用来保存设备之间或应用程序和设备之间传输的数据
		|作用
			1.缓和高速设备和低速设备间的速度差异
			2.协调传输数据包大小不一致的设备
			3.解耦高速和低速设备(高速设备不必等待低速设备,直接将数据写入缓冲区),提高系统并行性
			4.减少IO次数(高速设备写入缓冲区, 区满后再一次性写入低速设备)

		|类型
			1.全缓冲 -> 当填满标准IO缓存后才进行实际IO操作。例如对磁盘文件的读写
			2.行缓冲 -> 在输入和输出中遇到换行符时，执行真正的IO操作。输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的IO操作。例如键盘输入数据
			3.不进行缓冲 -> 例如标准出错情况stderr，可以尽快显示出错信息

		-> 偏重于磁盘'写操作'
		-> 存放的是别处传输过来的数据, 一般没有备份
		-> 缓冲区满或关闭文件时都会刷新缓冲区，进行真正的IO操作
		-> 缓冲区溢出的时候，多余出来的数据会直接将之前的数据覆盖

-> '假定下列指令已装入指令寄存器. 则执行时不可能导致CPU从用户态变为内核态(系统态)的是?'
	1.DIV R0, R1;(R0)/(R1)→R0
	2.INT n; 产生软中断
	3.NOT R0; 寄存器R0的内容取非
	4.MOV R0, addr; 把地址处的内存数据放入寄存器R0中

-> '会导致进程从执行态变为就绪态的事件是?'
	1.执行P(wait)操作
	2.申请内存失败
	3.启动I/O设备
	4.被高优先级进程抢占

-> 文件系统的顺序分配方式, 文件系统的链接分配方式, 以及文件的存储

-> 总线定时 >>> 异步通信,全互锁协议是否最慢,非互锁协议的可靠性是否最差 >>> 同步通信,时钟信号是否可由多设备提供 >>> 半同步通信,握手信号的采样是否由同步时钟控制

-> 磁盘转速 >>> 平均寻道时间 >>> 扇区数 >>> 访问一个扇区的平均存取时间

-> '若系统S1 采用死锁避免方法, S2采用死锁检测方法,那么'
	1.S1会限制用户申请资源的顺序
	2.S1需要进行所需资源总量信息, 而S2不需要
	3.S1不会给可能导致死锁的进程分配资源, S2会

-> '系统为某进程分配了4个页框, 该进程已访问的页号序列为2,0,2,9,3,4,2,8,2,3,8,4,5, 若进程要访问的下一页的页号为7, 依据LRU算法, 应淘汰页的页号是?'
	1.2
	2.3
	3.4
	4.8

-> '在系统内存中设置磁盘缓冲区的主要目的是?'
	1.减少磁盘IO次数
	2.减少平均寻道时间
	3.提高磁盘数据可靠性
	4.实现设备无关性

-> '在文件的索引节点中存放直接索引指针10个, 一级二级索引指针各1个, 磁盘块大小为1KB. 每个索引指针占4个字节. 若某个文件的索引节点已在内存中, 到把该文件的偏移量(按字节编址)为1234和307400处所在的磁盘块读入内存. 需访问的磁盘块个数分别是?'
	1.1, 2
	2.1, 3
	3.2, 3
	4.2, 4

-> '在请求分页系统中, 页面分配策略与页面置换策略不能组合使用的是?'
	1.可变分配, 全局置换
	2.可变分配, 局部置换
	3.固定分配, 全局置换
	4.固定分配, 局部置换
