->  算法的时间复杂度和空间复杂度

\栈
    -> 程序运行
    -> 调用过程
    -> 尾递归
    -> 中缀和后缀表达式的转化  √

\链表
    -> LRU算法(双向循环链表)  √
    -> 用单链表保存m个整数，节点的结构为(data,link)，且|data|<n(n为正整数)。现要求设计一个时间复杂度尽可能高效地算法，对于链表中绝对值相等的节点，仅保留第一次出现的节点而删除其余绝对值相等的节点

    |串
    -> KMP匹配算法
    -> BM算法  √

    |数组
    -> 顺序存储结构
    -> 矩阵的压缩存储
    -> 十字链表  √

    |广义表
        -> 链式存储结构  √

\排序
    1.插入排序（希尔排序-间隔-组内排序）
    2.起泡排序
    3.快速排序
    4.基数排序
    5.选择排序
    6.归并排序
    7.外部排序  √

\二叉树
    -> 遍历顺序（先序，中序，后序）
    -> 中序线索化二叉树，找出左右线索
    -> 哈夫曼树  √
    -> 二叉树的带权路径长度的求法

    |森林转化为二叉树
        -> 二叉链表（*firstchild, *nextsibling）  √

    |二叉排序树(BST)
    -> 平衡二叉树(AVL)
    -> 红黑树-B-树
    -> B+树
    -> 数字查找树（键树）  √

|折半查找
    -> 关键字比较序列

|哈希表（散列）
    -> 处理冲突堆积现象影响的因素  √

|堆
    -> 小根堆

\图
    |图的邻接矩阵
    -> 深度优先遍历
    -> 广度优先遍历
    -> 拓扑排序
    -> 关键路径  √

    |带权图的最小（代价）生成树
    -> 克鲁斯卡（kruskal）算法
    -> 普里姆（Prim）算法
    -> 旅行商问题  √

    |最短路径
    -> Dijkstra算法
    -> Floyd算法  √

->  动态存储管理  √

\查找
    -> 顺序查找
    -> 分块查找  √

\Application
	-> 顺序表:数组
	-> 链表:进程管理,管程的条件变量
	-> 栈:堆栈
	-> 后缀表达式:计算器
	-> 队列:任务列表
	-> 树:菜单结构,多级进程,语法解析,文档结构,堆
	-> 二叉树:描述分类过程和处理判定优化(人工智能),压缩编码(哈夫曼树,通信原理),排序
	-> 线索二叉树:将树结构转化为双向链表,实现了线性遍历
	-> B树/B+树:关系型数据库结构
	-> 有向图:通信网络,工程关系,课程关系,有限状态机
	-> 无向图:最短路径算法
	-> 二叉树
	-> 栈/队列
	-> 字符串操作
