-> Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine '共享同一个地址空间'
-> 当一个协程在写map的时候，其他协程如果试图去读或者写这个map，程序会直接崩溃
-> 所有 goroutine 在 main() 函数结束时会一起结束

|调度 -> goroutine 由Go程序'runtime调度和管理'
    -> Go 程序在启动时，runtime会默认为 main() 函数创建一个 goroutine
    -> goroutine属于抢占式任务处理.当前goroutine只有涉及到'锁操作和读写channel'才会触发线程切换
    -> Go运行的时候包涵一个'自己的调度器'，这个调度器使用一个称为一个M:N调度技术，m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，'不需要切换到内核'语境，所以goroutine的'调度开销远远小于线程'
    -> 'OS的线程'由OS'内核调度'，每隔几毫秒，一个'硬件时钟中断'发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存中恢复线程的注册表信息，最后继续执行选中的线程

    runtime.Gosched() // 显式地让出CPU时间给其他goroutine
    runtime.Goexit() //函数用于终止当前的goroutine，但defer函数将会继续被调用

package main
import (
        "fmt"
        "time"
)
func say(s string) {
        for i := 0; i < 5; i++ {
                time.Sleep(100 * time.Millisecond)
                fmt.Println(s)
        }
}
func main() {
        go say("。。。") //goroutine
        go say("！！！") //goroutine
        go say("world") //goroutine
        say("hello")
}

|闭包问题
    var wg sync.WaitGroup
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func() {
            fmt.Println(i)
            wg.Done()
        }()
    }
    wg.Wait()
    >>>
    5
    5
    5
    5
    5
    -> 启动一个goroutine的速度远小于循环执行的速度，所以即使是第一个goroutine刚起启动时，外层的循环也执行到了最后一步了。由于所有的goroutine共享i，而且这个i会在最后一个使用它的goroutine结束后被销毁，所以最后的输出结果都是最后一步的i==5
    |解决方案
    1.
        ...
        go func(i int) {
            fmt.Println(i)
            wg.Done()
        }(i)
        ...
    2.
        ...
        i := i //同名变量覆盖
        go func() {
            fmt.Println(i)
            wg.Done()
        }()
        ...
    3.
        ...
        ch := make(chan int, 1)
    	for i:=0; i<5; i++ {
    		go func(){
    			ch <- 1
    			fmt.Println(i)
    		}()
    		<- ch //阻塞直到上面的goroutine完成通道写操作
    	}
        ...
