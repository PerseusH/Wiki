\Start
    git init #初始化一个本地仓库(add .git dir,删除本级.git,本级文件／目录权限收归上级.git)
    git clone git@xbc.me:wordpress.git #Clone远程仓库
    |暂存区 -> 是个简单的文件，放在.git目录中(index)
    |HEAD -> 就是当前活跃分支的指针.指示当前位置
    |origin -> 默认情况下的远程仓库的名字
    |upstream -> fetch的上游目标仓库
    -> Forking工作流需要2个远程别名 —— 一个指向正式仓库，另一个指向开发者自己的服务端仓库。别名的名字可以任意命名，常见的约定是使用origin作为远程克隆的仓库的别名（这个别名会在运行git clone自动创建），upstream（上游）作为正式仓库的别名

\远程仓库管理
    git remote add origin git@github:robbin/robbin.git #添加远程版本库origin
    git remote set-url origin git@github:robbin/robbin.git #修改远程仓库地址
    git remote set-head origin master #设置远程仓库的HEAD指向master分支

    |设置本地分支跟踪远程分支
    git branch --set-upstream-to=origin/remote local #new
    git branch --set-upstream local origin/remote #old

    git remote rm <repository> #删除远程仓库
    git remote -v #查看远程服务器地址和仓库名称
    git remote show origin #查看远程服务器仓库状态
    git clone --bare robbin_site robbin_site.git  #用带版本的项目创建纯版本仓库
    scp -r my_project.git git@git.csdn.net:~      #将纯仓库上传到服务器上
    mkdir robbin_site.git&&cd robbin_site.git&&git --bare init #在服务器创建纯仓库

\提交修改
    git add .                 #添加当前修改的文件到暂存区
    git add -u                #自动追踪文件，包括你已经手动删除的，状态为Deleted的文件
    git commit –[a]m "xxx"    #提交到本地库. -am = git add . + git commit -m 'xxx'
    git commit <file>|.       #提交到本地库. 需在文件中写注释
    git commit --a            #git add + git rm + git commit
    git commit --amend        #修改最后一次提交注释
    git push origin master    #推送到远程服务器
    git cherry-pick <cmt_id>  #把已经提交的commit从一个分支添加到另一个分支

    |忘记提交某些修改，下面的三条命令只会得到一个提交
    git commit –m "xxx" && git add readme_forgotten && git commit --amend

\分支
    git br -r                 #查看远程分支
    git br <new_branch>       #创建新的分支
    git br -v                 #查看各个分支最后提交信息
    git br --merged           #查看已经被合并到当前分支的分支
    git br --no-merged        #查看尚未被合并到当前分支的分支
    git br -d <branch>        #删除某个分支
    git br -D <branch>        #强制删除某个分支 (未被合并的分支被删除的时候需要强制)

    git checkout <branch>     #切换到某个分支
    git checkout -b <new_br> #创建新的分支，并切换过去
    git checkout -b <new_br> <branch>  #基于branch创建新的new_br，并切换过去
    git checkout $id          #checkout出某次提交,但无分支信息,切换到其他分支会自动删除
    git checkout $id -b <new_branch>  #checkout出某次提交并新建一个分支

    git pull <远程主机名> <远程分支名>[:<本地分支名>]
    git pull                        #抓取远程仓库所有分支更新并合并到本地
    git pull --no-ff                #抓取远程仓库所有分支更新并合并到本地,不要快进合并
    git checkout --track origin/br  #跟踪某个远程分支创建相应的本地分支
    git checkout –b br origin/br    #根据远程分支建立本地分支

    git push <远程主机名> <本地分支名>[:<远程分支名>] [-f] #将本地推到远程(-f为强制执行)
    git push                        #push所有分支
    git push origin <br>[:<remote_br>] #创建本地分支到远程.不跟踪(upstream)
    git push origin :<remote_br>    #本地分支删除后,再删除对应远程分支
    git push --set-upstream|-u origin <br> #将本地分支首次推到远程,如无则创建并跟踪(add upstream br->origin/br)

    |分支合并和rebase
    git fetch origin                 #抓取远程仓库更新，但不会更新合并到本地，要merge
    git merge origin/master          #将远程主分支合并到本地当前分支,本地自动生成新提交
    git merge <branch>               #将branch分支合并到当前分支(快进当前分支到branch)
    git merge origin/master --no-ff  #不要Fast-Foward合并，这样可以生成merge提交

    -> rebase和merge合并得到的结果没有任何区别，但是rebase能产生一个'{更整洁有序}'的提交历史
    git rebase master <branch>       #等于: git checkout br && git rebase master
    (rebase后)git co master&&git merge br #快进到br的最新commit
    git checkout br && git rebase master && git checkout master && git merge br
        #把branch分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(放到.git/rebase目录中),然后把branch分支更新为最新的master分支，再把保存的补丁应用到branch分支上.最后快进master到branch的最新commit
    git rebase -i [origin/master]    #合并多个commit为一个(pick a commit,squash else:'s'), 默认为合并当前分支commits
    git rebase -i HEAD~2             #合并前两个commit

\Tag
    -> 指向某个commit的指针,commit的别名.用作代码的历史版本管理
    git tag                   #查看当前分支下所有标签信息
    git tag -a <tag> [-m <comment>] <commitid> #给指定commit打标签
    git tag -d <tag>          #删除标签
    git push origin :<tag>    #删除远程标签(必须先删除本地标签)
    git show <tag>            #查看标签下某版本信息
    git checkout tag          #切换到标签
    git push origin <tag>     #发布标签到远程(必须先创建本地标签)
    git push origin --tags    #发布全部标签到远程


\查看、添加、提交、删除、找回，重置修改文件
    git status                #查看文件状态
    git help <checkoutmmand>  #显示checkoutmmand的help
    git show $id              #显示某次提交的内容
    git log                   #查看提交记录
    git log <file>            #查看该文件每次提交记录
    git log -p <file>         #查看每次详细修改内容的diff
    git log -p -2             #查看最近两次详细修改内容的diff
    git log --stat            #查看提交统计信息
    cat .git/config           #查看分支详情

    git checkout <file>|.     #撤销工作文件(所有)修改
    git add <file>|.          #将工作文件(所有)修改提交到本地暂存区并跟踪
    git reset <file>|.        #从暂存区恢复到(所有)工作文件
    git reset HEAD b          #git add .将修改过的文件a、b加到暂存区后,撤回b,保留a
    git reset --hard          #恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改
    git reset --hard <cmt_id> #彻底回退到某个版本
    git rm <file>             #从当前跟踪列表移除文件，并完全删除
    git rm –cached <file>     #仅在暂存区删除，保留文件在当前目录，不再跟踪
    git mv <file> <file1>     #重命名文件

    git stash                 #暂存所有修改
    git stash list|apply|drop #列出|恢复|删除暂存内容

    git revert <$id>          #恢复某次提交的状态，恢复动作本身也创建了一次提交对象
    git revert HEAD           #恢复最后一次提交的状态

\初始化配置(用户的git配置文件~/.gitconfig)
    git config --global user.name "USERNAME"    #配置姓名
    git config --global user.email email        #配置email
    git config -l                               #列举所有配置
    git config --global credential.helper 'cache --timeout=3600' #修改缓存时间
    git config --global credential.helper cache #配置到缓存 默认15分钟
    git config --global color.ui true
    git config --global alias.co checkout
    git config --global alias.ci commit
    git config --global alias.st status
    git config --global alias.br branch
    git config --global core.editor "mate -w"   #设置Editor使用textmate

\git diff
    git diff <file>                  #比较当前文件和暂存区文件差异
    git diff <$id1> <$id2>           #比较两次提交之间的差异
    git diff <branch1>..<branch2> #在两个分支之间比较
    git diff --staged                #比较暂存区和版本库差异
    git diff --cached                #比较暂存区和版本库差异
    git diff --stat                  #仅仅比较统计信息
    -> Mac上可以使用tig代替diff和log，brew install tig

\Git补丁管理(方便在多台机器上开发同步时用)
    git diff > ../sync.patch         #生成补丁
    git apply ../sync.patch          #打补丁
    git apply --check ../sync.patch  #测试补丁能否成功

\错误
    1."You are not currently on a branch, so I cannot use any"
    -> git checkout master
    2."Your branch and 'bruce/dev' have diverged,and have 6 and 1 different commits each, respectively"
    -> git rebase
    3."There is no tracking information for the current branch...""
    -> 说明本地分支和远程分支的链接关系没有创建，用命令：
    -> git branch --set-upstream-to=origin/remote local
    4."![rejected] dev -> dev (non-fast-forward)  ... Updates were rejected because the tip of your current branch"
    -> 推送失败，因为远程的最新提交和推送的提交有冲突
    -> 先用git pull把最新的提交从origin/dev抓下来在本地合并，解决冲突，再推送
    5."Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded"
    -> 意思是，有一个更新还没有反应到本地来，可能是别人往server上提交了一点东西
    -> 使用git pull命令更新到本地来
    6."pull或rebase后大量冲突"
    -> 当前分支是基于一个较旧的分支建立或很久没有更新
    -> git co -b newbr origin/master && cherry-pick #基于最新分支新建一个开发分支
    7.git clone 远程仓库报错error setting certificate verify locations
    -> 执行命令 git config --system http.sslverify false
    8.git  config报错：fatal: not in a git directory
    -> cd .../git && git init #将当前目录git作为git目录
    9.fatal: unable to access 'https://github.com/barakmich/go-nyet/': OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054
    -> 这样设置即可 git config http.postBuffer 524288000

\github(acfdc768bd59823972b74f3f5391f702720b6b89)
    -> repo -> settings(last part) -> delete #删除repo
    -> github-pages只能建立在master/master-docs/gh-pages之上
